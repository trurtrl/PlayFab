// This is automatically generated by PlayFab SDKGenerator. DO NOT modify this manually!
#pragma once

#include "CoreMinimal.h"
#include "Core/PlayFabBaseModel.h"

namespace PlayFab
{
namespace ServerModels
{

    struct PLAYFAB_API FAdCampaignAttribution : public FPlayFabBaseModel
    {
        // UTC time stamp of attribution
        FDateTime AttributedAt;

        // [optional] Attribution campaign identifier
        FString CampaignId;

        // [optional] Attribution network name
        FString Platform;

        FAdCampaignAttribution() :
            FPlayFabBaseModel(),
            AttributedAt(0),
            CampaignId(),
            Platform()
            {}

        FAdCampaignAttribution(const FAdCampaignAttribution& src) :
            FPlayFabBaseModel(),
            AttributedAt(src.AttributedAt),
            CampaignId(src.CampaignId),
            Platform(src.Platform)
            {}

        FAdCampaignAttribution(const TSharedPtr<FJsonObject>& obj) : FAdCampaignAttribution()
        {
            readFromValue(obj);
        }

        ~FAdCampaignAttribution();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FAdCampaignAttributionModel : public FPlayFabBaseModel
    {
        // UTC time stamp of attribution
        FDateTime AttributedAt;

        // [optional] Attribution campaign identifier
        FString CampaignId;

        // [optional] Attribution network name
        FString Platform;

        FAdCampaignAttributionModel() :
            FPlayFabBaseModel(),
            AttributedAt(0),
            CampaignId(),
            Platform()
            {}

        FAdCampaignAttributionModel(const FAdCampaignAttributionModel& src) :
            FPlayFabBaseModel(),
            AttributedAt(src.AttributedAt),
            CampaignId(src.CampaignId),
            Platform(src.Platform)
            {}

        FAdCampaignAttributionModel(const TSharedPtr<FJsonObject>& obj) : FAdCampaignAttributionModel()
        {
            readFromValue(obj);
        }

        ~FAdCampaignAttributionModel();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FAddCharacterVirtualCurrencyRequest : public FPlayFabBaseModel
    {
        /**
         * Amount to be added to the character balance of the specified virtual currency. Maximum VC balance is Int32
         * (2,147,483,647). Any increase over this value will be discarded.
         */
        int32 Amount;

        // Unique PlayFab assigned ID for a specific character owned by a user
        FString CharacterId;

        // PlayFab unique identifier of the user whose virtual currency balance is to be incremented.
        FString PlayFabId;

        // Name of the virtual currency which is to be incremented.
        FString VirtualCurrency;

        FAddCharacterVirtualCurrencyRequest() :
            FPlayFabBaseModel(),
            Amount(0),
            CharacterId(),
            PlayFabId(),
            VirtualCurrency()
            {}

        FAddCharacterVirtualCurrencyRequest(const FAddCharacterVirtualCurrencyRequest& src) :
            FPlayFabBaseModel(),
            Amount(src.Amount),
            CharacterId(src.CharacterId),
            PlayFabId(src.PlayFabId),
            VirtualCurrency(src.VirtualCurrency)
            {}

        FAddCharacterVirtualCurrencyRequest(const TSharedPtr<FJsonObject>& obj) : FAddCharacterVirtualCurrencyRequest()
        {
            readFromValue(obj);
        }

        ~FAddCharacterVirtualCurrencyRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FAddFriendRequest : public FPlayFabBaseModel
    {
        // [optional] Email address of the user being added.
        FString FriendEmail;

        // [optional] The PlayFab identifier of the user being added.
        FString FriendPlayFabId;

        // [optional] Title-specific display name of the user to being added.
        FString FriendTitleDisplayName;

        // [optional] The PlayFab username of the user being added
        FString FriendUsername;

        // PlayFab identifier of the player to add a new friend.
        FString PlayFabId;

        FAddFriendRequest() :
            FPlayFabBaseModel(),
            FriendEmail(),
            FriendPlayFabId(),
            FriendTitleDisplayName(),
            FriendUsername(),
            PlayFabId()
            {}

        FAddFriendRequest(const FAddFriendRequest& src) :
            FPlayFabBaseModel(),
            FriendEmail(src.FriendEmail),
            FriendPlayFabId(src.FriendPlayFabId),
            FriendTitleDisplayName(src.FriendTitleDisplayName),
            FriendUsername(src.FriendUsername),
            PlayFabId(src.PlayFabId)
            {}

        FAddFriendRequest(const TSharedPtr<FJsonObject>& obj) : FAddFriendRequest()
        {
            readFromValue(obj);
        }

        ~FAddFriendRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FAddPlayerTagRequest : public FPlayFabBaseModel
    {
        // Unique PlayFab assigned ID of the user on whom the operation will be performed.
        FString PlayFabId;

        // Unique tag for player profile.
        FString TagName;

        FAddPlayerTagRequest() :
            FPlayFabBaseModel(),
            PlayFabId(),
            TagName()
            {}

        FAddPlayerTagRequest(const FAddPlayerTagRequest& src) :
            FPlayFabBaseModel(),
            PlayFabId(src.PlayFabId),
            TagName(src.TagName)
            {}

        FAddPlayerTagRequest(const TSharedPtr<FJsonObject>& obj) : FAddPlayerTagRequest()
        {
            readFromValue(obj);
        }

        ~FAddPlayerTagRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FAddPlayerTagResult : public FPlayFabBaseModel
    {
        FAddPlayerTagResult() :
            FPlayFabBaseModel()
            {}

        FAddPlayerTagResult(const FAddPlayerTagResult& src) :
            FPlayFabBaseModel()
            {}

        FAddPlayerTagResult(const TSharedPtr<FJsonObject>& obj) : FAddPlayerTagResult()
        {
            readFromValue(obj);
        }

        ~FAddPlayerTagResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FAddSharedGroupMembersRequest : public FPlayFabBaseModel
    {
        // An array of unique PlayFab assigned ID of the user on whom the operation will be performed.
        TArray<FString> PlayFabIds;
        // Unique identifier for the shared group.
        FString SharedGroupId;

        FAddSharedGroupMembersRequest() :
            FPlayFabBaseModel(),
            PlayFabIds(),
            SharedGroupId()
            {}

        FAddSharedGroupMembersRequest(const FAddSharedGroupMembersRequest& src) :
            FPlayFabBaseModel(),
            PlayFabIds(src.PlayFabIds),
            SharedGroupId(src.SharedGroupId)
            {}

        FAddSharedGroupMembersRequest(const TSharedPtr<FJsonObject>& obj) : FAddSharedGroupMembersRequest()
        {
            readFromValue(obj);
        }

        ~FAddSharedGroupMembersRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FAddSharedGroupMembersResult : public FPlayFabBaseModel
    {
        FAddSharedGroupMembersResult() :
            FPlayFabBaseModel()
            {}

        FAddSharedGroupMembersResult(const FAddSharedGroupMembersResult& src) :
            FPlayFabBaseModel()
            {}

        FAddSharedGroupMembersResult(const TSharedPtr<FJsonObject>& obj) : FAddSharedGroupMembersResult()
        {
            readFromValue(obj);
        }

        ~FAddSharedGroupMembersResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FAddUserVirtualCurrencyRequest : public FPlayFabBaseModel
    {
        /**
         * Amount to be added to the user balance of the specified virtual currency. Maximum VC balance is Int32 (2,147,483,647).
         * Any increase over this value will be discarded.
         */
        int32 Amount;

        // PlayFab unique identifier of the user whose virtual currency balance is to be increased.
        FString PlayFabId;

        // Name of the virtual currency which is to be incremented.
        FString VirtualCurrency;

        FAddUserVirtualCurrencyRequest() :
            FPlayFabBaseModel(),
            Amount(0),
            PlayFabId(),
            VirtualCurrency()
            {}

        FAddUserVirtualCurrencyRequest(const FAddUserVirtualCurrencyRequest& src) :
            FPlayFabBaseModel(),
            Amount(src.Amount),
            PlayFabId(src.PlayFabId),
            VirtualCurrency(src.VirtualCurrency)
            {}

        FAddUserVirtualCurrencyRequest(const TSharedPtr<FJsonObject>& obj) : FAddUserVirtualCurrencyRequest()
        {
            readFromValue(obj);
        }

        ~FAddUserVirtualCurrencyRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    enum PushNotificationPlatform
    {
        PushNotificationPlatformApplePushNotificationService,
        PushNotificationPlatformGoogleCloudMessaging
    };

    PLAYFAB_API void writePushNotificationPlatformEnumJSON(PushNotificationPlatform enumVal, JsonWriter& writer);
    PLAYFAB_API PushNotificationPlatform readPushNotificationPlatformFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFAB_API PushNotificationPlatform readPushNotificationPlatformFromValue(const FString& value);

    struct PLAYFAB_API FAdvancedPushPlatformMsg : public FPlayFabBaseModel
    {
        // The Json the platform should receive.
        FString Json;

        // The platform that should receive the Json.
        PushNotificationPlatform Platform;

        FAdvancedPushPlatformMsg() :
            FPlayFabBaseModel(),
            Json(),
            Platform()
            {}

        FAdvancedPushPlatformMsg(const FAdvancedPushPlatformMsg& src) :
            FPlayFabBaseModel(),
            Json(src.Json),
            Platform(src.Platform)
            {}

        FAdvancedPushPlatformMsg(const TSharedPtr<FJsonObject>& obj) : FAdvancedPushPlatformMsg()
        {
            readFromValue(obj);
        }

        ~FAdvancedPushPlatformMsg();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FAuthenticateSessionTicketRequest : public FPlayFabBaseModel
    {
        // Session ticket as issued by a PlayFab client login API.
        FString SessionTicket;

        FAuthenticateSessionTicketRequest() :
            FPlayFabBaseModel(),
            SessionTicket()
            {}

        FAuthenticateSessionTicketRequest(const FAuthenticateSessionTicketRequest& src) :
            FPlayFabBaseModel(),
            SessionTicket(src.SessionTicket)
            {}

        FAuthenticateSessionTicketRequest(const TSharedPtr<FJsonObject>& obj) : FAuthenticateSessionTicketRequest()
        {
            readFromValue(obj);
        }

        ~FAuthenticateSessionTicketRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUserAndroidDeviceInfo : public FPlayFabBaseModel
    {
        // [optional] Android device ID
        FString AndroidDeviceId;

        FUserAndroidDeviceInfo() :
            FPlayFabBaseModel(),
            AndroidDeviceId()
            {}

        FUserAndroidDeviceInfo(const FUserAndroidDeviceInfo& src) :
            FPlayFabBaseModel(),
            AndroidDeviceId(src.AndroidDeviceId)
            {}

        FUserAndroidDeviceInfo(const TSharedPtr<FJsonObject>& obj) : FUserAndroidDeviceInfo()
        {
            readFromValue(obj);
        }

        ~FUserAndroidDeviceInfo();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUserCustomIdInfo : public FPlayFabBaseModel
    {
        // [optional] Custom ID
        FString CustomId;

        FUserCustomIdInfo() :
            FPlayFabBaseModel(),
            CustomId()
            {}

        FUserCustomIdInfo(const FUserCustomIdInfo& src) :
            FPlayFabBaseModel(),
            CustomId(src.CustomId)
            {}

        FUserCustomIdInfo(const TSharedPtr<FJsonObject>& obj) : FUserCustomIdInfo()
        {
            readFromValue(obj);
        }

        ~FUserCustomIdInfo();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUserFacebookInfo : public FPlayFabBaseModel
    {
        // [optional] Facebook identifier
        FString FacebookId;

        // [optional] Facebook full name
        FString FullName;

        FUserFacebookInfo() :
            FPlayFabBaseModel(),
            FacebookId(),
            FullName()
            {}

        FUserFacebookInfo(const FUserFacebookInfo& src) :
            FPlayFabBaseModel(),
            FacebookId(src.FacebookId),
            FullName(src.FullName)
            {}

        FUserFacebookInfo(const TSharedPtr<FJsonObject>& obj) : FUserFacebookInfo()
        {
            readFromValue(obj);
        }

        ~FUserFacebookInfo();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUserGameCenterInfo : public FPlayFabBaseModel
    {
        // [optional] Gamecenter identifier
        FString GameCenterId;

        FUserGameCenterInfo() :
            FPlayFabBaseModel(),
            GameCenterId()
            {}

        FUserGameCenterInfo(const FUserGameCenterInfo& src) :
            FPlayFabBaseModel(),
            GameCenterId(src.GameCenterId)
            {}

        FUserGameCenterInfo(const TSharedPtr<FJsonObject>& obj) : FUserGameCenterInfo()
        {
            readFromValue(obj);
        }

        ~FUserGameCenterInfo();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUserGoogleInfo : public FPlayFabBaseModel
    {
        // [optional] Email address of the Google account
        FString GoogleEmail;

        // [optional] Gender information of the Google account
        FString GoogleGender;

        // [optional] Google ID
        FString GoogleId;

        // [optional] Locale of the Google account
        FString GoogleLocale;

        FUserGoogleInfo() :
            FPlayFabBaseModel(),
            GoogleEmail(),
            GoogleGender(),
            GoogleId(),
            GoogleLocale()
            {}

        FUserGoogleInfo(const FUserGoogleInfo& src) :
            FPlayFabBaseModel(),
            GoogleEmail(src.GoogleEmail),
            GoogleGender(src.GoogleGender),
            GoogleId(src.GoogleId),
            GoogleLocale(src.GoogleLocale)
            {}

        FUserGoogleInfo(const TSharedPtr<FJsonObject>& obj) : FUserGoogleInfo()
        {
            readFromValue(obj);
        }

        ~FUserGoogleInfo();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUserIosDeviceInfo : public FPlayFabBaseModel
    {
        // [optional] iOS device ID
        FString IosDeviceId;

        FUserIosDeviceInfo() :
            FPlayFabBaseModel(),
            IosDeviceId()
            {}

        FUserIosDeviceInfo(const FUserIosDeviceInfo& src) :
            FPlayFabBaseModel(),
            IosDeviceId(src.IosDeviceId)
            {}

        FUserIosDeviceInfo(const TSharedPtr<FJsonObject>& obj) : FUserIosDeviceInfo()
        {
            readFromValue(obj);
        }

        ~FUserIosDeviceInfo();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUserKongregateInfo : public FPlayFabBaseModel
    {
        // [optional] Kongregate ID
        FString KongregateId;

        // [optional] Kongregate Username
        FString KongregateName;

        FUserKongregateInfo() :
            FPlayFabBaseModel(),
            KongregateId(),
            KongregateName()
            {}

        FUserKongregateInfo(const FUserKongregateInfo& src) :
            FPlayFabBaseModel(),
            KongregateId(src.KongregateId),
            KongregateName(src.KongregateName)
            {}

        FUserKongregateInfo(const TSharedPtr<FJsonObject>& obj) : FUserKongregateInfo()
        {
            readFromValue(obj);
        }

        ~FUserKongregateInfo();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUserPrivateAccountInfo : public FPlayFabBaseModel
    {
        // [optional] user email address
        FString Email;

        FUserPrivateAccountInfo() :
            FPlayFabBaseModel(),
            Email()
            {}

        FUserPrivateAccountInfo(const FUserPrivateAccountInfo& src) :
            FPlayFabBaseModel(),
            Email(src.Email)
            {}

        FUserPrivateAccountInfo(const TSharedPtr<FJsonObject>& obj) : FUserPrivateAccountInfo()
        {
            readFromValue(obj);
        }

        ~FUserPrivateAccountInfo();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUserPsnInfo : public FPlayFabBaseModel
    {
        // [optional] PSN account ID
        FString PsnAccountId;

        // [optional] PSN online ID
        FString PsnOnlineId;

        FUserPsnInfo() :
            FPlayFabBaseModel(),
            PsnAccountId(),
            PsnOnlineId()
            {}

        FUserPsnInfo(const FUserPsnInfo& src) :
            FPlayFabBaseModel(),
            PsnAccountId(src.PsnAccountId),
            PsnOnlineId(src.PsnOnlineId)
            {}

        FUserPsnInfo(const TSharedPtr<FJsonObject>& obj) : FUserPsnInfo()
        {
            readFromValue(obj);
        }

        ~FUserPsnInfo();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    enum TitleActivationStatus
    {
        TitleActivationStatusNone,
        TitleActivationStatusActivatedTitleKey,
        TitleActivationStatusPendingSteam,
        TitleActivationStatusActivatedSteam,
        TitleActivationStatusRevokedSteam
    };

    PLAYFAB_API void writeTitleActivationStatusEnumJSON(TitleActivationStatus enumVal, JsonWriter& writer);
    PLAYFAB_API TitleActivationStatus readTitleActivationStatusFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFAB_API TitleActivationStatus readTitleActivationStatusFromValue(const FString& value);

    enum Currency
    {
        CurrencyAED,
        CurrencyAFN,
        CurrencyALL,
        CurrencyAMD,
        CurrencyANG,
        CurrencyAOA,
        CurrencyARS,
        CurrencyAUD,
        CurrencyAWG,
        CurrencyAZN,
        CurrencyBAM,
        CurrencyBBD,
        CurrencyBDT,
        CurrencyBGN,
        CurrencyBHD,
        CurrencyBIF,
        CurrencyBMD,
        CurrencyBND,
        CurrencyBOB,
        CurrencyBRL,
        CurrencyBSD,
        CurrencyBTN,
        CurrencyBWP,
        CurrencyBYR,
        CurrencyBZD,
        CurrencyCAD,
        CurrencyCDF,
        CurrencyCHF,
        CurrencyCLP,
        CurrencyCNY,
        CurrencyCOP,
        CurrencyCRC,
        CurrencyCUC,
        CurrencyCUP,
        CurrencyCVE,
        CurrencyCZK,
        CurrencyDJF,
        CurrencyDKK,
        CurrencyDOP,
        CurrencyDZD,
        CurrencyEGP,
        CurrencyERN,
        CurrencyETB,
        CurrencyEUR,
        CurrencyFJD,
        CurrencyFKP,
        CurrencyGBP,
        CurrencyGEL,
        CurrencyGGP,
        CurrencyGHS,
        CurrencyGIP,
        CurrencyGMD,
        CurrencyGNF,
        CurrencyGTQ,
        CurrencyGYD,
        CurrencyHKD,
        CurrencyHNL,
        CurrencyHRK,
        CurrencyHTG,
        CurrencyHUF,
        CurrencyIDR,
        CurrencyILS,
        CurrencyIMP,
        CurrencyINR,
        CurrencyIQD,
        CurrencyIRR,
        CurrencyISK,
        CurrencyJEP,
        CurrencyJMD,
        CurrencyJOD,
        CurrencyJPY,
        CurrencyKES,
        CurrencyKGS,
        CurrencyKHR,
        CurrencyKMF,
        CurrencyKPW,
        CurrencyKRW,
        CurrencyKWD,
        CurrencyKYD,
        CurrencyKZT,
        CurrencyLAK,
        CurrencyLBP,
        CurrencyLKR,
        CurrencyLRD,
        CurrencyLSL,
        CurrencyLYD,
        CurrencyMAD,
        CurrencyMDL,
        CurrencyMGA,
        CurrencyMKD,
        CurrencyMMK,
        CurrencyMNT,
        CurrencyMOP,
        CurrencyMRO,
        CurrencyMUR,
        CurrencyMVR,
        CurrencyMWK,
        CurrencyMXN,
        CurrencyMYR,
        CurrencyMZN,
        CurrencyNAD,
        CurrencyNGN,
        CurrencyNIO,
        CurrencyNOK,
        CurrencyNPR,
        CurrencyNZD,
        CurrencyOMR,
        CurrencyPAB,
        CurrencyPEN,
        CurrencyPGK,
        CurrencyPHP,
        CurrencyPKR,
        CurrencyPLN,
        CurrencyPYG,
        CurrencyQAR,
        CurrencyRON,
        CurrencyRSD,
        CurrencyRUB,
        CurrencyRWF,
        CurrencySAR,
        CurrencySBD,
        CurrencySCR,
        CurrencySDG,
        CurrencySEK,
        CurrencySGD,
        CurrencySHP,
        CurrencySLL,
        CurrencySOS,
        CurrencySPL,
        CurrencySRD,
        CurrencySTD,
        CurrencySVC,
        CurrencySYP,
        CurrencySZL,
        CurrencyTHB,
        CurrencyTJS,
        CurrencyTMT,
        CurrencyTND,
        CurrencyTOP,
        CurrencyTRY,
        CurrencyTTD,
        CurrencyTVD,
        CurrencyTWD,
        CurrencyTZS,
        CurrencyUAH,
        CurrencyUGX,
        CurrencyUSD,
        CurrencyUYU,
        CurrencyUZS,
        CurrencyVEF,
        CurrencyVND,
        CurrencyVUV,
        CurrencyWST,
        CurrencyXAF,
        CurrencyXCD,
        CurrencyXDR,
        CurrencyXOF,
        CurrencyXPF,
        CurrencyYER,
        CurrencyZAR,
        CurrencyZMW,
        CurrencyZWD
    };

    PLAYFAB_API void writeCurrencyEnumJSON(Currency enumVal, JsonWriter& writer);
    PLAYFAB_API Currency readCurrencyFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFAB_API Currency readCurrencyFromValue(const FString& value);

    struct PLAYFAB_API FUserSteamInfo : public FPlayFabBaseModel
    {
        // [optional] what stage of game ownership the user is listed as being in, from Steam
        Boxed<TitleActivationStatus> SteamActivationStatus;

        // [optional] the country in which the player resides, from Steam data
        FString SteamCountry;

        // [optional] currency type set in the user Steam account
        Boxed<Currency> SteamCurrency;

        // [optional] Steam identifier
        FString SteamId;

        FUserSteamInfo() :
            FPlayFabBaseModel(),
            SteamActivationStatus(),
            SteamCountry(),
            SteamCurrency(),
            SteamId()
            {}

        FUserSteamInfo(const FUserSteamInfo& src) :
            FPlayFabBaseModel(),
            SteamActivationStatus(src.SteamActivationStatus),
            SteamCountry(src.SteamCountry),
            SteamCurrency(src.SteamCurrency),
            SteamId(src.SteamId)
            {}

        FUserSteamInfo(const TSharedPtr<FJsonObject>& obj) : FUserSteamInfo()
        {
            readFromValue(obj);
        }

        ~FUserSteamInfo();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    enum UserOrigination
    {
        UserOriginationOrganic,
        UserOriginationSteam,
        UserOriginationGoogle,
        UserOriginationAmazon,
        UserOriginationFacebook,
        UserOriginationKongregate,
        UserOriginationGamersFirst,
        UserOriginationUnknown,
        UserOriginationIOS,
        UserOriginationLoadTest,
        UserOriginationAndroid,
        UserOriginationPSN,
        UserOriginationGameCenter,
        UserOriginationCustomId,
        UserOriginationXboxLive,
        UserOriginationParse,
        UserOriginationTwitch,
        UserOriginationWindowsHello
    };

    PLAYFAB_API void writeUserOriginationEnumJSON(UserOrigination enumVal, JsonWriter& writer);
    PLAYFAB_API UserOrigination readUserOriginationFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFAB_API UserOrigination readUserOriginationFromValue(const FString& value);

    enum EntityTypes
    {
        EntityTypestitle,
        EntityTypesmaster_player_account,
        EntityTypestitle_player_account,
        EntityTypescharacter,
        EntityTypesgroup
    };

    PLAYFAB_API void writeEntityTypesEnumJSON(EntityTypes enumVal, JsonWriter& writer);
    PLAYFAB_API EntityTypes readEntityTypesFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFAB_API EntityTypes readEntityTypesFromValue(const FString& value);

    struct PLAYFAB_API FEntityKey : public FPlayFabBaseModel
    {
        // Entity profile ID.
        FString Id;

        // [optional] Entity type. Optional to be used but one of EntityType or EntityTypeString must be set.
        Boxed<EntityTypes> Type;

        // [optional] Entity type. Optional to be used but one of EntityType or EntityTypeString must be set.
        FString TypeString;

        FEntityKey() :
            FPlayFabBaseModel(),
            Id(),
            Type(),
            TypeString()
            {}

        FEntityKey(const FEntityKey& src) :
            FPlayFabBaseModel(),
            Id(src.Id),
            Type(src.Type),
            TypeString(src.TypeString)
            {}

        FEntityKey(const TSharedPtr<FJsonObject>& obj) : FEntityKey()
        {
            readFromValue(obj);
        }

        ~FEntityKey();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUserTitleInfo : public FPlayFabBaseModel
    {
        // [optional] URL to the player's avatar.
        FString AvatarUrl;

        /**
         * timestamp indicating when the user was first associated with this game (this can differ significantly from when the user
         * first registered with PlayFab)
         */
        FDateTime Created;

        // [optional] name of the user, as it is displayed in-game
        FString DisplayName;

        /**
         * [optional] timestamp indicating when the user first signed into this game (this can differ from the Created timestamp, as other
         * events, such as issuing a beta key to the user, can associate the title to the user)
         */
        Boxed<FDateTime> FirstLogin;

        // [optional] boolean indicating whether or not the user is currently banned for a title
        Boxed<bool> isBanned;

        // [optional] timestamp for the last user login for this title
        Boxed<FDateTime> LastLogin;

        // [optional] source by which the user first joined the game, if known
        Boxed<UserOrigination> Origination;

        // [optional] Title player account entity for this user
        TSharedPtr<FEntityKey> TitlePlayerAccount;

        FUserTitleInfo() :
            FPlayFabBaseModel(),
            AvatarUrl(),
            Created(0),
            DisplayName(),
            FirstLogin(),
            isBanned(),
            LastLogin(),
            Origination(),
            TitlePlayerAccount(nullptr)
            {}

        FUserTitleInfo(const FUserTitleInfo& src) :
            FPlayFabBaseModel(),
            AvatarUrl(src.AvatarUrl),
            Created(src.Created),
            DisplayName(src.DisplayName),
            FirstLogin(src.FirstLogin),
            isBanned(src.isBanned),
            LastLogin(src.LastLogin),
            Origination(src.Origination),
            TitlePlayerAccount(src.TitlePlayerAccount.IsValid() ? MakeShareable(new FEntityKey(*src.TitlePlayerAccount)) : nullptr)
            {}

        FUserTitleInfo(const TSharedPtr<FJsonObject>& obj) : FUserTitleInfo()
        {
            readFromValue(obj);
        }

        ~FUserTitleInfo();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUserTwitchInfo : public FPlayFabBaseModel
    {
        // [optional] Twitch ID
        FString TwitchId;

        // [optional] Twitch Username
        FString TwitchUserName;

        FUserTwitchInfo() :
            FPlayFabBaseModel(),
            TwitchId(),
            TwitchUserName()
            {}

        FUserTwitchInfo(const FUserTwitchInfo& src) :
            FPlayFabBaseModel(),
            TwitchId(src.TwitchId),
            TwitchUserName(src.TwitchUserName)
            {}

        FUserTwitchInfo(const TSharedPtr<FJsonObject>& obj) : FUserTwitchInfo()
        {
            readFromValue(obj);
        }

        ~FUserTwitchInfo();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUserXboxInfo : public FPlayFabBaseModel
    {
        // [optional] XBox user ID
        FString XboxUserId;

        FUserXboxInfo() :
            FPlayFabBaseModel(),
            XboxUserId()
            {}

        FUserXboxInfo(const FUserXboxInfo& src) :
            FPlayFabBaseModel(),
            XboxUserId(src.XboxUserId)
            {}

        FUserXboxInfo(const TSharedPtr<FJsonObject>& obj) : FUserXboxInfo()
        {
            readFromValue(obj);
        }

        ~FUserXboxInfo();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUserAccountInfo : public FPlayFabBaseModel
    {
        // [optional] User Android device information, if an Android device has been linked
        TSharedPtr<FUserAndroidDeviceInfo> AndroidDeviceInfo;

        // Timestamp indicating when the user account was created
        FDateTime Created;

        // [optional] Custom ID information, if a custom ID has been assigned
        TSharedPtr<FUserCustomIdInfo> CustomIdInfo;

        // [optional] User Facebook information, if a Facebook account has been linked
        TSharedPtr<FUserFacebookInfo> FacebookInfo;

        // [optional] User Gamecenter information, if a Gamecenter account has been linked
        TSharedPtr<FUserGameCenterInfo> GameCenterInfo;

        // [optional] User Google account information, if a Google account has been linked
        TSharedPtr<FUserGoogleInfo> GoogleInfo;

        // [optional] User iOS device information, if an iOS device has been linked
        TSharedPtr<FUserIosDeviceInfo> IosDeviceInfo;

        // [optional] User Kongregate account information, if a Kongregate account has been linked
        TSharedPtr<FUserKongregateInfo> KongregateInfo;

        // [optional] Unique identifier for the user account
        FString PlayFabId;

        // [optional] Personal information for the user which is considered more sensitive
        TSharedPtr<FUserPrivateAccountInfo> PrivateInfo;

        // [optional] User PSN account information, if a PSN account has been linked
        TSharedPtr<FUserPsnInfo> PsnInfo;

        // [optional] User Steam information, if a Steam account has been linked
        TSharedPtr<FUserSteamInfo> SteamInfo;

        // [optional] Title-specific information for the user account
        TSharedPtr<FUserTitleInfo> TitleInfo;

        // [optional] User Twitch account information, if a Twitch account has been linked
        TSharedPtr<FUserTwitchInfo> TwitchInfo;

        // [optional] User account name in the PlayFab service
        FString Username;

        // [optional] User XBox account information, if a XBox account has been linked
        TSharedPtr<FUserXboxInfo> XboxInfo;

        FUserAccountInfo() :
            FPlayFabBaseModel(),
            AndroidDeviceInfo(nullptr),
            Created(0),
            CustomIdInfo(nullptr),
            FacebookInfo(nullptr),
            GameCenterInfo(nullptr),
            GoogleInfo(nullptr),
            IosDeviceInfo(nullptr),
            KongregateInfo(nullptr),
            PlayFabId(),
            PrivateInfo(nullptr),
            PsnInfo(nullptr),
            SteamInfo(nullptr),
            TitleInfo(nullptr),
            TwitchInfo(nullptr),
            Username(),
            XboxInfo(nullptr)
            {}

        FUserAccountInfo(const FUserAccountInfo& src) :
            FPlayFabBaseModel(),
            AndroidDeviceInfo(src.AndroidDeviceInfo.IsValid() ? MakeShareable(new FUserAndroidDeviceInfo(*src.AndroidDeviceInfo)) : nullptr),
            Created(src.Created),
            CustomIdInfo(src.CustomIdInfo.IsValid() ? MakeShareable(new FUserCustomIdInfo(*src.CustomIdInfo)) : nullptr),
            FacebookInfo(src.FacebookInfo.IsValid() ? MakeShareable(new FUserFacebookInfo(*src.FacebookInfo)) : nullptr),
            GameCenterInfo(src.GameCenterInfo.IsValid() ? MakeShareable(new FUserGameCenterInfo(*src.GameCenterInfo)) : nullptr),
            GoogleInfo(src.GoogleInfo.IsValid() ? MakeShareable(new FUserGoogleInfo(*src.GoogleInfo)) : nullptr),
            IosDeviceInfo(src.IosDeviceInfo.IsValid() ? MakeShareable(new FUserIosDeviceInfo(*src.IosDeviceInfo)) : nullptr),
            KongregateInfo(src.KongregateInfo.IsValid() ? MakeShareable(new FUserKongregateInfo(*src.KongregateInfo)) : nullptr),
            PlayFabId(src.PlayFabId),
            PrivateInfo(src.PrivateInfo.IsValid() ? MakeShareable(new FUserPrivateAccountInfo(*src.PrivateInfo)) : nullptr),
            PsnInfo(src.PsnInfo.IsValid() ? MakeShareable(new FUserPsnInfo(*src.PsnInfo)) : nullptr),
            SteamInfo(src.SteamInfo.IsValid() ? MakeShareable(new FUserSteamInfo(*src.SteamInfo)) : nullptr),
            TitleInfo(src.TitleInfo.IsValid() ? MakeShareable(new FUserTitleInfo(*src.TitleInfo)) : nullptr),
            TwitchInfo(src.TwitchInfo.IsValid() ? MakeShareable(new FUserTwitchInfo(*src.TwitchInfo)) : nullptr),
            Username(src.Username),
            XboxInfo(src.XboxInfo.IsValid() ? MakeShareable(new FUserXboxInfo(*src.XboxInfo)) : nullptr)
            {}

        FUserAccountInfo(const TSharedPtr<FJsonObject>& obj) : FUserAccountInfo()
        {
            readFromValue(obj);
        }

        ~FUserAccountInfo();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FAuthenticateSessionTicketResult : public FPlayFabBaseModel
    {
        // [optional] Account info for the user whose session ticket was supplied.
        TSharedPtr<FUserAccountInfo> UserInfo;

        FAuthenticateSessionTicketResult() :
            FPlayFabBaseModel(),
            UserInfo(nullptr)
            {}

        FAuthenticateSessionTicketResult(const FAuthenticateSessionTicketResult& src) :
            FPlayFabBaseModel(),
            UserInfo(src.UserInfo.IsValid() ? MakeShareable(new FUserAccountInfo(*src.UserInfo)) : nullptr)
            {}

        FAuthenticateSessionTicketResult(const TSharedPtr<FJsonObject>& obj) : FAuthenticateSessionTicketResult()
        {
            readFromValue(obj);
        }

        ~FAuthenticateSessionTicketResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FAwardSteamAchievementItem : public FPlayFabBaseModel
    {
        // Unique Steam achievement name.
        FString AchievementName;

        // Unique PlayFab assigned ID of the user on whom the operation will be performed.
        FString PlayFabId;

        // Result of the award attempt (only valid on response, not on request).
        bool Result;

        FAwardSteamAchievementItem() :
            FPlayFabBaseModel(),
            AchievementName(),
            PlayFabId(),
            Result(false)
            {}

        FAwardSteamAchievementItem(const FAwardSteamAchievementItem& src) :
            FPlayFabBaseModel(),
            AchievementName(src.AchievementName),
            PlayFabId(src.PlayFabId),
            Result(src.Result)
            {}

        FAwardSteamAchievementItem(const TSharedPtr<FJsonObject>& obj) : FAwardSteamAchievementItem()
        {
            readFromValue(obj);
        }

        ~FAwardSteamAchievementItem();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FAwardSteamAchievementRequest : public FPlayFabBaseModel
    {
        // Array of achievements to grant and the users to whom they are to be granted.
        TArray<FAwardSteamAchievementItem> Achievements;
        FAwardSteamAchievementRequest() :
            FPlayFabBaseModel(),
            Achievements()
            {}

        FAwardSteamAchievementRequest(const FAwardSteamAchievementRequest& src) :
            FPlayFabBaseModel(),
            Achievements(src.Achievements)
            {}

        FAwardSteamAchievementRequest(const TSharedPtr<FJsonObject>& obj) : FAwardSteamAchievementRequest()
        {
            readFromValue(obj);
        }

        ~FAwardSteamAchievementRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FAwardSteamAchievementResult : public FPlayFabBaseModel
    {
        // [optional] Array of achievements granted.
        TArray<FAwardSteamAchievementItem> AchievementResults;
        FAwardSteamAchievementResult() :
            FPlayFabBaseModel(),
            AchievementResults()
            {}

        FAwardSteamAchievementResult(const FAwardSteamAchievementResult& src) :
            FPlayFabBaseModel(),
            AchievementResults(src.AchievementResults)
            {}

        FAwardSteamAchievementResult(const TSharedPtr<FJsonObject>& obj) : FAwardSteamAchievementResult()
        {
            readFromValue(obj);
        }

        ~FAwardSteamAchievementResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FBanInfo : public FPlayFabBaseModel
    {
        // The active state of this ban. Expired bans may still have this value set to true but they will have no effect.
        bool Active;

        // [optional] The unique Ban Id associated with this ban.
        FString BanId;

        // [optional] The time when this ban was applied.
        Boxed<FDateTime> Created;

        // [optional] The time when this ban expires. Permanent bans do not have expiration date.
        Boxed<FDateTime> Expires;

        // [optional] The IP address on which the ban was applied. May affect multiple players.
        FString IPAddress;

        // [optional] The MAC address on which the ban was applied. May affect multiple players.
        FString MACAddress;

        // [optional] Unique PlayFab assigned ID of the user on whom the operation will be performed.
        FString PlayFabId;

        // [optional] The reason why this ban was applied.
        FString Reason;

        FBanInfo() :
            FPlayFabBaseModel(),
            Active(false),
            BanId(),
            Created(),
            Expires(),
            IPAddress(),
            MACAddress(),
            PlayFabId(),
            Reason()
            {}

        FBanInfo(const FBanInfo& src) :
            FPlayFabBaseModel(),
            Active(src.Active),
            BanId(src.BanId),
            Created(src.Created),
            Expires(src.Expires),
            IPAddress(src.IPAddress),
            MACAddress(src.MACAddress),
            PlayFabId(src.PlayFabId),
            Reason(src.Reason)
            {}

        FBanInfo(const TSharedPtr<FJsonObject>& obj) : FBanInfo()
        {
            readFromValue(obj);
        }

        ~FBanInfo();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FBanRequest : public FPlayFabBaseModel
    {
        // [optional] The duration in hours for the ban. Leave this blank for a permanent ban.
        Boxed<uint32> DurationInHours;

        // [optional] IP address to be banned. May affect multiple players.
        FString IPAddress;

        // [optional] MAC address to be banned. May affect multiple players.
        FString MACAddress;

        // Unique PlayFab assigned ID of the user on whom the operation will be performed.
        FString PlayFabId;

        // [optional] The reason for this ban. Maximum 140 characters.
        FString Reason;

        FBanRequest() :
            FPlayFabBaseModel(),
            DurationInHours(),
            IPAddress(),
            MACAddress(),
            PlayFabId(),
            Reason()
            {}

        FBanRequest(const FBanRequest& src) :
            FPlayFabBaseModel(),
            DurationInHours(src.DurationInHours),
            IPAddress(src.IPAddress),
            MACAddress(src.MACAddress),
            PlayFabId(src.PlayFabId),
            Reason(src.Reason)
            {}

        FBanRequest(const TSharedPtr<FJsonObject>& obj) : FBanRequest()
        {
            readFromValue(obj);
        }

        ~FBanRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FBanUsersRequest : public FPlayFabBaseModel
    {
        // List of ban requests to be applied. Maximum 100.
        TArray<FBanRequest> Bans;
        FBanUsersRequest() :
            FPlayFabBaseModel(),
            Bans()
            {}

        FBanUsersRequest(const FBanUsersRequest& src) :
            FPlayFabBaseModel(),
            Bans(src.Bans)
            {}

        FBanUsersRequest(const TSharedPtr<FJsonObject>& obj) : FBanUsersRequest()
        {
            readFromValue(obj);
        }

        ~FBanUsersRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FBanUsersResult : public FPlayFabBaseModel
    {
        // [optional] Information on the bans that were applied
        TArray<FBanInfo> BanData;
        FBanUsersResult() :
            FPlayFabBaseModel(),
            BanData()
            {}

        FBanUsersResult(const FBanUsersResult& src) :
            FPlayFabBaseModel(),
            BanData(src.BanData)
            {}

        FBanUsersResult(const TSharedPtr<FJsonObject>& obj) : FBanUsersResult()
        {
            readFromValue(obj);
        }

        ~FBanUsersResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FCatalogItemBundleInfo : public FPlayFabBaseModel
    {
        // [optional] unique ItemId values for all items which will be added to the player inventory when the bundle is added
        TArray<FString> BundledItems;
        /**
         * [optional] unique TableId values for all RandomResultTable objects which are part of the bundle (random tables will be resolved and
         * add the relevant items to the player inventory when the bundle is added)
         */
        TArray<FString> BundledResultTables;
        // [optional] virtual currency types and balances which will be added to the player inventory when the bundle is added
        TMap<FString, uint32> BundledVirtualCurrencies;
        FCatalogItemBundleInfo() :
            FPlayFabBaseModel(),
            BundledItems(),
            BundledResultTables(),
            BundledVirtualCurrencies()
            {}

        FCatalogItemBundleInfo(const FCatalogItemBundleInfo& src) :
            FPlayFabBaseModel(),
            BundledItems(src.BundledItems),
            BundledResultTables(src.BundledResultTables),
            BundledVirtualCurrencies(src.BundledVirtualCurrencies)
            {}

        FCatalogItemBundleInfo(const TSharedPtr<FJsonObject>& obj) : FCatalogItemBundleInfo()
        {
            readFromValue(obj);
        }

        ~FCatalogItemBundleInfo();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FCatalogItemConsumableInfo : public FPlayFabBaseModel
    {
        // [optional] number of times this object can be used, after which it will be removed from the player inventory
        Boxed<uint32> UsageCount;

        /**
         * [optional] duration in seconds for how long the item will remain in the player inventory - once elapsed, the item will be removed
         * (recommended minimum value is 5 seconds, as lower values can cause the item to expire before operations depending on
         * this item's details have completed)
         */
        Boxed<uint32> UsagePeriod;

        /**
         * [optional] all inventory item instances in the player inventory sharing a non-null UsagePeriodGroup have their UsagePeriod values
         * added together, and share the result - when that period has elapsed, all the items in the group will be removed
         */
        FString UsagePeriodGroup;

        FCatalogItemConsumableInfo() :
            FPlayFabBaseModel(),
            UsageCount(),
            UsagePeriod(),
            UsagePeriodGroup()
            {}

        FCatalogItemConsumableInfo(const FCatalogItemConsumableInfo& src) :
            FPlayFabBaseModel(),
            UsageCount(src.UsageCount),
            UsagePeriod(src.UsagePeriod),
            UsagePeriodGroup(src.UsagePeriodGroup)
            {}

        FCatalogItemConsumableInfo(const TSharedPtr<FJsonObject>& obj) : FCatalogItemConsumableInfo()
        {
            readFromValue(obj);
        }

        ~FCatalogItemConsumableInfo();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FCatalogItemContainerInfo : public FPlayFabBaseModel
    {
        // [optional] unique ItemId values for all items which will be added to the player inventory, once the container has been unlocked
        TArray<FString> ItemContents;
        /**
         * [optional] ItemId for the catalog item used to unlock the container, if any (if not specified, a call to UnlockContainerItem will
         * open the container, adding the contents to the player inventory and currency balances)
         */
        FString KeyItemId;

        /**
         * [optional] unique TableId values for all RandomResultTable objects which are part of the container (once unlocked, random tables
         * will be resolved and add the relevant items to the player inventory)
         */
        TArray<FString> ResultTableContents;
        // [optional] virtual currency types and balances which will be added to the player inventory when the container is unlocked
        TMap<FString, uint32> VirtualCurrencyContents;
        FCatalogItemContainerInfo() :
            FPlayFabBaseModel(),
            ItemContents(),
            KeyItemId(),
            ResultTableContents(),
            VirtualCurrencyContents()
            {}

        FCatalogItemContainerInfo(const FCatalogItemContainerInfo& src) :
            FPlayFabBaseModel(),
            ItemContents(src.ItemContents),
            KeyItemId(src.KeyItemId),
            ResultTableContents(src.ResultTableContents),
            VirtualCurrencyContents(src.VirtualCurrencyContents)
            {}

        FCatalogItemContainerInfo(const TSharedPtr<FJsonObject>& obj) : FCatalogItemContainerInfo()
        {
            readFromValue(obj);
        }

        ~FCatalogItemContainerInfo();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FCatalogItem : public FPlayFabBaseModel
    {
        /**
         * [optional] defines the bundle properties for the item - bundles are items which contain other items, including random drop tables
         * and virtual currencies
         */
        TSharedPtr<FCatalogItemBundleInfo> Bundle;

        // if true, then an item instance of this type can be used to grant a character to a user.
        bool CanBecomeCharacter;

        // [optional] catalog version for this item
        FString CatalogVersion;

        // [optional] defines the consumable properties (number of uses, timeout) for the item
        TSharedPtr<FCatalogItemConsumableInfo> Consumable;

        /**
         * [optional] defines the container properties for the item - what items it contains, including random drop tables and virtual
         * currencies, and what item (if any) is required to open it via the UnlockContainerItem API
         */
        TSharedPtr<FCatalogItemContainerInfo> Container;

        // [optional] game specific custom data
        FString CustomData;

        // [optional] text description of item, to show in-game
        FString Description;

        // [optional] text name for the item, to show in-game
        FString DisplayName;

        /**
         * If the item has IsLImitedEdition set to true, and this is the first time this ItemId has been defined as a limited
         * edition item, this value determines the total number of instances to allocate for the title. Once this limit has been
         * reached, no more instances of this ItemId can be created, and attempts to purchase or grant it will return a Result of
         * false for that ItemId. If the item has already been defined to have a limited edition count, or if this value is less
         * than zero, it will be ignored.
         */
        int32 InitialLimitedEditionCount;

        // BETA: If true, then only a fixed number can ever be granted.
        bool IsLimitedEdition;

        /**
         * if true, then only one item instance of this type will exist and its remaininguses will be incremented instead.
         * RemainingUses will cap out at Int32.Max (2,147,483,647). All subsequent increases will be discarded
         */
        bool IsStackable;

        // if true, then an item instance of this type can be traded between players using the trading APIs
        bool IsTradable;

        // [optional] class to which the item belongs
        FString ItemClass;

        // unique identifier for this item
        FString ItemId;

        /**
         * [optional] URL to the item image. For Facebook purchase to display the image on the item purchase page, this must be set to an HTTP
         * URL.
         */
        FString ItemImageUrl;

        // [optional] override prices for this item for specific currencies
        TMap<FString, uint32> RealCurrencyPrices;
        // [optional] list of item tags
        TArray<FString> Tags;
        // [optional] price of this item in virtual currencies and "RM" (the base Real Money purchase price, in USD pennies)
        TMap<FString, uint32> VirtualCurrencyPrices;
        FCatalogItem() :
            FPlayFabBaseModel(),
            Bundle(nullptr),
            CanBecomeCharacter(false),
            CatalogVersion(),
            Consumable(nullptr),
            Container(nullptr),
            CustomData(),
            Description(),
            DisplayName(),
            InitialLimitedEditionCount(0),
            IsLimitedEdition(false),
            IsStackable(false),
            IsTradable(false),
            ItemClass(),
            ItemId(),
            ItemImageUrl(),
            RealCurrencyPrices(),
            Tags(),
            VirtualCurrencyPrices()
            {}

        FCatalogItem(const FCatalogItem& src) :
            FPlayFabBaseModel(),
            Bundle(src.Bundle.IsValid() ? MakeShareable(new FCatalogItemBundleInfo(*src.Bundle)) : nullptr),
            CanBecomeCharacter(src.CanBecomeCharacter),
            CatalogVersion(src.CatalogVersion),
            Consumable(src.Consumable.IsValid() ? MakeShareable(new FCatalogItemConsumableInfo(*src.Consumable)) : nullptr),
            Container(src.Container.IsValid() ? MakeShareable(new FCatalogItemContainerInfo(*src.Container)) : nullptr),
            CustomData(src.CustomData),
            Description(src.Description),
            DisplayName(src.DisplayName),
            InitialLimitedEditionCount(src.InitialLimitedEditionCount),
            IsLimitedEdition(src.IsLimitedEdition),
            IsStackable(src.IsStackable),
            IsTradable(src.IsTradable),
            ItemClass(src.ItemClass),
            ItemId(src.ItemId),
            ItemImageUrl(src.ItemImageUrl),
            RealCurrencyPrices(src.RealCurrencyPrices),
            Tags(src.Tags),
            VirtualCurrencyPrices(src.VirtualCurrencyPrices)
            {}

        FCatalogItem(const TSharedPtr<FJsonObject>& obj) : FCatalogItem()
        {
            readFromValue(obj);
        }

        ~FCatalogItem();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FItemInstance : public FPlayFabBaseModel
    {
        // [optional] Game specific comment associated with this instance when it was added to the user inventory.
        FString Annotation;

        // [optional] Array of unique items that were awarded when this catalog item was purchased.
        TArray<FString> BundleContents;
        /**
         * [optional] Unique identifier for the parent inventory item, as defined in the catalog, for object which were added from a bundle or
         * container.
         */
        FString BundleParent;

        // [optional] Catalog version for the inventory item, when this instance was created.
        FString CatalogVersion;

        // [optional] A set of custom key-value pairs on the inventory item.
        TMap<FString, FString> CustomData;
        // [optional] CatalogItem.DisplayName at the time this item was purchased.
        FString DisplayName;

        // [optional] Timestamp for when this instance will expire.
        Boxed<FDateTime> Expiration;

        // [optional] Class name for the inventory item, as defined in the catalog.
        FString ItemClass;

        // [optional] Unique identifier for the inventory item, as defined in the catalog.
        FString ItemId;

        // [optional] Unique item identifier for this specific instance of the item.
        FString ItemInstanceId;

        // [optional] Timestamp for when this instance was purchased.
        Boxed<FDateTime> PurchaseDate;

        // [optional] Total number of remaining uses, if this is a consumable item.
        Boxed<int32> RemainingUses;

        // [optional] Currency type for the cost of the catalog item.
        FString UnitCurrency;

        // Cost of the catalog item in the given currency.
        uint32 UnitPrice;

        // [optional] The number of uses that were added or removed to this item in this call.
        Boxed<int32> UsesIncrementedBy;

        FItemInstance() :
            FPlayFabBaseModel(),
            Annotation(),
            BundleContents(),
            BundleParent(),
            CatalogVersion(),
            CustomData(),
            DisplayName(),
            Expiration(),
            ItemClass(),
            ItemId(),
            ItemInstanceId(),
            PurchaseDate(),
            RemainingUses(),
            UnitCurrency(),
            UnitPrice(0),
            UsesIncrementedBy()
            {}

        FItemInstance(const FItemInstance& src) :
            FPlayFabBaseModel(),
            Annotation(src.Annotation),
            BundleContents(src.BundleContents),
            BundleParent(src.BundleParent),
            CatalogVersion(src.CatalogVersion),
            CustomData(src.CustomData),
            DisplayName(src.DisplayName),
            Expiration(src.Expiration),
            ItemClass(src.ItemClass),
            ItemId(src.ItemId),
            ItemInstanceId(src.ItemInstanceId),
            PurchaseDate(src.PurchaseDate),
            RemainingUses(src.RemainingUses),
            UnitCurrency(src.UnitCurrency),
            UnitPrice(src.UnitPrice),
            UsesIncrementedBy(src.UsesIncrementedBy)
            {}

        FItemInstance(const TSharedPtr<FJsonObject>& obj) : FItemInstance()
        {
            readFromValue(obj);
        }

        ~FItemInstance();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FCharacterInventory : public FPlayFabBaseModel
    {
        // [optional] The id of this character.
        FString CharacterId;

        // [optional] The inventory of this character.
        TArray<FItemInstance> Inventory;
        FCharacterInventory() :
            FPlayFabBaseModel(),
            CharacterId(),
            Inventory()
            {}

        FCharacterInventory(const FCharacterInventory& src) :
            FPlayFabBaseModel(),
            CharacterId(src.CharacterId),
            Inventory(src.Inventory)
            {}

        FCharacterInventory(const TSharedPtr<FJsonObject>& obj) : FCharacterInventory()
        {
            readFromValue(obj);
        }

        ~FCharacterInventory();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FCharacterLeaderboardEntry : public FPlayFabBaseModel
    {
        // [optional] PlayFab unique identifier of the character that belongs to the user for this leaderboard entry.
        FString CharacterId;

        // [optional] Title-specific display name of the character for this leaderboard entry.
        FString CharacterName;

        // [optional] Name of the character class for this entry.
        FString CharacterType;

        // [optional] Title-specific display name of the user for this leaderboard entry.
        FString DisplayName;

        // [optional] PlayFab unique identifier of the user for this leaderboard entry.
        FString PlayFabId;

        // User's overall position in the leaderboard.
        int32 Position;

        // Specific value of the user's statistic.
        int32 StatValue;

        FCharacterLeaderboardEntry() :
            FPlayFabBaseModel(),
            CharacterId(),
            CharacterName(),
            CharacterType(),
            DisplayName(),
            PlayFabId(),
            Position(0),
            StatValue(0)
            {}

        FCharacterLeaderboardEntry(const FCharacterLeaderboardEntry& src) :
            FPlayFabBaseModel(),
            CharacterId(src.CharacterId),
            CharacterName(src.CharacterName),
            CharacterType(src.CharacterType),
            DisplayName(src.DisplayName),
            PlayFabId(src.PlayFabId),
            Position(src.Position),
            StatValue(src.StatValue)
            {}

        FCharacterLeaderboardEntry(const TSharedPtr<FJsonObject>& obj) : FCharacterLeaderboardEntry()
        {
            readFromValue(obj);
        }

        ~FCharacterLeaderboardEntry();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FCharacterResult : public FPlayFabBaseModel
    {
        // [optional] The id for this character on this player.
        FString CharacterId;

        // [optional] The name of this character.
        FString CharacterName;

        // [optional] The type-string that was given to this character on creation.
        FString CharacterType;

        FCharacterResult() :
            FPlayFabBaseModel(),
            CharacterId(),
            CharacterName(),
            CharacterType()
            {}

        FCharacterResult(const FCharacterResult& src) :
            FPlayFabBaseModel(),
            CharacterId(src.CharacterId),
            CharacterName(src.CharacterName),
            CharacterType(src.CharacterType)
            {}

        FCharacterResult(const TSharedPtr<FJsonObject>& obj) : FCharacterResult()
        {
            readFromValue(obj);
        }

        ~FCharacterResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    enum CloudScriptRevisionOption
    {
        CloudScriptRevisionOptionLive,
        CloudScriptRevisionOptionLatest,
        CloudScriptRevisionOptionSpecific
    };

    PLAYFAB_API void writeCloudScriptRevisionOptionEnumJSON(CloudScriptRevisionOption enumVal, JsonWriter& writer);
    PLAYFAB_API CloudScriptRevisionOption readCloudScriptRevisionOptionFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFAB_API CloudScriptRevisionOption readCloudScriptRevisionOptionFromValue(const FString& value);

    struct PLAYFAB_API FConsumeItemRequest : public FPlayFabBaseModel
    {
        // [optional] Unique PlayFab assigned ID for a specific character owned by a user
        FString CharacterId;

        // Number of uses to consume from the item.
        int32 ConsumeCount;

        // Unique instance identifier of the item to be consumed.
        FString ItemInstanceId;

        // Unique PlayFab assigned ID of the user on whom the operation will be performed.
        FString PlayFabId;

        FConsumeItemRequest() :
            FPlayFabBaseModel(),
            CharacterId(),
            ConsumeCount(0),
            ItemInstanceId(),
            PlayFabId()
            {}

        FConsumeItemRequest(const FConsumeItemRequest& src) :
            FPlayFabBaseModel(),
            CharacterId(src.CharacterId),
            ConsumeCount(src.ConsumeCount),
            ItemInstanceId(src.ItemInstanceId),
            PlayFabId(src.PlayFabId)
            {}

        FConsumeItemRequest(const TSharedPtr<FJsonObject>& obj) : FConsumeItemRequest()
        {
            readFromValue(obj);
        }

        ~FConsumeItemRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FConsumeItemResult : public FPlayFabBaseModel
    {
        // [optional] Unique instance identifier of the item with uses consumed.
        FString ItemInstanceId;

        // Number of uses remaining on the item.
        int32 RemainingUses;

        FConsumeItemResult() :
            FPlayFabBaseModel(),
            ItemInstanceId(),
            RemainingUses(0)
            {}

        FConsumeItemResult(const FConsumeItemResult& src) :
            FPlayFabBaseModel(),
            ItemInstanceId(src.ItemInstanceId),
            RemainingUses(src.RemainingUses)
            {}

        FConsumeItemResult(const TSharedPtr<FJsonObject>& obj) : FConsumeItemResult()
        {
            readFromValue(obj);
        }

        ~FConsumeItemResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    enum EmailVerificationStatus
    {
        EmailVerificationStatusUnverified,
        EmailVerificationStatusPending,
        EmailVerificationStatusConfirmed
    };

    PLAYFAB_API void writeEmailVerificationStatusEnumJSON(EmailVerificationStatus enumVal, JsonWriter& writer);
    PLAYFAB_API EmailVerificationStatus readEmailVerificationStatusFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFAB_API EmailVerificationStatus readEmailVerificationStatusFromValue(const FString& value);

    struct PLAYFAB_API FContactEmailInfo : public FPlayFabBaseModel
    {
        // [optional] The email address
        FString EmailAddress;

        // [optional] The name of the email info data
        FString Name;

        // [optional] The verification status of the email
        Boxed<EmailVerificationStatus> VerificationStatus;

        FContactEmailInfo() :
            FPlayFabBaseModel(),
            EmailAddress(),
            Name(),
            VerificationStatus()
            {}

        FContactEmailInfo(const FContactEmailInfo& src) :
            FPlayFabBaseModel(),
            EmailAddress(src.EmailAddress),
            Name(src.Name),
            VerificationStatus(src.VerificationStatus)
            {}

        FContactEmailInfo(const TSharedPtr<FJsonObject>& obj) : FContactEmailInfo()
        {
            readFromValue(obj);
        }

        ~FContactEmailInfo();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FContactEmailInfoModel : public FPlayFabBaseModel
    {
        // [optional] The email address
        FString EmailAddress;

        // [optional] The name of the email info data
        FString Name;

        // [optional] The verification status of the email
        Boxed<EmailVerificationStatus> VerificationStatus;

        FContactEmailInfoModel() :
            FPlayFabBaseModel(),
            EmailAddress(),
            Name(),
            VerificationStatus()
            {}

        FContactEmailInfoModel(const FContactEmailInfoModel& src) :
            FPlayFabBaseModel(),
            EmailAddress(src.EmailAddress),
            Name(src.Name),
            VerificationStatus(src.VerificationStatus)
            {}

        FContactEmailInfoModel(const TSharedPtr<FJsonObject>& obj) : FContactEmailInfoModel()
        {
            readFromValue(obj);
        }

        ~FContactEmailInfoModel();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    enum ContinentCode
    {
        ContinentCodeAF,
        ContinentCodeAN,
        ContinentCodeAS,
        ContinentCodeEU,
        ContinentCodeNA,
        ContinentCodeOC,
        ContinentCodeSA
    };

    PLAYFAB_API void writeContinentCodeEnumJSON(ContinentCode enumVal, JsonWriter& writer);
    PLAYFAB_API ContinentCode readContinentCodeFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFAB_API ContinentCode readContinentCodeFromValue(const FString& value);

    enum CountryCode
    {
        CountryCodeAF,
        CountryCodeAX,
        CountryCodeAL,
        CountryCodeDZ,
        CountryCodeAS,
        CountryCodeAD,
        CountryCodeAO,
        CountryCodeAI,
        CountryCodeAQ,
        CountryCodeAG,
        CountryCodeAR,
        CountryCodeAM,
        CountryCodeAW,
        CountryCodeAU,
        CountryCodeAT,
        CountryCodeAZ,
        CountryCodeBS,
        CountryCodeBH,
        CountryCodeBD,
        CountryCodeBB,
        CountryCodeBY,
        CountryCodeBE,
        CountryCodeBZ,
        CountryCodeBJ,
        CountryCodeBM,
        CountryCodeBT,
        CountryCodeBO,
        CountryCodeBQ,
        CountryCodeBA,
        CountryCodeBW,
        CountryCodeBV,
        CountryCodeBR,
        CountryCodeIO,
        CountryCodeBN,
        CountryCodeBG,
        CountryCodeBF,
        CountryCodeBI,
        CountryCodeKH,
        CountryCodeCM,
        CountryCodeCA,
        CountryCodeCV,
        CountryCodeKY,
        CountryCodeCF,
        CountryCodeTD,
        CountryCodeCL,
        CountryCodeCN,
        CountryCodeCX,
        CountryCodeCC,
        CountryCodeCO,
        CountryCodeKM,
        CountryCodeCG,
        CountryCodeCD,
        CountryCodeCK,
        CountryCodeCR,
        CountryCodeCI,
        CountryCodeHR,
        CountryCodeCU,
        CountryCodeCW,
        CountryCodeCY,
        CountryCodeCZ,
        CountryCodeDK,
        CountryCodeDJ,
        CountryCodeDM,
        CountryCodeDO,
        CountryCodeEC,
        CountryCodeEG,
        CountryCodeSV,
        CountryCodeGQ,
        CountryCodeER,
        CountryCodeEE,
        CountryCodeET,
        CountryCodeFK,
        CountryCodeFO,
        CountryCodeFJ,
        CountryCodeFI,
        CountryCodeFR,
        CountryCodeGF,
        CountryCodePF,
        CountryCodeTF,
        CountryCodeGA,
        CountryCodeGM,
        CountryCodeGE,
        CountryCodeDE,
        CountryCodeGH,
        CountryCodeGI,
        CountryCodeGR,
        CountryCodeGL,
        CountryCodeGD,
        CountryCodeGP,
        CountryCodeGU,
        CountryCodeGT,
        CountryCodeGG,
        CountryCodeGN,
        CountryCodeGW,
        CountryCodeGY,
        CountryCodeHT,
        CountryCodeHM,
        CountryCodeVA,
        CountryCodeHN,
        CountryCodeHK,
        CountryCodeHU,
        CountryCodeIS,
        CountryCodeIN,
        CountryCodeID,
        CountryCodeIR,
        CountryCodeIQ,
        CountryCodeIE,
        CountryCodeIM,
        CountryCodeIL,
        CountryCodeIT,
        CountryCodeJM,
        CountryCodeJP,
        CountryCodeJE,
        CountryCodeJO,
        CountryCodeKZ,
        CountryCodeKE,
        CountryCodeKI,
        CountryCodeKP,
        CountryCodeKR,
        CountryCodeKW,
        CountryCodeKG,
        CountryCodeLA,
        CountryCodeLV,
        CountryCodeLB,
        CountryCodeLS,
        CountryCodeLR,
        CountryCodeLY,
        CountryCodeLI,
        CountryCodeLT,
        CountryCodeLU,
        CountryCodeMO,
        CountryCodeMK,
        CountryCodeMG,
        CountryCodeMW,
        CountryCodeMY,
        CountryCodeMV,
        CountryCodeML,
        CountryCodeMT,
        CountryCodeMH,
        CountryCodeMQ,
        CountryCodeMR,
        CountryCodeMU,
        CountryCodeYT,
        CountryCodeMX,
        CountryCodeFM,
        CountryCodeMD,
        CountryCodeMC,
        CountryCodeMN,
        CountryCodeME,
        CountryCodeMS,
        CountryCodeMA,
        CountryCodeMZ,
        CountryCodeMM,
        CountryCodeNA,
        CountryCodeNR,
        CountryCodeNP,
        CountryCodeNL,
        CountryCodeNC,
        CountryCodeNZ,
        CountryCodeNI,
        CountryCodeNE,
        CountryCodeNG,
        CountryCodeNU,
        CountryCodeNF,
        CountryCodeMP,
        CountryCodeNO,
        CountryCodeOM,
        CountryCodePK,
        CountryCodePW,
        CountryCodePS,
        CountryCodePA,
        CountryCodePG,
        CountryCodePY,
        CountryCodePE,
        CountryCodePH,
        CountryCodePN,
        CountryCodePL,
        CountryCodePT,
        CountryCodePR,
        CountryCodeQA,
        CountryCodeRE,
        CountryCodeRO,
        CountryCodeRU,
        CountryCodeRW,
        CountryCodeBL,
        CountryCodeSH,
        CountryCodeKN,
        CountryCodeLC,
        CountryCodeMF,
        CountryCodePM,
        CountryCodeVC,
        CountryCodeWS,
        CountryCodeSM,
        CountryCodeST,
        CountryCodeSA,
        CountryCodeSN,
        CountryCodeRS,
        CountryCodeSC,
        CountryCodeSL,
        CountryCodeSG,
        CountryCodeSX,
        CountryCodeSK,
        CountryCodeSI,
        CountryCodeSB,
        CountryCodeSO,
        CountryCodeZA,
        CountryCodeGS,
        CountryCodeSS,
        CountryCodeES,
        CountryCodeLK,
        CountryCodeSD,
        CountryCodeSR,
        CountryCodeSJ,
        CountryCodeSZ,
        CountryCodeSE,
        CountryCodeCH,
        CountryCodeSY,
        CountryCodeTW,
        CountryCodeTJ,
        CountryCodeTZ,
        CountryCodeTH,
        CountryCodeTL,
        CountryCodeTG,
        CountryCodeTK,
        CountryCodeTO,
        CountryCodeTT,
        CountryCodeTN,
        CountryCodeTR,
        CountryCodeTM,
        CountryCodeTC,
        CountryCodeTV,
        CountryCodeUG,
        CountryCodeUA,
        CountryCodeAE,
        CountryCodeGB,
        CountryCodeUS,
        CountryCodeUM,
        CountryCodeUY,
        CountryCodeUZ,
        CountryCodeVU,
        CountryCodeVE,
        CountryCodeVN,
        CountryCodeVG,
        CountryCodeVI,
        CountryCodeWF,
        CountryCodeEH,
        CountryCodeYE,
        CountryCodeZM,
        CountryCodeZW
    };

    PLAYFAB_API void writeCountryCodeEnumJSON(CountryCode enumVal, JsonWriter& writer);
    PLAYFAB_API CountryCode readCountryCodeFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFAB_API CountryCode readCountryCodeFromValue(const FString& value);

    struct PLAYFAB_API FCreateSharedGroupRequest : public FPlayFabBaseModel
    {
        // [optional] Unique identifier for the shared group (a random identifier will be assigned, if one is not specified).
        FString SharedGroupId;

        FCreateSharedGroupRequest() :
            FPlayFabBaseModel(),
            SharedGroupId()
            {}

        FCreateSharedGroupRequest(const FCreateSharedGroupRequest& src) :
            FPlayFabBaseModel(),
            SharedGroupId(src.SharedGroupId)
            {}

        FCreateSharedGroupRequest(const TSharedPtr<FJsonObject>& obj) : FCreateSharedGroupRequest()
        {
            readFromValue(obj);
        }

        ~FCreateSharedGroupRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FCreateSharedGroupResult : public FPlayFabBaseModel
    {
        // [optional] Unique identifier for the shared group.
        FString SharedGroupId;

        FCreateSharedGroupResult() :
            FPlayFabBaseModel(),
            SharedGroupId()
            {}

        FCreateSharedGroupResult(const FCreateSharedGroupResult& src) :
            FPlayFabBaseModel(),
            SharedGroupId(src.SharedGroupId)
            {}

        FCreateSharedGroupResult(const TSharedPtr<FJsonObject>& obj) : FCreateSharedGroupResult()
        {
            readFromValue(obj);
        }

        ~FCreateSharedGroupResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FDeleteCharacterFromUserRequest : public FPlayFabBaseModel
    {
        // Unique PlayFab assigned ID for a specific character owned by a user
        FString CharacterId;

        // Unique PlayFab assigned ID of the user on whom the operation will be performed.
        FString PlayFabId;

        /**
         * If true, the character's inventory will be transferred up to the owning user; otherwise, this request will purge those
         * items.
         */
        bool SaveCharacterInventory;

        FDeleteCharacterFromUserRequest() :
            FPlayFabBaseModel(),
            CharacterId(),
            PlayFabId(),
            SaveCharacterInventory(false)
            {}

        FDeleteCharacterFromUserRequest(const FDeleteCharacterFromUserRequest& src) :
            FPlayFabBaseModel(),
            CharacterId(src.CharacterId),
            PlayFabId(src.PlayFabId),
            SaveCharacterInventory(src.SaveCharacterInventory)
            {}

        FDeleteCharacterFromUserRequest(const TSharedPtr<FJsonObject>& obj) : FDeleteCharacterFromUserRequest()
        {
            readFromValue(obj);
        }

        ~FDeleteCharacterFromUserRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FDeleteCharacterFromUserResult : public FPlayFabBaseModel
    {
        FDeleteCharacterFromUserResult() :
            FPlayFabBaseModel()
            {}

        FDeleteCharacterFromUserResult(const FDeleteCharacterFromUserResult& src) :
            FPlayFabBaseModel()
            {}

        FDeleteCharacterFromUserResult(const TSharedPtr<FJsonObject>& obj) : FDeleteCharacterFromUserResult()
        {
            readFromValue(obj);
        }

        ~FDeleteCharacterFromUserResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FDeleteSharedGroupRequest : public FPlayFabBaseModel
    {
        // Unique identifier for the shared group.
        FString SharedGroupId;

        FDeleteSharedGroupRequest() :
            FPlayFabBaseModel(),
            SharedGroupId()
            {}

        FDeleteSharedGroupRequest(const FDeleteSharedGroupRequest& src) :
            FPlayFabBaseModel(),
            SharedGroupId(src.SharedGroupId)
            {}

        FDeleteSharedGroupRequest(const TSharedPtr<FJsonObject>& obj) : FDeleteSharedGroupRequest()
        {
            readFromValue(obj);
        }

        ~FDeleteSharedGroupRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FDeleteUsersRequest : public FPlayFabBaseModel
    {
        // An array of unique PlayFab assigned ID of the user on whom the operation will be performed.
        TArray<FString> PlayFabIds;
        /**
         * Unique identifier for the title, found in the Settings > Game Properties section of the PlayFab developer site when a
         * title has been selected.
         */
        FString TitleId;

        FDeleteUsersRequest() :
            FPlayFabBaseModel(),
            PlayFabIds(),
            TitleId()
            {}

        FDeleteUsersRequest(const FDeleteUsersRequest& src) :
            FPlayFabBaseModel(),
            PlayFabIds(src.PlayFabIds),
            TitleId(src.TitleId)
            {}

        FDeleteUsersRequest(const TSharedPtr<FJsonObject>& obj) : FDeleteUsersRequest()
        {
            readFromValue(obj);
        }

        ~FDeleteUsersRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FDeleteUsersResult : public FPlayFabBaseModel
    {
        FDeleteUsersResult() :
            FPlayFabBaseModel()
            {}

        FDeleteUsersResult(const FDeleteUsersResult& src) :
            FPlayFabBaseModel()
            {}

        FDeleteUsersResult(const TSharedPtr<FJsonObject>& obj) : FDeleteUsersResult()
        {
            readFromValue(obj);
        }

        ~FDeleteUsersResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FDeregisterGameRequest : public FPlayFabBaseModel
    {
        // Unique identifier for the Game Server Instance that is being deregistered.
        FString LobbyId;

        FDeregisterGameRequest() :
            FPlayFabBaseModel(),
            LobbyId()
            {}

        FDeregisterGameRequest(const FDeregisterGameRequest& src) :
            FPlayFabBaseModel(),
            LobbyId(src.LobbyId)
            {}

        FDeregisterGameRequest(const TSharedPtr<FJsonObject>& obj) : FDeregisterGameRequest()
        {
            readFromValue(obj);
        }

        ~FDeregisterGameRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FDeregisterGameResponse : public FPlayFabBaseModel
    {
        FDeregisterGameResponse() :
            FPlayFabBaseModel()
            {}

        FDeregisterGameResponse(const FDeregisterGameResponse& src) :
            FPlayFabBaseModel()
            {}

        FDeregisterGameResponse(const TSharedPtr<FJsonObject>& obj) : FDeregisterGameResponse()
        {
            readFromValue(obj);
        }

        ~FDeregisterGameResponse();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FEmptyResult : public FPlayFabBaseModel
    {
        FEmptyResult() :
            FPlayFabBaseModel()
            {}

        FEmptyResult(const FEmptyResult& src) :
            FPlayFabBaseModel()
            {}

        FEmptyResult(const TSharedPtr<FJsonObject>& obj) : FEmptyResult()
        {
            readFromValue(obj);
        }

        ~FEmptyResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FEvaluateRandomResultTableRequest : public FPlayFabBaseModel
    {
        /**
         * [optional] Specifies the catalog version that should be used to evaluate the Random Result Table. If unspecified, uses
         * default/primary catalog.
         */
        FString CatalogVersion;

        // The unique identifier of the Random Result Table to use.
        FString TableId;

        FEvaluateRandomResultTableRequest() :
            FPlayFabBaseModel(),
            CatalogVersion(),
            TableId()
            {}

        FEvaluateRandomResultTableRequest(const FEvaluateRandomResultTableRequest& src) :
            FPlayFabBaseModel(),
            CatalogVersion(src.CatalogVersion),
            TableId(src.TableId)
            {}

        FEvaluateRandomResultTableRequest(const TSharedPtr<FJsonObject>& obj) : FEvaluateRandomResultTableRequest()
        {
            readFromValue(obj);
        }

        ~FEvaluateRandomResultTableRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FEvaluateRandomResultTableResult : public FPlayFabBaseModel
    {
        // [optional] Unique identifier for the item returned from the Random Result Table evaluation, for the given catalog.
        FString ResultItemId;

        FEvaluateRandomResultTableResult() :
            FPlayFabBaseModel(),
            ResultItemId()
            {}

        FEvaluateRandomResultTableResult(const FEvaluateRandomResultTableResult& src) :
            FPlayFabBaseModel(),
            ResultItemId(src.ResultItemId)
            {}

        FEvaluateRandomResultTableResult(const TSharedPtr<FJsonObject>& obj) : FEvaluateRandomResultTableResult()
        {
            readFromValue(obj);
        }

        ~FEvaluateRandomResultTableResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FScriptExecutionError : public FPlayFabBaseModel
    {
        /**
         * [optional] Error code, such as CloudScriptNotFound, JavascriptException, CloudScriptFunctionArgumentSizeExceeded,
         * CloudScriptAPIRequestCountExceeded, CloudScriptAPIRequestError, or CloudScriptHTTPRequestError
         */
        FString Error;

        // [optional] Details about the error
        FString Message;

        // [optional] Point during the execution of the script at which the error occurred, if any
        FString StackTrace;

        FScriptExecutionError() :
            FPlayFabBaseModel(),
            Error(),
            Message(),
            StackTrace()
            {}

        FScriptExecutionError(const FScriptExecutionError& src) :
            FPlayFabBaseModel(),
            Error(src.Error),
            Message(src.Message),
            StackTrace(src.StackTrace)
            {}

        FScriptExecutionError(const TSharedPtr<FJsonObject>& obj) : FScriptExecutionError()
        {
            readFromValue(obj);
        }

        ~FScriptExecutionError();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FLogStatement : public FPlayFabBaseModel
    {
        // [optional] Optional object accompanying the message as contextual information
        FJsonKeeper Data;

        // [optional] 'Debug', 'Info', or 'Error'
        FString Level;

        // [optional] undefined
        FString Message;

        FLogStatement() :
            FPlayFabBaseModel(),
            Data(),
            Level(),
            Message()
            {}

        FLogStatement(const FLogStatement& src) :
            FPlayFabBaseModel(),
            Data(src.Data),
            Level(src.Level),
            Message(src.Message)
            {}

        FLogStatement(const TSharedPtr<FJsonObject>& obj) : FLogStatement()
        {
            readFromValue(obj);
        }

        ~FLogStatement();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FExecuteCloudScriptResult : public FPlayFabBaseModel
    {
        // Number of PlayFab API requests issued by the CloudScript function
        int32 APIRequestsIssued;

        // [optional] Information about the error, if any, that occurred during execution
        TSharedPtr<FScriptExecutionError> Error;

        double ExecutionTimeSeconds;

        // [optional] The name of the function that executed
        FString FunctionName;

        // [optional] The object returned from the CloudScript function, if any
        FJsonKeeper FunctionResult;

        /**
         * [optional] Flag indicating if the FunctionResult was too large and was subsequently dropped from this event. This only occurs if
         * the total event size is larger than 350KB.
         */
        Boxed<bool> FunctionResultTooLarge;

        // Number of external HTTP requests issued by the CloudScript function
        int32 HttpRequestsIssued;

        /**
         * [optional] Entries logged during the function execution. These include both entries logged in the function code using log.info()
         * and log.error() and error entries for API and HTTP request failures.
         */
        TArray<FLogStatement> Logs;
        /**
         * [optional] Flag indicating if the logs were too large and were subsequently dropped from this event. This only occurs if the total
         * event size is larger than 350KB after the FunctionResult was removed.
         */
        Boxed<bool> LogsTooLarge;

        uint32 MemoryConsumedBytes;

        /**
         * Processor time consumed while executing the function. This does not include time spent waiting on API calls or HTTP
         * requests.
         */
        double ProcessorTimeSeconds;

        // The revision of the CloudScript that executed
        int32 Revision;

        FExecuteCloudScriptResult() :
            FPlayFabBaseModel(),
            APIRequestsIssued(0),
            Error(nullptr),
            ExecutionTimeSeconds(0),
            FunctionName(),
            FunctionResult(),
            FunctionResultTooLarge(),
            HttpRequestsIssued(0),
            Logs(),
            LogsTooLarge(),
            MemoryConsumedBytes(0),
            ProcessorTimeSeconds(0),
            Revision(0)
            {}

        FExecuteCloudScriptResult(const FExecuteCloudScriptResult& src) :
            FPlayFabBaseModel(),
            APIRequestsIssued(src.APIRequestsIssued),
            Error(src.Error.IsValid() ? MakeShareable(new FScriptExecutionError(*src.Error)) : nullptr),
            ExecutionTimeSeconds(src.ExecutionTimeSeconds),
            FunctionName(src.FunctionName),
            FunctionResult(src.FunctionResult),
            FunctionResultTooLarge(src.FunctionResultTooLarge),
            HttpRequestsIssued(src.HttpRequestsIssued),
            Logs(src.Logs),
            LogsTooLarge(src.LogsTooLarge),
            MemoryConsumedBytes(src.MemoryConsumedBytes),
            ProcessorTimeSeconds(src.ProcessorTimeSeconds),
            Revision(src.Revision)
            {}

        FExecuteCloudScriptResult(const TSharedPtr<FJsonObject>& obj) : FExecuteCloudScriptResult()
        {
            readFromValue(obj);
        }

        ~FExecuteCloudScriptResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FExecuteCloudScriptServerRequest : public FPlayFabBaseModel
    {
        // The name of the CloudScript function to execute
        FString FunctionName;

        // [optional] Object that is passed in to the function as the first argument
        FJsonKeeper FunctionParameter;

        /**
         * [optional] Generate a 'player_executed_cloudscript' PlayStream event containing the results of the function execution and other
         * contextual information. This event will show up in the PlayStream debugger console for the player in Game Manager.
         */
        Boxed<bool> GeneratePlayStreamEvent;

        // The unique user identifier for the player on whose behalf the script is being run
        FString PlayFabId;

        /**
         * [optional] Option for which revision of the CloudScript to execute. 'Latest' executes the most recently created revision, 'Live'
         * executes the current live, published revision, and 'Specific' executes the specified revision. The default value is
         * 'Specific', if the SpeificRevision parameter is specified, otherwise it is 'Live'.
         */
        Boxed<CloudScriptRevisionOption> RevisionSelection;

        // [optional] The specivic revision to execute, when RevisionSelection is set to 'Specific'
        Boxed<int32> SpecificRevision;

        FExecuteCloudScriptServerRequest() :
            FPlayFabBaseModel(),
            FunctionName(),
            FunctionParameter(),
            GeneratePlayStreamEvent(),
            PlayFabId(),
            RevisionSelection(),
            SpecificRevision()
            {}

        FExecuteCloudScriptServerRequest(const FExecuteCloudScriptServerRequest& src) :
            FPlayFabBaseModel(),
            FunctionName(src.FunctionName),
            FunctionParameter(src.FunctionParameter),
            GeneratePlayStreamEvent(src.GeneratePlayStreamEvent),
            PlayFabId(src.PlayFabId),
            RevisionSelection(src.RevisionSelection),
            SpecificRevision(src.SpecificRevision)
            {}

        FExecuteCloudScriptServerRequest(const TSharedPtr<FJsonObject>& obj) : FExecuteCloudScriptServerRequest()
        {
            readFromValue(obj);
        }

        ~FExecuteCloudScriptServerRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FFacebookPlayFabIdPair : public FPlayFabBaseModel
    {
        // [optional] Unique Facebook identifier for a user.
        FString FacebookId;

        // [optional] Unique PlayFab identifier for a user, or null if no PlayFab account is linked to the Facebook identifier.
        FString PlayFabId;

        FFacebookPlayFabIdPair() :
            FPlayFabBaseModel(),
            FacebookId(),
            PlayFabId()
            {}

        FFacebookPlayFabIdPair(const FFacebookPlayFabIdPair& src) :
            FPlayFabBaseModel(),
            FacebookId(src.FacebookId),
            PlayFabId(src.PlayFabId)
            {}

        FFacebookPlayFabIdPair(const TSharedPtr<FJsonObject>& obj) : FFacebookPlayFabIdPair()
        {
            readFromValue(obj);
        }

        ~FFacebookPlayFabIdPair();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    enum LoginIdentityProvider
    {
        LoginIdentityProviderUnknown,
        LoginIdentityProviderPlayFab,
        LoginIdentityProviderCustom,
        LoginIdentityProviderGameCenter,
        LoginIdentityProviderGooglePlay,
        LoginIdentityProviderSteam,
        LoginIdentityProviderXBoxLive,
        LoginIdentityProviderPSN,
        LoginIdentityProviderKongregate,
        LoginIdentityProviderFacebook,
        LoginIdentityProviderIOSDevice,
        LoginIdentityProviderAndroidDevice,
        LoginIdentityProviderTwitch,
        LoginIdentityProviderWindowsHello
    };

    PLAYFAB_API void writeLoginIdentityProviderEnumJSON(LoginIdentityProvider enumVal, JsonWriter& writer);
    PLAYFAB_API LoginIdentityProvider readLoginIdentityProviderFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFAB_API LoginIdentityProvider readLoginIdentityProviderFromValue(const FString& value);

    struct PLAYFAB_API FLinkedPlatformAccountModel : public FPlayFabBaseModel
    {
        // [optional] Linked account email of the user on the platform, if available
        FString Email;

        // [optional] Authentication platform
        Boxed<LoginIdentityProvider> Platform;

        // [optional] Unique account identifier of the user on the platform
        FString PlatformUserId;

        // [optional] Linked account username of the user on the platform, if available
        FString Username;

        FLinkedPlatformAccountModel() :
            FPlayFabBaseModel(),
            Email(),
            Platform(),
            PlatformUserId(),
            Username()
            {}

        FLinkedPlatformAccountModel(const FLinkedPlatformAccountModel& src) :
            FPlayFabBaseModel(),
            Email(src.Email),
            Platform(src.Platform),
            PlatformUserId(src.PlatformUserId),
            Username(src.Username)
            {}

        FLinkedPlatformAccountModel(const TSharedPtr<FJsonObject>& obj) : FLinkedPlatformAccountModel()
        {
            readFromValue(obj);
        }

        ~FLinkedPlatformAccountModel();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FLocationModel : public FPlayFabBaseModel
    {
        // [optional] City name.
        FString City;

        // [optional] The two-character continent code for this location
        Boxed<ContinentCode> pfContinentCode;

        // [optional] The two-character ISO 3166-1 country code for the country associated with the location
        Boxed<CountryCode> pfCountryCode;

        // [optional] Latitude coordinate of the geographic location.
        Boxed<double> Latitude;

        // [optional] Longitude coordinate of the geographic location.
        Boxed<double> Longitude;

        FLocationModel() :
            FPlayFabBaseModel(),
            City(),
            pfContinentCode(),
            pfCountryCode(),
            Latitude(),
            Longitude()
            {}

        FLocationModel(const FLocationModel& src) :
            FPlayFabBaseModel(),
            City(src.City),
            pfContinentCode(src.pfContinentCode),
            pfCountryCode(src.pfCountryCode),
            Latitude(src.Latitude),
            Longitude(src.Longitude)
            {}

        FLocationModel(const TSharedPtr<FJsonObject>& obj) : FLocationModel()
        {
            readFromValue(obj);
        }

        ~FLocationModel();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    enum SubscriptionProviderStatus
    {
        SubscriptionProviderStatusNoError,
        SubscriptionProviderStatusCancelled,
        SubscriptionProviderStatusUnknownError,
        SubscriptionProviderStatusBillingError,
        SubscriptionProviderStatusProductUnavailable,
        SubscriptionProviderStatusCustomerDidNotAcceptPriceChange,
        SubscriptionProviderStatusFreeTrial,
        SubscriptionProviderStatusPaymentPending
    };

    PLAYFAB_API void writeSubscriptionProviderStatusEnumJSON(SubscriptionProviderStatus enumVal, JsonWriter& writer);
    PLAYFAB_API SubscriptionProviderStatus readSubscriptionProviderStatusFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFAB_API SubscriptionProviderStatus readSubscriptionProviderStatusFromValue(const FString& value);

    struct PLAYFAB_API FSubscriptionModel : public FPlayFabBaseModel
    {
        // When this subscription expires.
        FDateTime Expiration;

        // The time the subscription was orignially purchased
        FDateTime InitialSubscriptionTime;

        // Whether this subscription is currently active. That is, if Expiration > now.
        bool IsActive;

        // [optional] The status of this subscription, according to the subscription provider.
        Boxed<SubscriptionProviderStatus> Status;

        // [optional] The id for this subscription
        FString SubscriptionId;

        // [optional] The item id for this subscription from the primary catalog
        FString SubscriptionItemId;

        // [optional] The provider for this subscription. Apple or Google Play are supported today.
        FString SubscriptionProvider;

        FSubscriptionModel() :
            FPlayFabBaseModel(),
            Expiration(0),
            InitialSubscriptionTime(0),
            IsActive(false),
            Status(),
            SubscriptionId(),
            SubscriptionItemId(),
            SubscriptionProvider()
            {}

        FSubscriptionModel(const FSubscriptionModel& src) :
            FPlayFabBaseModel(),
            Expiration(src.Expiration),
            InitialSubscriptionTime(src.InitialSubscriptionTime),
            IsActive(src.IsActive),
            Status(src.Status),
            SubscriptionId(src.SubscriptionId),
            SubscriptionItemId(src.SubscriptionItemId),
            SubscriptionProvider(src.SubscriptionProvider)
            {}

        FSubscriptionModel(const TSharedPtr<FJsonObject>& obj) : FSubscriptionModel()
        {
            readFromValue(obj);
        }

        ~FSubscriptionModel();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FMembershipModel : public FPlayFabBaseModel
    {
        // Whether this membership is active. That is, whether the MembershipExpiration time has been reached.
        bool IsActive;

        // The time this membership expires
        FDateTime MembershipExpiration;

        // [optional] The id of the membership
        FString MembershipId;

        /**
         * [optional] Membership expirations can be explicitly overridden (via game manager or the admin api). If this membership has been
         * overridden, this will be the new expiration time.
         */
        Boxed<FDateTime> OverrideExpiration;

        // [optional] Whether the override expiration is set.
        Boxed<bool> OverrideIsSet;

        // [optional] The list of subscriptions that this player has for this membership
        TArray<FSubscriptionModel> Subscriptions;
        FMembershipModel() :
            FPlayFabBaseModel(),
            IsActive(false),
            MembershipExpiration(0),
            MembershipId(),
            OverrideExpiration(),
            OverrideIsSet(),
            Subscriptions()
            {}

        FMembershipModel(const FMembershipModel& src) :
            FPlayFabBaseModel(),
            IsActive(src.IsActive),
            MembershipExpiration(src.MembershipExpiration),
            MembershipId(src.MembershipId),
            OverrideExpiration(src.OverrideExpiration),
            OverrideIsSet(src.OverrideIsSet),
            Subscriptions(src.Subscriptions)
            {}

        FMembershipModel(const TSharedPtr<FJsonObject>& obj) : FMembershipModel()
        {
            readFromValue(obj);
        }

        ~FMembershipModel();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FPushNotificationRegistrationModel : public FPlayFabBaseModel
    {
        // [optional] Notification configured endpoint
        FString NotificationEndpointARN;

        // [optional] Push notification platform
        Boxed<PushNotificationPlatform> Platform;

        FPushNotificationRegistrationModel() :
            FPlayFabBaseModel(),
            NotificationEndpointARN(),
            Platform()
            {}

        FPushNotificationRegistrationModel(const FPushNotificationRegistrationModel& src) :
            FPlayFabBaseModel(),
            NotificationEndpointARN(src.NotificationEndpointARN),
            Platform(src.Platform)
            {}

        FPushNotificationRegistrationModel(const TSharedPtr<FJsonObject>& obj) : FPushNotificationRegistrationModel()
        {
            readFromValue(obj);
        }

        ~FPushNotificationRegistrationModel();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FStatisticModel : public FPlayFabBaseModel
    {
        // [optional] Statistic name
        FString Name;

        // Statistic value
        int32 Value;

        // Statistic version (0 if not a versioned statistic)
        int32 Version;

        FStatisticModel() :
            FPlayFabBaseModel(),
            Name(),
            Value(0),
            Version(0)
            {}

        FStatisticModel(const FStatisticModel& src) :
            FPlayFabBaseModel(),
            Name(src.Name),
            Value(src.Value),
            Version(src.Version)
            {}

        FStatisticModel(const TSharedPtr<FJsonObject>& obj) : FStatisticModel()
        {
            readFromValue(obj);
        }

        ~FStatisticModel();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FTagModel : public FPlayFabBaseModel
    {
        // [optional] Full value of the tag, including namespace
        FString TagValue;

        FTagModel() :
            FPlayFabBaseModel(),
            TagValue()
            {}

        FTagModel(const FTagModel& src) :
            FPlayFabBaseModel(),
            TagValue(src.TagValue)
            {}

        FTagModel(const TSharedPtr<FJsonObject>& obj) : FTagModel()
        {
            readFromValue(obj);
        }

        ~FTagModel();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FValueToDateModel : public FPlayFabBaseModel
    {
        // [optional] ISO 4217 code of the currency used in the purchases
        FString Currency;

        /**
         * Total value of the purchases in a whole number of 1/100 monetary units. For example, 999 indicates nine dollars and
         * ninety-nine cents when Currency is 'USD')
         */
        uint32 TotalValue;

        /**
         * [optional] Total value of the purchases in a string representation of decimal monetary units. For example, '9.99' indicates nine
         * dollars and ninety-nine cents when Currency is 'USD'.
         */
        FString TotalValueAsDecimal;

        FValueToDateModel() :
            FPlayFabBaseModel(),
            Currency(),
            TotalValue(0),
            TotalValueAsDecimal()
            {}

        FValueToDateModel(const FValueToDateModel& src) :
            FPlayFabBaseModel(),
            Currency(src.Currency),
            TotalValue(src.TotalValue),
            TotalValueAsDecimal(src.TotalValueAsDecimal)
            {}

        FValueToDateModel(const TSharedPtr<FJsonObject>& obj) : FValueToDateModel()
        {
            readFromValue(obj);
        }

        ~FValueToDateModel();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FPlayerProfileModel : public FPlayFabBaseModel
    {
        // [optional] List of advertising campaigns the player has been attributed to
        TArray<FAdCampaignAttributionModel> AdCampaignAttributions;
        // [optional] URL of the player's avatar image
        FString AvatarUrl;

        // [optional] If the player is currently banned, the UTC Date when the ban expires
        Boxed<FDateTime> BannedUntil;

        // [optional] List of all contact email info associated with the player account
        TArray<FContactEmailInfoModel> ContactEmailAddresses;
        // [optional] Player record created
        Boxed<FDateTime> Created;

        // [optional] Player display name
        FString DisplayName;

        // [optional] UTC time when the player most recently logged in to the title
        Boxed<FDateTime> LastLogin;

        // [optional] List of all authentication systems linked to this player account
        TArray<FLinkedPlatformAccountModel> LinkedAccounts;
        // [optional] List of geographic locations from which the player has logged in to the title
        TArray<FLocationModel> Locations;
        // [optional] List of memberships for the player, along with whether are expired.
        TArray<FMembershipModel> Memberships;
        // [optional] Player account origination
        Boxed<LoginIdentityProvider> Origination;

        // [optional] PlayFab player account unique identifier
        FString PlayerId;

        // [optional] Publisher this player belongs to
        FString PublisherId;

        // [optional] List of configured end points registered for sending the player push notifications
        TArray<FPushNotificationRegistrationModel> PushNotificationRegistrations;
        // [optional] List of leaderboard statistic values for the player
        TArray<FStatisticModel> Statistics;
        // [optional] List of player's tags for segmentation
        TArray<FTagModel> Tags;
        // [optional] Title ID this player profile applies to
        FString TitleId;

        /**
         * [optional] Sum of the player's purchases made with real-money currencies, converted to US dollars equivalent and represented as a
         * whole number of cents (1/100 USD).       For example, 999 indicates nine dollars and ninety-nine cents.
         */
        Boxed<uint32> TotalValueToDateInUSD;

        // [optional] List of the player's lifetime purchase totals, summed by real-money currency
        TArray<FValueToDateModel> ValuesToDate;
        FPlayerProfileModel() :
            FPlayFabBaseModel(),
            AdCampaignAttributions(),
            AvatarUrl(),
            BannedUntil(),
            ContactEmailAddresses(),
            Created(),
            DisplayName(),
            LastLogin(),
            LinkedAccounts(),
            Locations(),
            Memberships(),
            Origination(),
            PlayerId(),
            PublisherId(),
            PushNotificationRegistrations(),
            Statistics(),
            Tags(),
            TitleId(),
            TotalValueToDateInUSD(),
            ValuesToDate()
            {}

        FPlayerProfileModel(const FPlayerProfileModel& src) :
            FPlayFabBaseModel(),
            AdCampaignAttributions(src.AdCampaignAttributions),
            AvatarUrl(src.AvatarUrl),
            BannedUntil(src.BannedUntil),
            ContactEmailAddresses(src.ContactEmailAddresses),
            Created(src.Created),
            DisplayName(src.DisplayName),
            LastLogin(src.LastLogin),
            LinkedAccounts(src.LinkedAccounts),
            Locations(src.Locations),
            Memberships(src.Memberships),
            Origination(src.Origination),
            PlayerId(src.PlayerId),
            PublisherId(src.PublisherId),
            PushNotificationRegistrations(src.PushNotificationRegistrations),
            Statistics(src.Statistics),
            Tags(src.Tags),
            TitleId(src.TitleId),
            TotalValueToDateInUSD(src.TotalValueToDateInUSD),
            ValuesToDate(src.ValuesToDate)
            {}

        FPlayerProfileModel(const TSharedPtr<FJsonObject>& obj) : FPlayerProfileModel()
        {
            readFromValue(obj);
        }

        ~FPlayerProfileModel();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FFriendInfo : public FPlayFabBaseModel
    {
        // [optional] Unique lobby identifier of the Game Server Instance to which this player is currently connected.
        FString CurrentMatchmakerLobbyId;

        // [optional] Available Facebook information (if the user and PlayFab friend are also connected in Facebook).
        TSharedPtr<FUserFacebookInfo> FacebookInfo;

        // [optional] PlayFab unique identifier for this friend.
        FString FriendPlayFabId;

        // [optional] Available Game Center information (if the user and PlayFab friend are also connected in Game Center).
        TSharedPtr<FUserGameCenterInfo> GameCenterInfo;

        // [optional] The profile of the user, if requested.
        TSharedPtr<FPlayerProfileModel> Profile;

        // [optional] Available Steam information (if the user and PlayFab friend are also connected in Steam).
        TSharedPtr<FUserSteamInfo> SteamInfo;

        // [optional] Tags which have been associated with this friend.
        TArray<FString> Tags;
        // [optional] Title-specific display name for this friend.
        FString TitleDisplayName;

        // [optional] PlayFab unique username for this friend.
        FString Username;

        FFriendInfo() :
            FPlayFabBaseModel(),
            CurrentMatchmakerLobbyId(),
            FacebookInfo(nullptr),
            FriendPlayFabId(),
            GameCenterInfo(nullptr),
            Profile(nullptr),
            SteamInfo(nullptr),
            Tags(),
            TitleDisplayName(),
            Username()
            {}

        FFriendInfo(const FFriendInfo& src) :
            FPlayFabBaseModel(),
            CurrentMatchmakerLobbyId(src.CurrentMatchmakerLobbyId),
            FacebookInfo(src.FacebookInfo.IsValid() ? MakeShareable(new FUserFacebookInfo(*src.FacebookInfo)) : nullptr),
            FriendPlayFabId(src.FriendPlayFabId),
            GameCenterInfo(src.GameCenterInfo.IsValid() ? MakeShareable(new FUserGameCenterInfo(*src.GameCenterInfo)) : nullptr),
            Profile(src.Profile.IsValid() ? MakeShareable(new FPlayerProfileModel(*src.Profile)) : nullptr),
            SteamInfo(src.SteamInfo.IsValid() ? MakeShareable(new FUserSteamInfo(*src.SteamInfo)) : nullptr),
            Tags(src.Tags),
            TitleDisplayName(src.TitleDisplayName),
            Username(src.Username)
            {}

        FFriendInfo(const TSharedPtr<FJsonObject>& obj) : FFriendInfo()
        {
            readFromValue(obj);
        }

        ~FFriendInfo();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    enum GameInstanceState
    {
        GameInstanceStateOpen,
        GameInstanceStateClosed
    };

    PLAYFAB_API void writeGameInstanceStateEnumJSON(GameInstanceState enumVal, JsonWriter& writer);
    PLAYFAB_API GameInstanceState readGameInstanceStateFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFAB_API GameInstanceState readGameInstanceStateFromValue(const FString& value);

    struct PLAYFAB_API FGetAllSegmentsRequest : public FPlayFabBaseModel
    {
        FGetAllSegmentsRequest() :
            FPlayFabBaseModel()
            {}

        FGetAllSegmentsRequest(const FGetAllSegmentsRequest& src) :
            FPlayFabBaseModel()
            {}

        FGetAllSegmentsRequest(const TSharedPtr<FJsonObject>& obj) : FGetAllSegmentsRequest()
        {
            readFromValue(obj);
        }

        ~FGetAllSegmentsRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetSegmentResult : public FPlayFabBaseModel
    {
        // [optional] Identifier of the segments AB Test, if it is attached to one.
        FString ABTestParent;

        // Unique identifier for this segment.
        FString Id;

        // [optional] Segment name.
        FString Name;

        FGetSegmentResult() :
            FPlayFabBaseModel(),
            ABTestParent(),
            Id(),
            Name()
            {}

        FGetSegmentResult(const FGetSegmentResult& src) :
            FPlayFabBaseModel(),
            ABTestParent(src.ABTestParent),
            Id(src.Id),
            Name(src.Name)
            {}

        FGetSegmentResult(const TSharedPtr<FJsonObject>& obj) : FGetSegmentResult()
        {
            readFromValue(obj);
        }

        ~FGetSegmentResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetAllSegmentsResult : public FPlayFabBaseModel
    {
        // [optional] Array of segments for this title.
        TArray<FGetSegmentResult> Segments;
        FGetAllSegmentsResult() :
            FPlayFabBaseModel(),
            Segments()
            {}

        FGetAllSegmentsResult(const FGetAllSegmentsResult& src) :
            FPlayFabBaseModel(),
            Segments(src.Segments)
            {}

        FGetAllSegmentsResult(const TSharedPtr<FJsonObject>& obj) : FGetAllSegmentsResult()
        {
            readFromValue(obj);
        }

        ~FGetAllSegmentsResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetCatalogItemsRequest : public FPlayFabBaseModel
    {
        // [optional] Which catalog is being requested. If null, uses the default catalog.
        FString CatalogVersion;

        FGetCatalogItemsRequest() :
            FPlayFabBaseModel(),
            CatalogVersion()
            {}

        FGetCatalogItemsRequest(const FGetCatalogItemsRequest& src) :
            FPlayFabBaseModel(),
            CatalogVersion(src.CatalogVersion)
            {}

        FGetCatalogItemsRequest(const TSharedPtr<FJsonObject>& obj) : FGetCatalogItemsRequest()
        {
            readFromValue(obj);
        }

        ~FGetCatalogItemsRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetCatalogItemsResult : public FPlayFabBaseModel
    {
        // [optional] Array of items which can be purchased.
        TArray<FCatalogItem> Catalog;
        FGetCatalogItemsResult() :
            FPlayFabBaseModel(),
            Catalog()
            {}

        FGetCatalogItemsResult(const FGetCatalogItemsResult& src) :
            FPlayFabBaseModel(),
            Catalog(src.Catalog)
            {}

        FGetCatalogItemsResult(const TSharedPtr<FJsonObject>& obj) : FGetCatalogItemsResult()
        {
            readFromValue(obj);
        }

        ~FGetCatalogItemsResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetCharacterDataRequest : public FPlayFabBaseModel
    {
        // Unique PlayFab assigned ID for a specific character owned by a user
        FString CharacterId;

        /**
         * [optional] The version that currently exists according to the caller. The call will return the data for all of the keys if the
         * version in the system is greater than this.
         */
        Boxed<uint32> IfChangedFromDataVersion;

        // [optional] Specific keys to search for in the custom user data.
        TArray<FString> Keys;
        // Unique PlayFab assigned ID of the user on whom the operation will be performed.
        FString PlayFabId;

        FGetCharacterDataRequest() :
            FPlayFabBaseModel(),
            CharacterId(),
            IfChangedFromDataVersion(),
            Keys(),
            PlayFabId()
            {}

        FGetCharacterDataRequest(const FGetCharacterDataRequest& src) :
            FPlayFabBaseModel(),
            CharacterId(src.CharacterId),
            IfChangedFromDataVersion(src.IfChangedFromDataVersion),
            Keys(src.Keys),
            PlayFabId(src.PlayFabId)
            {}

        FGetCharacterDataRequest(const TSharedPtr<FJsonObject>& obj) : FGetCharacterDataRequest()
        {
            readFromValue(obj);
        }

        ~FGetCharacterDataRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    enum UserDataPermission
    {
        UserDataPermissionPrivate,
        UserDataPermissionPublic
    };

    PLAYFAB_API void writeUserDataPermissionEnumJSON(UserDataPermission enumVal, JsonWriter& writer);
    PLAYFAB_API UserDataPermission readUserDataPermissionFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFAB_API UserDataPermission readUserDataPermissionFromValue(const FString& value);

    struct PLAYFAB_API FUserDataRecord : public FPlayFabBaseModel
    {
        // Timestamp for when this data was last updated.
        FDateTime LastUpdated;

        /**
         * [optional] Indicates whether this data can be read by all users (public) or only the user (private). This is used for GetUserData
         * requests being made by one player about another player.
         */
        Boxed<UserDataPermission> Permission;

        // [optional] Data stored for the specified user data key.
        FString Value;

        FUserDataRecord() :
            FPlayFabBaseModel(),
            LastUpdated(0),
            Permission(),
            Value()
            {}

        FUserDataRecord(const FUserDataRecord& src) :
            FPlayFabBaseModel(),
            LastUpdated(src.LastUpdated),
            Permission(src.Permission),
            Value(src.Value)
            {}

        FUserDataRecord(const TSharedPtr<FJsonObject>& obj) : FUserDataRecord()
        {
            readFromValue(obj);
        }

        ~FUserDataRecord();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetCharacterDataResult : public FPlayFabBaseModel
    {
        // [optional] Unique PlayFab assigned ID for a specific character owned by a user
        FString CharacterId;

        // [optional] User specific data for this title.
        TMap<FString, FUserDataRecord> Data;
        /**
         * Indicates the current version of the data that has been set. This is incremented with every set call for that type of
         * data (read-only, internal, etc). This version can be provided in Get calls to find updated data.
         */
        uint32 DataVersion;

        // [optional] Unique PlayFab assigned ID of the user on whom the operation will be performed.
        FString PlayFabId;

        FGetCharacterDataResult() :
            FPlayFabBaseModel(),
            CharacterId(),
            Data(),
            DataVersion(0),
            PlayFabId()
            {}

        FGetCharacterDataResult(const FGetCharacterDataResult& src) :
            FPlayFabBaseModel(),
            CharacterId(src.CharacterId),
            Data(src.Data),
            DataVersion(src.DataVersion),
            PlayFabId(src.PlayFabId)
            {}

        FGetCharacterDataResult(const TSharedPtr<FJsonObject>& obj) : FGetCharacterDataResult()
        {
            readFromValue(obj);
        }

        ~FGetCharacterDataResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetCharacterInventoryRequest : public FPlayFabBaseModel
    {
        // [optional] Used to limit results to only those from a specific catalog version.
        FString CatalogVersion;

        // Unique PlayFab assigned ID for a specific character owned by a user
        FString CharacterId;

        // Unique PlayFab assigned ID of the user on whom the operation will be performed.
        FString PlayFabId;

        FGetCharacterInventoryRequest() :
            FPlayFabBaseModel(),
            CatalogVersion(),
            CharacterId(),
            PlayFabId()
            {}

        FGetCharacterInventoryRequest(const FGetCharacterInventoryRequest& src) :
            FPlayFabBaseModel(),
            CatalogVersion(src.CatalogVersion),
            CharacterId(src.CharacterId),
            PlayFabId(src.PlayFabId)
            {}

        FGetCharacterInventoryRequest(const TSharedPtr<FJsonObject>& obj) : FGetCharacterInventoryRequest()
        {
            readFromValue(obj);
        }

        ~FGetCharacterInventoryRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FVirtualCurrencyRechargeTime : public FPlayFabBaseModel
    {
        /**
         * Maximum value to which the regenerating currency will automatically increment. Note that it can exceed this value
         * through use of the AddUserVirtualCurrency API call. However, it will not regenerate automatically until it has fallen
         * below this value.
         */
        int32 RechargeMax;

        // Server timestamp in UTC indicating the next time the virtual currency will be incremented.
        FDateTime RechargeTime;

        // Time remaining (in seconds) before the next recharge increment of the virtual currency.
        int32 SecondsToRecharge;

        FVirtualCurrencyRechargeTime() :
            FPlayFabBaseModel(),
            RechargeMax(0),
            RechargeTime(0),
            SecondsToRecharge(0)
            {}

        FVirtualCurrencyRechargeTime(const FVirtualCurrencyRechargeTime& src) :
            FPlayFabBaseModel(),
            RechargeMax(src.RechargeMax),
            RechargeTime(src.RechargeTime),
            SecondsToRecharge(src.SecondsToRecharge)
            {}

        FVirtualCurrencyRechargeTime(const TSharedPtr<FJsonObject>& obj) : FVirtualCurrencyRechargeTime()
        {
            readFromValue(obj);
        }

        ~FVirtualCurrencyRechargeTime();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetCharacterInventoryResult : public FPlayFabBaseModel
    {
        // [optional] Unique identifier of the character for this inventory.
        FString CharacterId;

        // [optional] Array of inventory items belonging to the character.
        TArray<FItemInstance> Inventory;
        // [optional] Unique PlayFab assigned ID of the user on whom the operation will be performed.
        FString PlayFabId;

        // [optional] Array of virtual currency balance(s) belonging to the character.
        TMap<FString, int32> VirtualCurrency;
        // [optional] Array of remaining times and timestamps for virtual currencies.
        TMap<FString, FVirtualCurrencyRechargeTime> VirtualCurrencyRechargeTimes;
        FGetCharacterInventoryResult() :
            FPlayFabBaseModel(),
            CharacterId(),
            Inventory(),
            PlayFabId(),
            VirtualCurrency(),
            VirtualCurrencyRechargeTimes()
            {}

        FGetCharacterInventoryResult(const FGetCharacterInventoryResult& src) :
            FPlayFabBaseModel(),
            CharacterId(src.CharacterId),
            Inventory(src.Inventory),
            PlayFabId(src.PlayFabId),
            VirtualCurrency(src.VirtualCurrency),
            VirtualCurrencyRechargeTimes(src.VirtualCurrencyRechargeTimes)
            {}

        FGetCharacterInventoryResult(const TSharedPtr<FJsonObject>& obj) : FGetCharacterInventoryResult()
        {
            readFromValue(obj);
        }

        ~FGetCharacterInventoryResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetCharacterLeaderboardRequest : public FPlayFabBaseModel
    {
        // Unique PlayFab assigned ID for a specific character owned by a user
        FString CharacterId;

        // [optional] Optional character type on which to filter the leaderboard entries.
        FString CharacterType;

        // Maximum number of entries to retrieve.
        int32 MaxResultsCount;

        // First entry in the leaderboard to be retrieved.
        int32 StartPosition;

        // Unique identifier for the title-specific statistic for the leaderboard.
        FString StatisticName;

        FGetCharacterLeaderboardRequest() :
            FPlayFabBaseModel(),
            CharacterId(),
            CharacterType(),
            MaxResultsCount(0),
            StartPosition(0),
            StatisticName()
            {}

        FGetCharacterLeaderboardRequest(const FGetCharacterLeaderboardRequest& src) :
            FPlayFabBaseModel(),
            CharacterId(src.CharacterId),
            CharacterType(src.CharacterType),
            MaxResultsCount(src.MaxResultsCount),
            StartPosition(src.StartPosition),
            StatisticName(src.StatisticName)
            {}

        FGetCharacterLeaderboardRequest(const TSharedPtr<FJsonObject>& obj) : FGetCharacterLeaderboardRequest()
        {
            readFromValue(obj);
        }

        ~FGetCharacterLeaderboardRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetCharacterLeaderboardResult : public FPlayFabBaseModel
    {
        // [optional] Ordered list of leaderboard entries.
        TArray<FCharacterLeaderboardEntry> Leaderboard;
        FGetCharacterLeaderboardResult() :
            FPlayFabBaseModel(),
            Leaderboard()
            {}

        FGetCharacterLeaderboardResult(const FGetCharacterLeaderboardResult& src) :
            FPlayFabBaseModel(),
            Leaderboard(src.Leaderboard)
            {}

        FGetCharacterLeaderboardResult(const TSharedPtr<FJsonObject>& obj) : FGetCharacterLeaderboardResult()
        {
            readFromValue(obj);
        }

        ~FGetCharacterLeaderboardResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetCharacterStatisticsRequest : public FPlayFabBaseModel
    {
        // Unique PlayFab assigned ID for a specific character owned by a user
        FString CharacterId;

        // Unique PlayFab assigned ID of the user on whom the operation will be performed.
        FString PlayFabId;

        FGetCharacterStatisticsRequest() :
            FPlayFabBaseModel(),
            CharacterId(),
            PlayFabId()
            {}

        FGetCharacterStatisticsRequest(const FGetCharacterStatisticsRequest& src) :
            FPlayFabBaseModel(),
            CharacterId(src.CharacterId),
            PlayFabId(src.PlayFabId)
            {}

        FGetCharacterStatisticsRequest(const TSharedPtr<FJsonObject>& obj) : FGetCharacterStatisticsRequest()
        {
            readFromValue(obj);
        }

        ~FGetCharacterStatisticsRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetCharacterStatisticsResult : public FPlayFabBaseModel
    {
        // [optional] Unique identifier of the character for the statistics.
        FString CharacterId;

        // [optional] Character statistics for the requested user.
        TMap<FString, int32> CharacterStatistics;
        // [optional] PlayFab unique identifier of the user whose character statistics are being returned.
        FString PlayFabId;

        FGetCharacterStatisticsResult() :
            FPlayFabBaseModel(),
            CharacterId(),
            CharacterStatistics(),
            PlayFabId()
            {}

        FGetCharacterStatisticsResult(const FGetCharacterStatisticsResult& src) :
            FPlayFabBaseModel(),
            CharacterId(src.CharacterId),
            CharacterStatistics(src.CharacterStatistics),
            PlayFabId(src.PlayFabId)
            {}

        FGetCharacterStatisticsResult(const TSharedPtr<FJsonObject>& obj) : FGetCharacterStatisticsResult()
        {
            readFromValue(obj);
        }

        ~FGetCharacterStatisticsResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetContentDownloadUrlRequest : public FPlayFabBaseModel
    {
        // [optional] HTTP method to fetch item - GET or HEAD. Use HEAD when only fetching metadata. Default is GET.
        FString HttpMethod;

        // Key of the content item to fetch, usually formatted as a path, e.g. images/a.png
        FString Key;

        /**
         * [optional] True to download through CDN. CDN provides higher download bandwidth and lower latency. However, if you want the latest,
         * non-cached version of the content during development, set this to false. Default is true.
         */
        Boxed<bool> ThruCDN;

        FGetContentDownloadUrlRequest() :
            FPlayFabBaseModel(),
            HttpMethod(),
            Key(),
            ThruCDN()
            {}

        FGetContentDownloadUrlRequest(const FGetContentDownloadUrlRequest& src) :
            FPlayFabBaseModel(),
            HttpMethod(src.HttpMethod),
            Key(src.Key),
            ThruCDN(src.ThruCDN)
            {}

        FGetContentDownloadUrlRequest(const TSharedPtr<FJsonObject>& obj) : FGetContentDownloadUrlRequest()
        {
            readFromValue(obj);
        }

        ~FGetContentDownloadUrlRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetContentDownloadUrlResult : public FPlayFabBaseModel
    {
        // [optional] URL for downloading content via HTTP GET or HEAD method. The URL will expire in approximately one hour.
        FString URL;

        FGetContentDownloadUrlResult() :
            FPlayFabBaseModel(),
            URL()
            {}

        FGetContentDownloadUrlResult(const FGetContentDownloadUrlResult& src) :
            FPlayFabBaseModel(),
            URL(src.URL)
            {}

        FGetContentDownloadUrlResult(const TSharedPtr<FJsonObject>& obj) : FGetContentDownloadUrlResult()
        {
            readFromValue(obj);
        }

        ~FGetContentDownloadUrlResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FPlayerProfileViewConstraints : public FPlayFabBaseModel
    {
        // Whether to show player's avatar URL. Defaults to false
        bool ShowAvatarUrl;

        // Whether to show the banned until time. Defaults to false
        bool ShowBannedUntil;

        // Whether to show campaign attributions. Defaults to false
        bool ShowCampaignAttributions;

        // Whether to show contact email addresses. Defaults to false
        bool ShowContactEmailAddresses;

        // Whether to show the created date. Defaults to false
        bool ShowCreated;

        // Whether to show the display name. Defaults to false
        bool ShowDisplayName;

        // Whether to show the last login time. Defaults to false
        bool ShowLastLogin;

        // Whether to show the linked accounts. Defaults to false
        bool ShowLinkedAccounts;

        // Whether to show player's locations. Defaults to false
        bool ShowLocations;

        // Whether to show player's membership information. Defaults to false
        bool ShowMemberships;

        // Whether to show origination. Defaults to false
        bool ShowOrigination;

        // Whether to show push notification registrations. Defaults to false
        bool ShowPushNotificationRegistrations;

        // Reserved for future development
        bool ShowStatistics;

        // Whether to show tags. Defaults to false
        bool ShowTags;

        // Whether to show the total value to date in usd. Defaults to false
        bool ShowTotalValueToDateInUsd;

        // Whether to show the values to date. Defaults to false
        bool ShowValuesToDate;

        FPlayerProfileViewConstraints() :
            FPlayFabBaseModel(),
            ShowAvatarUrl(false),
            ShowBannedUntil(false),
            ShowCampaignAttributions(false),
            ShowContactEmailAddresses(false),
            ShowCreated(false),
            ShowDisplayName(false),
            ShowLastLogin(false),
            ShowLinkedAccounts(false),
            ShowLocations(false),
            ShowMemberships(false),
            ShowOrigination(false),
            ShowPushNotificationRegistrations(false),
            ShowStatistics(false),
            ShowTags(false),
            ShowTotalValueToDateInUsd(false),
            ShowValuesToDate(false)
            {}

        FPlayerProfileViewConstraints(const FPlayerProfileViewConstraints& src) :
            FPlayFabBaseModel(),
            ShowAvatarUrl(src.ShowAvatarUrl),
            ShowBannedUntil(src.ShowBannedUntil),
            ShowCampaignAttributions(src.ShowCampaignAttributions),
            ShowContactEmailAddresses(src.ShowContactEmailAddresses),
            ShowCreated(src.ShowCreated),
            ShowDisplayName(src.ShowDisplayName),
            ShowLastLogin(src.ShowLastLogin),
            ShowLinkedAccounts(src.ShowLinkedAccounts),
            ShowLocations(src.ShowLocations),
            ShowMemberships(src.ShowMemberships),
            ShowOrigination(src.ShowOrigination),
            ShowPushNotificationRegistrations(src.ShowPushNotificationRegistrations),
            ShowStatistics(src.ShowStatistics),
            ShowTags(src.ShowTags),
            ShowTotalValueToDateInUsd(src.ShowTotalValueToDateInUsd),
            ShowValuesToDate(src.ShowValuesToDate)
            {}

        FPlayerProfileViewConstraints(const TSharedPtr<FJsonObject>& obj) : FPlayerProfileViewConstraints()
        {
            readFromValue(obj);
        }

        ~FPlayerProfileViewConstraints();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetFriendLeaderboardRequest : public FPlayFabBaseModel
    {
        // [optional] Indicates whether Facebook friends should be included in the response. Default is true.
        Boxed<bool> IncludeFacebookFriends;

        // [optional] Indicates whether Steam service friends should be included in the response. Default is true.
        Boxed<bool> IncludeSteamFriends;

        // Maximum number of entries to retrieve.
        int32 MaxResultsCount;

        // The player whose friend leaderboard to get
        FString PlayFabId;

        /**
         * [optional] If non-null, this determines which properties of the resulting player profiles to return. For API calls from the client,
         * only the allowed client profile properties for the title may be requested. These allowed properties are configured in
         * the Game Manager "Client Profile Options" tab in the "Settings" section.
         */
        TSharedPtr<FPlayerProfileViewConstraints> ProfileConstraints;

        // Position in the leaderboard to start this listing (defaults to the first entry).
        int32 StartPosition;

        // Statistic used to rank friends for this leaderboard.
        FString StatisticName;

        // [optional] If set to false, Version is considered null. If true, uses the specified Version
        Boxed<bool> UseSpecificVersion;

        // [optional] The version of the leaderboard to get.
        Boxed<int32> Version;

        FGetFriendLeaderboardRequest() :
            FPlayFabBaseModel(),
            IncludeFacebookFriends(),
            IncludeSteamFriends(),
            MaxResultsCount(0),
            PlayFabId(),
            ProfileConstraints(nullptr),
            StartPosition(0),
            StatisticName(),
            UseSpecificVersion(),
            Version()
            {}

        FGetFriendLeaderboardRequest(const FGetFriendLeaderboardRequest& src) :
            FPlayFabBaseModel(),
            IncludeFacebookFriends(src.IncludeFacebookFriends),
            IncludeSteamFriends(src.IncludeSteamFriends),
            MaxResultsCount(src.MaxResultsCount),
            PlayFabId(src.PlayFabId),
            ProfileConstraints(src.ProfileConstraints.IsValid() ? MakeShareable(new FPlayerProfileViewConstraints(*src.ProfileConstraints)) : nullptr),
            StartPosition(src.StartPosition),
            StatisticName(src.StatisticName),
            UseSpecificVersion(src.UseSpecificVersion),
            Version(src.Version)
            {}

        FGetFriendLeaderboardRequest(const TSharedPtr<FJsonObject>& obj) : FGetFriendLeaderboardRequest()
        {
            readFromValue(obj);
        }

        ~FGetFriendLeaderboardRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetFriendsListRequest : public FPlayFabBaseModel
    {
        // [optional] Indicates whether Facebook friends should be included in the response. Default is true.
        Boxed<bool> IncludeFacebookFriends;

        // [optional] Indicates whether Steam service friends should be included in the response. Default is true.
        Boxed<bool> IncludeSteamFriends;

        // PlayFab identifier of the player whose friend list to get.
        FString PlayFabId;

        /**
         * [optional] If non-null, this determines which properties of the resulting player profiles to return. For API calls from the client,
         * only the allowed client profile properties for the title may be requested. These allowed properties are configured in
         * the Game Manager "Client Profile Options" tab in the "Settings" section.
         */
        TSharedPtr<FPlayerProfileViewConstraints> ProfileConstraints;

        FGetFriendsListRequest() :
            FPlayFabBaseModel(),
            IncludeFacebookFriends(),
            IncludeSteamFriends(),
            PlayFabId(),
            ProfileConstraints(nullptr)
            {}

        FGetFriendsListRequest(const FGetFriendsListRequest& src) :
            FPlayFabBaseModel(),
            IncludeFacebookFriends(src.IncludeFacebookFriends),
            IncludeSteamFriends(src.IncludeSteamFriends),
            PlayFabId(src.PlayFabId),
            ProfileConstraints(src.ProfileConstraints.IsValid() ? MakeShareable(new FPlayerProfileViewConstraints(*src.ProfileConstraints)) : nullptr)
            {}

        FGetFriendsListRequest(const TSharedPtr<FJsonObject>& obj) : FGetFriendsListRequest()
        {
            readFromValue(obj);
        }

        ~FGetFriendsListRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetFriendsListResult : public FPlayFabBaseModel
    {
        // [optional] Array of friends found.
        TArray<FFriendInfo> Friends;
        FGetFriendsListResult() :
            FPlayFabBaseModel(),
            Friends()
            {}

        FGetFriendsListResult(const FGetFriendsListResult& src) :
            FPlayFabBaseModel(),
            Friends(src.Friends)
            {}

        FGetFriendsListResult(const TSharedPtr<FJsonObject>& obj) : FGetFriendsListResult()
        {
            readFromValue(obj);
        }

        ~FGetFriendsListResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetLeaderboardAroundCharacterRequest : public FPlayFabBaseModel
    {
        // Unique PlayFab assigned ID for a specific character owned by a user
        FString CharacterId;

        // [optional] Optional character type on which to filter the leaderboard entries.
        FString CharacterType;

        // Maximum number of entries to retrieve.
        int32 MaxResultsCount;

        // Unique PlayFab assigned ID of the user on whom the operation will be performed.
        FString PlayFabId;

        // Unique identifier for the title-specific statistic for the leaderboard.
        FString StatisticName;

        FGetLeaderboardAroundCharacterRequest() :
            FPlayFabBaseModel(),
            CharacterId(),
            CharacterType(),
            MaxResultsCount(0),
            PlayFabId(),
            StatisticName()
            {}

        FGetLeaderboardAroundCharacterRequest(const FGetLeaderboardAroundCharacterRequest& src) :
            FPlayFabBaseModel(),
            CharacterId(src.CharacterId),
            CharacterType(src.CharacterType),
            MaxResultsCount(src.MaxResultsCount),
            PlayFabId(src.PlayFabId),
            StatisticName(src.StatisticName)
            {}

        FGetLeaderboardAroundCharacterRequest(const TSharedPtr<FJsonObject>& obj) : FGetLeaderboardAroundCharacterRequest()
        {
            readFromValue(obj);
        }

        ~FGetLeaderboardAroundCharacterRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetLeaderboardAroundCharacterResult : public FPlayFabBaseModel
    {
        // [optional] Ordered list of leaderboard entries.
        TArray<FCharacterLeaderboardEntry> Leaderboard;
        FGetLeaderboardAroundCharacterResult() :
            FPlayFabBaseModel(),
            Leaderboard()
            {}

        FGetLeaderboardAroundCharacterResult(const FGetLeaderboardAroundCharacterResult& src) :
            FPlayFabBaseModel(),
            Leaderboard(src.Leaderboard)
            {}

        FGetLeaderboardAroundCharacterResult(const TSharedPtr<FJsonObject>& obj) : FGetLeaderboardAroundCharacterResult()
        {
            readFromValue(obj);
        }

        ~FGetLeaderboardAroundCharacterResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetLeaderboardAroundUserRequest : public FPlayFabBaseModel
    {
        // Maximum number of entries to retrieve.
        int32 MaxResultsCount;

        // Unique PlayFab assigned ID of the user on whom the operation will be performed.
        FString PlayFabId;

        /**
         * [optional] If non-null, this determines which properties of the resulting player profiles to return. For API calls from the client,
         * only the allowed client profile properties for the title may be requested. These allowed properties are configured in
         * the Game Manager "Client Profile Options" tab in the "Settings" section.
         */
        TSharedPtr<FPlayerProfileViewConstraints> ProfileConstraints;

        // Unique identifier for the title-specific statistic for the leaderboard.
        FString StatisticName;

        // [optional] If set to false, Version is considered null. If true, uses the specified Version
        Boxed<bool> UseSpecificVersion;

        // [optional] The version of the leaderboard to get.
        Boxed<int32> Version;

        FGetLeaderboardAroundUserRequest() :
            FPlayFabBaseModel(),
            MaxResultsCount(0),
            PlayFabId(),
            ProfileConstraints(nullptr),
            StatisticName(),
            UseSpecificVersion(),
            Version()
            {}

        FGetLeaderboardAroundUserRequest(const FGetLeaderboardAroundUserRequest& src) :
            FPlayFabBaseModel(),
            MaxResultsCount(src.MaxResultsCount),
            PlayFabId(src.PlayFabId),
            ProfileConstraints(src.ProfileConstraints.IsValid() ? MakeShareable(new FPlayerProfileViewConstraints(*src.ProfileConstraints)) : nullptr),
            StatisticName(src.StatisticName),
            UseSpecificVersion(src.UseSpecificVersion),
            Version(src.Version)
            {}

        FGetLeaderboardAroundUserRequest(const TSharedPtr<FJsonObject>& obj) : FGetLeaderboardAroundUserRequest()
        {
            readFromValue(obj);
        }

        ~FGetLeaderboardAroundUserRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FPlayerLeaderboardEntry : public FPlayFabBaseModel
    {
        // [optional] Title-specific display name of the user for this leaderboard entry.
        FString DisplayName;

        // [optional] PlayFab unique identifier of the user for this leaderboard entry.
        FString PlayFabId;

        // User's overall position in the leaderboard.
        int32 Position;

        // [optional] The profile of the user, if requested.
        TSharedPtr<FPlayerProfileModel> Profile;

        // Specific value of the user's statistic.
        int32 StatValue;

        FPlayerLeaderboardEntry() :
            FPlayFabBaseModel(),
            DisplayName(),
            PlayFabId(),
            Position(0),
            Profile(nullptr),
            StatValue(0)
            {}

        FPlayerLeaderboardEntry(const FPlayerLeaderboardEntry& src) :
            FPlayFabBaseModel(),
            DisplayName(src.DisplayName),
            PlayFabId(src.PlayFabId),
            Position(src.Position),
            Profile(src.Profile.IsValid() ? MakeShareable(new FPlayerProfileModel(*src.Profile)) : nullptr),
            StatValue(src.StatValue)
            {}

        FPlayerLeaderboardEntry(const TSharedPtr<FJsonObject>& obj) : FPlayerLeaderboardEntry()
        {
            readFromValue(obj);
        }

        ~FPlayerLeaderboardEntry();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetLeaderboardAroundUserResult : public FPlayFabBaseModel
    {
        // [optional] Ordered listing of users and their positions in the requested leaderboard.
        TArray<FPlayerLeaderboardEntry> Leaderboard;
        // [optional] The time the next scheduled reset will occur. Null if the leaderboard does not reset on a schedule.
        Boxed<FDateTime> NextReset;

        // The version of the leaderboard returned.
        int32 Version;

        FGetLeaderboardAroundUserResult() :
            FPlayFabBaseModel(),
            Leaderboard(),
            NextReset(),
            Version(0)
            {}

        FGetLeaderboardAroundUserResult(const FGetLeaderboardAroundUserResult& src) :
            FPlayFabBaseModel(),
            Leaderboard(src.Leaderboard),
            NextReset(src.NextReset),
            Version(src.Version)
            {}

        FGetLeaderboardAroundUserResult(const TSharedPtr<FJsonObject>& obj) : FGetLeaderboardAroundUserResult()
        {
            readFromValue(obj);
        }

        ~FGetLeaderboardAroundUserResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetLeaderboardForUsersCharactersRequest : public FPlayFabBaseModel
    {
        // Maximum number of entries to retrieve.
        int32 MaxResultsCount;

        // Unique PlayFab assigned ID of the user on whom the operation will be performed.
        FString PlayFabId;

        // Unique identifier for the title-specific statistic for the leaderboard.
        FString StatisticName;

        FGetLeaderboardForUsersCharactersRequest() :
            FPlayFabBaseModel(),
            MaxResultsCount(0),
            PlayFabId(),
            StatisticName()
            {}

        FGetLeaderboardForUsersCharactersRequest(const FGetLeaderboardForUsersCharactersRequest& src) :
            FPlayFabBaseModel(),
            MaxResultsCount(src.MaxResultsCount),
            PlayFabId(src.PlayFabId),
            StatisticName(src.StatisticName)
            {}

        FGetLeaderboardForUsersCharactersRequest(const TSharedPtr<FJsonObject>& obj) : FGetLeaderboardForUsersCharactersRequest()
        {
            readFromValue(obj);
        }

        ~FGetLeaderboardForUsersCharactersRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetLeaderboardForUsersCharactersResult : public FPlayFabBaseModel
    {
        // [optional] Ordered list of leaderboard entries.
        TArray<FCharacterLeaderboardEntry> Leaderboard;
        FGetLeaderboardForUsersCharactersResult() :
            FPlayFabBaseModel(),
            Leaderboard()
            {}

        FGetLeaderboardForUsersCharactersResult(const FGetLeaderboardForUsersCharactersResult& src) :
            FPlayFabBaseModel(),
            Leaderboard(src.Leaderboard)
            {}

        FGetLeaderboardForUsersCharactersResult(const TSharedPtr<FJsonObject>& obj) : FGetLeaderboardForUsersCharactersResult()
        {
            readFromValue(obj);
        }

        ~FGetLeaderboardForUsersCharactersResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetLeaderboardRequest : public FPlayFabBaseModel
    {
        // Maximum number of entries to retrieve.
        int32 MaxResultsCount;

        /**
         * [optional] If non-null, this determines which properties of the resulting player profiles to return. For API calls from the client,
         * only the allowed client profile properties for the title may be requested. These allowed properties are configured in
         * the Game Manager "Client Profile Options" tab in the "Settings" section.
         */
        TSharedPtr<FPlayerProfileViewConstraints> ProfileConstraints;

        // First entry in the leaderboard to be retrieved.
        int32 StartPosition;

        // Unique identifier for the title-specific statistic for the leaderboard.
        FString StatisticName;

        // [optional] If set to false, Version is considered null. If true, uses the specified Version
        Boxed<bool> UseSpecificVersion;

        // [optional] The version of the leaderboard to get.
        Boxed<int32> Version;

        FGetLeaderboardRequest() :
            FPlayFabBaseModel(),
            MaxResultsCount(0),
            ProfileConstraints(nullptr),
            StartPosition(0),
            StatisticName(),
            UseSpecificVersion(),
            Version()
            {}

        FGetLeaderboardRequest(const FGetLeaderboardRequest& src) :
            FPlayFabBaseModel(),
            MaxResultsCount(src.MaxResultsCount),
            ProfileConstraints(src.ProfileConstraints.IsValid() ? MakeShareable(new FPlayerProfileViewConstraints(*src.ProfileConstraints)) : nullptr),
            StartPosition(src.StartPosition),
            StatisticName(src.StatisticName),
            UseSpecificVersion(src.UseSpecificVersion),
            Version(src.Version)
            {}

        FGetLeaderboardRequest(const TSharedPtr<FJsonObject>& obj) : FGetLeaderboardRequest()
        {
            readFromValue(obj);
        }

        ~FGetLeaderboardRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetLeaderboardResult : public FPlayFabBaseModel
    {
        // [optional] Ordered listing of users and their positions in the requested leaderboard.
        TArray<FPlayerLeaderboardEntry> Leaderboard;
        // [optional] The time the next scheduled reset will occur. Null if the leaderboard does not reset on a schedule.
        Boxed<FDateTime> NextReset;

        // The version of the leaderboard returned.
        int32 Version;

        FGetLeaderboardResult() :
            FPlayFabBaseModel(),
            Leaderboard(),
            NextReset(),
            Version(0)
            {}

        FGetLeaderboardResult(const FGetLeaderboardResult& src) :
            FPlayFabBaseModel(),
            Leaderboard(src.Leaderboard),
            NextReset(src.NextReset),
            Version(src.Version)
            {}

        FGetLeaderboardResult(const TSharedPtr<FJsonObject>& obj) : FGetLeaderboardResult()
        {
            readFromValue(obj);
        }

        ~FGetLeaderboardResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetPlayerCombinedInfoRequestParams : public FPlayFabBaseModel
    {
        // Whether to get character inventories. Defaults to false.
        bool GetCharacterInventories;

        // Whether to get the list of characters. Defaults to false.
        bool GetCharacterList;

        // Whether to get player profile. Defaults to false.
        bool GetPlayerProfile;

        // Whether to get player statistics. Defaults to false.
        bool GetPlayerStatistics;

        // Whether to get title data. Defaults to false.
        bool GetTitleData;

        // Whether to get the player's account Info. Defaults to false
        bool GetUserAccountInfo;

        // Whether to get the player's custom data. Defaults to false
        bool GetUserData;

        // Whether to get the player's inventory. Defaults to false
        bool GetUserInventory;

        // Whether to get the player's read only data. Defaults to false
        bool GetUserReadOnlyData;

        // Whether to get the player's virtual currency balances. Defaults to false
        bool GetUserVirtualCurrency;

        // [optional] Specific statistics to retrieve. Leave null to get all keys. Has no effect if GetPlayerStatistics is false
        TArray<FString> PlayerStatisticNames;
        // [optional] Specifies the properties to return from the player profile. Defaults to returning the player's display name.
        TSharedPtr<FPlayerProfileViewConstraints> ProfileConstraints;

        // [optional] Specific keys to search for in the custom data. Leave null to get all keys. Has no effect if GetTitleData is false
        TArray<FString> TitleDataKeys;
        // [optional] Specific keys to search for in the custom data. Leave null to get all keys. Has no effect if GetUserData is false
        TArray<FString> UserDataKeys;
        /**
         * [optional] Specific keys to search for in the custom data. Leave null to get all keys. Has no effect if GetUserReadOnlyData is
         * false
         */
        TArray<FString> UserReadOnlyDataKeys;
        FGetPlayerCombinedInfoRequestParams() :
            FPlayFabBaseModel(),
            GetCharacterInventories(false),
            GetCharacterList(false),
            GetPlayerProfile(false),
            GetPlayerStatistics(false),
            GetTitleData(false),
            GetUserAccountInfo(false),
            GetUserData(false),
            GetUserInventory(false),
            GetUserReadOnlyData(false),
            GetUserVirtualCurrency(false),
            PlayerStatisticNames(),
            ProfileConstraints(nullptr),
            TitleDataKeys(),
            UserDataKeys(),
            UserReadOnlyDataKeys()
            {}

        FGetPlayerCombinedInfoRequestParams(const FGetPlayerCombinedInfoRequestParams& src) :
            FPlayFabBaseModel(),
            GetCharacterInventories(src.GetCharacterInventories),
            GetCharacterList(src.GetCharacterList),
            GetPlayerProfile(src.GetPlayerProfile),
            GetPlayerStatistics(src.GetPlayerStatistics),
            GetTitleData(src.GetTitleData),
            GetUserAccountInfo(src.GetUserAccountInfo),
            GetUserData(src.GetUserData),
            GetUserInventory(src.GetUserInventory),
            GetUserReadOnlyData(src.GetUserReadOnlyData),
            GetUserVirtualCurrency(src.GetUserVirtualCurrency),
            PlayerStatisticNames(src.PlayerStatisticNames),
            ProfileConstraints(src.ProfileConstraints.IsValid() ? MakeShareable(new FPlayerProfileViewConstraints(*src.ProfileConstraints)) : nullptr),
            TitleDataKeys(src.TitleDataKeys),
            UserDataKeys(src.UserDataKeys),
            UserReadOnlyDataKeys(src.UserReadOnlyDataKeys)
            {}

        FGetPlayerCombinedInfoRequestParams(const TSharedPtr<FJsonObject>& obj) : FGetPlayerCombinedInfoRequestParams()
        {
            readFromValue(obj);
        }

        ~FGetPlayerCombinedInfoRequestParams();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetPlayerCombinedInfoRequest : public FPlayFabBaseModel
    {
        // Flags for which pieces of info to return for the user.
        FGetPlayerCombinedInfoRequestParams InfoRequestParameters;

        // PlayFabId of the user whose data will be returned
        FString PlayFabId;

        FGetPlayerCombinedInfoRequest() :
            FPlayFabBaseModel(),
            InfoRequestParameters(),
            PlayFabId()
            {}

        FGetPlayerCombinedInfoRequest(const FGetPlayerCombinedInfoRequest& src) :
            FPlayFabBaseModel(),
            InfoRequestParameters(src.InfoRequestParameters),
            PlayFabId(src.PlayFabId)
            {}

        FGetPlayerCombinedInfoRequest(const TSharedPtr<FJsonObject>& obj) : FGetPlayerCombinedInfoRequest()
        {
            readFromValue(obj);
        }

        ~FGetPlayerCombinedInfoRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FStatisticValue : public FPlayFabBaseModel
    {
        // [optional] unique name of the statistic
        FString StatisticName;

        // statistic value for the player
        int32 Value;

        // for updates to an existing statistic value for a player, the version of the statistic when it was loaded
        uint32 Version;

        FStatisticValue() :
            FPlayFabBaseModel(),
            StatisticName(),
            Value(0),
            Version(0)
            {}

        FStatisticValue(const FStatisticValue& src) :
            FPlayFabBaseModel(),
            StatisticName(src.StatisticName),
            Value(src.Value),
            Version(src.Version)
            {}

        FStatisticValue(const TSharedPtr<FJsonObject>& obj) : FStatisticValue()
        {
            readFromValue(obj);
        }

        ~FStatisticValue();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetPlayerCombinedInfoResultPayload : public FPlayFabBaseModel
    {
        // [optional] Account information for the user. This is always retrieved.
        TSharedPtr<FUserAccountInfo> AccountInfo;

        // [optional] Inventories for each character for the user.
        TArray<FCharacterInventory> CharacterInventories;
        // [optional] List of characters for the user.
        TArray<FCharacterResult> CharacterList;
        /**
         * [optional] The profile of the players. This profile is not guaranteed to be up-to-date. For a new player, this profile will not
         * exist.
         */
        TSharedPtr<FPlayerProfileModel> PlayerProfile;

        // [optional] List of statistics for this player.
        TArray<FStatisticValue> PlayerStatistics;
        // [optional] Title data for this title.
        TMap<FString, FString> TitleData;
        // [optional] User specific custom data.
        TMap<FString, FUserDataRecord> UserData;
        // The version of the UserData that was returned.
        uint32 UserDataVersion;

        // [optional] Array of inventory items in the user's current inventory.
        TArray<FItemInstance> UserInventory;
        // [optional] User specific read-only data.
        TMap<FString, FUserDataRecord> UserReadOnlyData;
        // The version of the Read-Only UserData that was returned.
        uint32 UserReadOnlyDataVersion;

        // [optional] Dictionary of virtual currency balance(s) belonging to the user.
        TMap<FString, int32> UserVirtualCurrency;
        // [optional] Dictionary of remaining times and timestamps for virtual currencies.
        TMap<FString, FVirtualCurrencyRechargeTime> UserVirtualCurrencyRechargeTimes;
        FGetPlayerCombinedInfoResultPayload() :
            FPlayFabBaseModel(),
            AccountInfo(nullptr),
            CharacterInventories(),
            CharacterList(),
            PlayerProfile(nullptr),
            PlayerStatistics(),
            TitleData(),
            UserData(),
            UserDataVersion(0),
            UserInventory(),
            UserReadOnlyData(),
            UserReadOnlyDataVersion(0),
            UserVirtualCurrency(),
            UserVirtualCurrencyRechargeTimes()
            {}

        FGetPlayerCombinedInfoResultPayload(const FGetPlayerCombinedInfoResultPayload& src) :
            FPlayFabBaseModel(),
            AccountInfo(src.AccountInfo.IsValid() ? MakeShareable(new FUserAccountInfo(*src.AccountInfo)) : nullptr),
            CharacterInventories(src.CharacterInventories),
            CharacterList(src.CharacterList),
            PlayerProfile(src.PlayerProfile.IsValid() ? MakeShareable(new FPlayerProfileModel(*src.PlayerProfile)) : nullptr),
            PlayerStatistics(src.PlayerStatistics),
            TitleData(src.TitleData),
            UserData(src.UserData),
            UserDataVersion(src.UserDataVersion),
            UserInventory(src.UserInventory),
            UserReadOnlyData(src.UserReadOnlyData),
            UserReadOnlyDataVersion(src.UserReadOnlyDataVersion),
            UserVirtualCurrency(src.UserVirtualCurrency),
            UserVirtualCurrencyRechargeTimes(src.UserVirtualCurrencyRechargeTimes)
            {}

        FGetPlayerCombinedInfoResultPayload(const TSharedPtr<FJsonObject>& obj) : FGetPlayerCombinedInfoResultPayload()
        {
            readFromValue(obj);
        }

        ~FGetPlayerCombinedInfoResultPayload();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetPlayerCombinedInfoResult : public FPlayFabBaseModel
    {
        // [optional] Results for requested info.
        TSharedPtr<FGetPlayerCombinedInfoResultPayload> InfoResultPayload;

        // [optional] Unique PlayFab assigned ID of the user on whom the operation will be performed.
        FString PlayFabId;

        FGetPlayerCombinedInfoResult() :
            FPlayFabBaseModel(),
            InfoResultPayload(nullptr),
            PlayFabId()
            {}

        FGetPlayerCombinedInfoResult(const FGetPlayerCombinedInfoResult& src) :
            FPlayFabBaseModel(),
            InfoResultPayload(src.InfoResultPayload.IsValid() ? MakeShareable(new FGetPlayerCombinedInfoResultPayload(*src.InfoResultPayload)) : nullptr),
            PlayFabId(src.PlayFabId)
            {}

        FGetPlayerCombinedInfoResult(const TSharedPtr<FJsonObject>& obj) : FGetPlayerCombinedInfoResult()
        {
            readFromValue(obj);
        }

        ~FGetPlayerCombinedInfoResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetPlayerProfileRequest : public FPlayFabBaseModel
    {
        // Unique PlayFab assigned ID of the user on whom the operation will be performed.
        FString PlayFabId;

        /**
         * [optional] If non-null, this determines which properties of the resulting player profiles to return. For API calls from the client,
         * only the allowed client profile properties for the title may be requested. These allowed properties are configured in
         * the Game Manager "Client Profile Options" tab in the "Settings" section.
         */
        TSharedPtr<FPlayerProfileViewConstraints> ProfileConstraints;

        FGetPlayerProfileRequest() :
            FPlayFabBaseModel(),
            PlayFabId(),
            ProfileConstraints(nullptr)
            {}

        FGetPlayerProfileRequest(const FGetPlayerProfileRequest& src) :
            FPlayFabBaseModel(),
            PlayFabId(src.PlayFabId),
            ProfileConstraints(src.ProfileConstraints.IsValid() ? MakeShareable(new FPlayerProfileViewConstraints(*src.ProfileConstraints)) : nullptr)
            {}

        FGetPlayerProfileRequest(const TSharedPtr<FJsonObject>& obj) : FGetPlayerProfileRequest()
        {
            readFromValue(obj);
        }

        ~FGetPlayerProfileRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetPlayerProfileResult : public FPlayFabBaseModel
    {
        /**
         * [optional] The profile of the player. This profile is not guaranteed to be up-to-date. For a new player, this profile will not
         * exist.
         */
        TSharedPtr<FPlayerProfileModel> PlayerProfile;

        FGetPlayerProfileResult() :
            FPlayFabBaseModel(),
            PlayerProfile(nullptr)
            {}

        FGetPlayerProfileResult(const FGetPlayerProfileResult& src) :
            FPlayFabBaseModel(),
            PlayerProfile(src.PlayerProfile.IsValid() ? MakeShareable(new FPlayerProfileModel(*src.PlayerProfile)) : nullptr)
            {}

        FGetPlayerProfileResult(const TSharedPtr<FJsonObject>& obj) : FGetPlayerProfileResult()
        {
            readFromValue(obj);
        }

        ~FGetPlayerProfileResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetPlayerSegmentsResult : public FPlayFabBaseModel
    {
        // [optional] Array of segments the requested player currently belongs to.
        TArray<FGetSegmentResult> Segments;
        FGetPlayerSegmentsResult() :
            FPlayFabBaseModel(),
            Segments()
            {}

        FGetPlayerSegmentsResult(const FGetPlayerSegmentsResult& src) :
            FPlayFabBaseModel(),
            Segments(src.Segments)
            {}

        FGetPlayerSegmentsResult(const TSharedPtr<FJsonObject>& obj) : FGetPlayerSegmentsResult()
        {
            readFromValue(obj);
        }

        ~FGetPlayerSegmentsResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetPlayersInSegmentRequest : public FPlayFabBaseModel
    {
        // [optional] Continuation token if retrieving subsequent pages of results.
        FString ContinuationToken;

        // [optional] Maximum number of profiles to load. Default is 1,000. Maximum is 10,000.
        Boxed<uint32> MaxBatchSize;

        /**
         * [optional] Number of seconds to keep the continuation token active. After token expiration it is not possible to continue paging
         * results. Default is 300 (5 minutes). Maximum is 1,800 (30 minutes).
         */
        Boxed<uint32> SecondsToLive;

        // Unique identifier for this segment.
        FString SegmentId;

        FGetPlayersInSegmentRequest() :
            FPlayFabBaseModel(),
            ContinuationToken(),
            MaxBatchSize(),
            SecondsToLive(),
            SegmentId()
            {}

        FGetPlayersInSegmentRequest(const FGetPlayersInSegmentRequest& src) :
            FPlayFabBaseModel(),
            ContinuationToken(src.ContinuationToken),
            MaxBatchSize(src.MaxBatchSize),
            SecondsToLive(src.SecondsToLive),
            SegmentId(src.SegmentId)
            {}

        FGetPlayersInSegmentRequest(const TSharedPtr<FJsonObject>& obj) : FGetPlayersInSegmentRequest()
        {
            readFromValue(obj);
        }

        ~FGetPlayersInSegmentRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FPlayerLinkedAccount : public FPlayFabBaseModel
    {
        // [optional] Linked account's email
        FString Email;

        // [optional] Authentication platform
        Boxed<LoginIdentityProvider> Platform;

        // [optional] Platform user identifier
        FString PlatformUserId;

        // [optional] Linked account's username
        FString Username;

        FPlayerLinkedAccount() :
            FPlayFabBaseModel(),
            Email(),
            Platform(),
            PlatformUserId(),
            Username()
            {}

        FPlayerLinkedAccount(const FPlayerLinkedAccount& src) :
            FPlayFabBaseModel(),
            Email(src.Email),
            Platform(src.Platform),
            PlatformUserId(src.PlatformUserId),
            Username(src.Username)
            {}

        FPlayerLinkedAccount(const TSharedPtr<FJsonObject>& obj) : FPlayerLinkedAccount()
        {
            readFromValue(obj);
        }

        ~FPlayerLinkedAccount();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FPlayerLocation : public FPlayFabBaseModel
    {
        // [optional] City of the player's geographic location.
        FString City;

        // The two-character continent code for this location
        ContinentCode pfContinentCode;

        // The two-character ISO 3166-1 country code for the country associated with the location
        CountryCode pfCountryCode;

        // [optional] Latitude coordinate of the player's geographic location.
        Boxed<double> Latitude;

        // [optional] Longitude coordinate of the player's geographic location.
        Boxed<double> Longitude;

        FPlayerLocation() :
            FPlayFabBaseModel(),
            City(),
            pfContinentCode(),
            pfCountryCode(),
            Latitude(),
            Longitude()
            {}

        FPlayerLocation(const FPlayerLocation& src) :
            FPlayFabBaseModel(),
            City(src.City),
            pfContinentCode(src.pfContinentCode),
            pfCountryCode(src.pfCountryCode),
            Latitude(src.Latitude),
            Longitude(src.Longitude)
            {}

        FPlayerLocation(const TSharedPtr<FJsonObject>& obj) : FPlayerLocation()
        {
            readFromValue(obj);
        }

        ~FPlayerLocation();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FPlayerStatistic : public FPlayFabBaseModel
    {
        // [optional] Statistic ID
        FString Id;

        // [optional] Statistic name
        FString Name;

        // Current statistic value
        int32 StatisticValue;

        // Statistic version (0 if not a versioned statistic)
        int32 StatisticVersion;

        FPlayerStatistic() :
            FPlayFabBaseModel(),
            Id(),
            Name(),
            StatisticValue(0),
            StatisticVersion(0)
            {}

        FPlayerStatistic(const FPlayerStatistic& src) :
            FPlayFabBaseModel(),
            Id(src.Id),
            Name(src.Name),
            StatisticValue(src.StatisticValue),
            StatisticVersion(src.StatisticVersion)
            {}

        FPlayerStatistic(const TSharedPtr<FJsonObject>& obj) : FPlayerStatistic()
        {
            readFromValue(obj);
        }

        ~FPlayerStatistic();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FPushNotificationRegistration : public FPlayFabBaseModel
    {
        // [optional] Notification configured endpoint
        FString NotificationEndpointARN;

        // [optional] Push notification platform
        Boxed<PushNotificationPlatform> Platform;

        FPushNotificationRegistration() :
            FPlayFabBaseModel(),
            NotificationEndpointARN(),
            Platform()
            {}

        FPushNotificationRegistration(const FPushNotificationRegistration& src) :
            FPlayFabBaseModel(),
            NotificationEndpointARN(src.NotificationEndpointARN),
            Platform(src.Platform)
            {}

        FPushNotificationRegistration(const TSharedPtr<FJsonObject>& obj) : FPushNotificationRegistration()
        {
            readFromValue(obj);
        }

        ~FPushNotificationRegistration();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FPlayerProfile : public FPlayFabBaseModel
    {
        // [optional] Array of ad campaigns player has been attributed to
        TArray<FAdCampaignAttribution> AdCampaignAttributions;
        // [optional] Image URL of the player's avatar.
        FString AvatarUrl;

        // [optional] Banned until UTC Date. If permanent ban this is set for 20 years after the original ban date.
        Boxed<FDateTime> BannedUntil;

        // [optional] Array of contact email addresses associated with the player
        TArray<FContactEmailInfo> ContactEmailAddresses;
        // [optional] Player record created
        Boxed<FDateTime> Created;

        // [optional] Player Display Name
        FString DisplayName;

        // [optional] Last login
        Boxed<FDateTime> LastLogin;

        // [optional] Array of third party accounts linked to this player
        TArray<FPlayerLinkedAccount> LinkedAccounts;
        // [optional] Dictionary of player's locations by type.
        TMap<FString, FPlayerLocation> Locations;
        // [optional] Player account origination
        Boxed<LoginIdentityProvider> Origination;

        // [optional] PlayFab Player ID
        FString PlayerId;

        // [optional] Array of player statistics
        TArray<FPlayerStatistic> PlayerStatistics;
        // [optional] Publisher this player belongs to
        FString PublisherId;

        // [optional] Array of configured push notification end points
        TArray<FPushNotificationRegistration> PushNotificationRegistrations;
        // [optional] Dictionary of player's statistics using only the latest version's value
        TMap<FString, int32> Statistics;
        // [optional] List of player's tags for segmentation.
        TArray<FString> Tags;
        // [optional] Title ID this profile applies to
        FString TitleId;

        // [optional] A sum of player's total purchases in USD across all currencies.
        Boxed<uint32> TotalValueToDateInUSD;

        // [optional] Dictionary of player's total purchases by currency.
        TMap<FString, uint32> ValuesToDate;
        // [optional] Dictionary of player's virtual currency balances
        TMap<FString, int32> VirtualCurrencyBalances;
        FPlayerProfile() :
            FPlayFabBaseModel(),
            AdCampaignAttributions(),
            AvatarUrl(),
            BannedUntil(),
            ContactEmailAddresses(),
            Created(),
            DisplayName(),
            LastLogin(),
            LinkedAccounts(),
            Locations(),
            Origination(),
            PlayerId(),
            PlayerStatistics(),
            PublisherId(),
            PushNotificationRegistrations(),
            Statistics(),
            Tags(),
            TitleId(),
            TotalValueToDateInUSD(),
            ValuesToDate(),
            VirtualCurrencyBalances()
            {}

        FPlayerProfile(const FPlayerProfile& src) :
            FPlayFabBaseModel(),
            AdCampaignAttributions(src.AdCampaignAttributions),
            AvatarUrl(src.AvatarUrl),
            BannedUntil(src.BannedUntil),
            ContactEmailAddresses(src.ContactEmailAddresses),
            Created(src.Created),
            DisplayName(src.DisplayName),
            LastLogin(src.LastLogin),
            LinkedAccounts(src.LinkedAccounts),
            Locations(src.Locations),
            Origination(src.Origination),
            PlayerId(src.PlayerId),
            PlayerStatistics(src.PlayerStatistics),
            PublisherId(src.PublisherId),
            PushNotificationRegistrations(src.PushNotificationRegistrations),
            Statistics(src.Statistics),
            Tags(src.Tags),
            TitleId(src.TitleId),
            TotalValueToDateInUSD(src.TotalValueToDateInUSD),
            ValuesToDate(src.ValuesToDate),
            VirtualCurrencyBalances(src.VirtualCurrencyBalances)
            {}

        FPlayerProfile(const TSharedPtr<FJsonObject>& obj) : FPlayerProfile()
        {
            readFromValue(obj);
        }

        ~FPlayerProfile();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetPlayersInSegmentResult : public FPlayFabBaseModel
    {
        // [optional] Continuation token to use to retrieve subsequent pages of results. If token returns null there are no more results.
        FString ContinuationToken;

        // [optional] Array of player profiles in this segment.
        TArray<FPlayerProfile> PlayerProfiles;
        // Count of profiles matching this segment.
        int32 ProfilesInSegment;

        FGetPlayersInSegmentResult() :
            FPlayFabBaseModel(),
            ContinuationToken(),
            PlayerProfiles(),
            ProfilesInSegment(0)
            {}

        FGetPlayersInSegmentResult(const FGetPlayersInSegmentResult& src) :
            FPlayFabBaseModel(),
            ContinuationToken(src.ContinuationToken),
            PlayerProfiles(src.PlayerProfiles),
            ProfilesInSegment(src.ProfilesInSegment)
            {}

        FGetPlayersInSegmentResult(const TSharedPtr<FJsonObject>& obj) : FGetPlayersInSegmentResult()
        {
            readFromValue(obj);
        }

        ~FGetPlayersInSegmentResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetPlayersSegmentsRequest : public FPlayFabBaseModel
    {
        // Unique PlayFab assigned ID of the user on whom the operation will be performed.
        FString PlayFabId;

        FGetPlayersSegmentsRequest() :
            FPlayFabBaseModel(),
            PlayFabId()
            {}

        FGetPlayersSegmentsRequest(const FGetPlayersSegmentsRequest& src) :
            FPlayFabBaseModel(),
            PlayFabId(src.PlayFabId)
            {}

        FGetPlayersSegmentsRequest(const TSharedPtr<FJsonObject>& obj) : FGetPlayersSegmentsRequest()
        {
            readFromValue(obj);
        }

        ~FGetPlayersSegmentsRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FStatisticNameVersion : public FPlayFabBaseModel
    {
        // unique name of the statistic
        FString StatisticName;

        // the version of the statistic to be returned
        uint32 Version;

        FStatisticNameVersion() :
            FPlayFabBaseModel(),
            StatisticName(),
            Version(0)
            {}

        FStatisticNameVersion(const FStatisticNameVersion& src) :
            FPlayFabBaseModel(),
            StatisticName(src.StatisticName),
            Version(src.Version)
            {}

        FStatisticNameVersion(const TSharedPtr<FJsonObject>& obj) : FStatisticNameVersion()
        {
            readFromValue(obj);
        }

        ~FStatisticNameVersion();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetPlayerStatisticsRequest : public FPlayFabBaseModel
    {
        // user for whom statistics are being requested
        FString PlayFabId;

        // [optional] statistics to return
        TArray<FString> StatisticNames;
        /**
         * [optional] statistics to return, if StatisticNames is not set (only statistics which have a version matching that provided will be
         * returned)
         */
        TArray<FStatisticNameVersion> StatisticNameVersions;
        FGetPlayerStatisticsRequest() :
            FPlayFabBaseModel(),
            PlayFabId(),
            StatisticNames(),
            StatisticNameVersions()
            {}

        FGetPlayerStatisticsRequest(const FGetPlayerStatisticsRequest& src) :
            FPlayFabBaseModel(),
            PlayFabId(src.PlayFabId),
            StatisticNames(src.StatisticNames),
            StatisticNameVersions(src.StatisticNameVersions)
            {}

        FGetPlayerStatisticsRequest(const TSharedPtr<FJsonObject>& obj) : FGetPlayerStatisticsRequest()
        {
            readFromValue(obj);
        }

        ~FGetPlayerStatisticsRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetPlayerStatisticsResult : public FPlayFabBaseModel
    {
        // [optional] PlayFab unique identifier of the user whose statistics are being returned
        FString PlayFabId;

        // [optional] User statistics for the requested user.
        TArray<FStatisticValue> Statistics;
        FGetPlayerStatisticsResult() :
            FPlayFabBaseModel(),
            PlayFabId(),
            Statistics()
            {}

        FGetPlayerStatisticsResult(const FGetPlayerStatisticsResult& src) :
            FPlayFabBaseModel(),
            PlayFabId(src.PlayFabId),
            Statistics(src.Statistics)
            {}

        FGetPlayerStatisticsResult(const TSharedPtr<FJsonObject>& obj) : FGetPlayerStatisticsResult()
        {
            readFromValue(obj);
        }

        ~FGetPlayerStatisticsResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetPlayerStatisticVersionsRequest : public FPlayFabBaseModel
    {
        // [optional] unique name of the statistic
        FString StatisticName;

        FGetPlayerStatisticVersionsRequest() :
            FPlayFabBaseModel(),
            StatisticName()
            {}

        FGetPlayerStatisticVersionsRequest(const FGetPlayerStatisticVersionsRequest& src) :
            FPlayFabBaseModel(),
            StatisticName(src.StatisticName)
            {}

        FGetPlayerStatisticVersionsRequest(const TSharedPtr<FJsonObject>& obj) : FGetPlayerStatisticVersionsRequest()
        {
            readFromValue(obj);
        }

        ~FGetPlayerStatisticVersionsRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FPlayerStatisticVersion : public FPlayFabBaseModel
    {
        // time when the statistic version became active
        FDateTime ActivationTime;

        // [optional] time when the statistic version became inactive due to statistic version incrementing
        Boxed<FDateTime> DeactivationTime;

        // [optional] time at which the statistic version was scheduled to become active, based on the configured ResetInterval
        Boxed<FDateTime> ScheduledActivationTime;

        // [optional] time at which the statistic version was scheduled to become inactive, based on the configured ResetInterval
        Boxed<FDateTime> ScheduledDeactivationTime;

        // [optional] name of the statistic when the version became active
        FString StatisticName;

        // version of the statistic
        uint32 Version;

        FPlayerStatisticVersion() :
            FPlayFabBaseModel(),
            ActivationTime(0),
            DeactivationTime(),
            ScheduledActivationTime(),
            ScheduledDeactivationTime(),
            StatisticName(),
            Version(0)
            {}

        FPlayerStatisticVersion(const FPlayerStatisticVersion& src) :
            FPlayFabBaseModel(),
            ActivationTime(src.ActivationTime),
            DeactivationTime(src.DeactivationTime),
            ScheduledActivationTime(src.ScheduledActivationTime),
            ScheduledDeactivationTime(src.ScheduledDeactivationTime),
            StatisticName(src.StatisticName),
            Version(src.Version)
            {}

        FPlayerStatisticVersion(const TSharedPtr<FJsonObject>& obj) : FPlayerStatisticVersion()
        {
            readFromValue(obj);
        }

        ~FPlayerStatisticVersion();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetPlayerStatisticVersionsResult : public FPlayFabBaseModel
    {
        // [optional] version change history of the statistic
        TArray<FPlayerStatisticVersion> StatisticVersions;
        FGetPlayerStatisticVersionsResult() :
            FPlayFabBaseModel(),
            StatisticVersions()
            {}

        FGetPlayerStatisticVersionsResult(const FGetPlayerStatisticVersionsResult& src) :
            FPlayFabBaseModel(),
            StatisticVersions(src.StatisticVersions)
            {}

        FGetPlayerStatisticVersionsResult(const TSharedPtr<FJsonObject>& obj) : FGetPlayerStatisticVersionsResult()
        {
            readFromValue(obj);
        }

        ~FGetPlayerStatisticVersionsResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetPlayerTagsRequest : public FPlayFabBaseModel
    {
        // [optional] Optional namespace to filter results by
        FString Namespace;

        // Unique PlayFab assigned ID of the user on whom the operation will be performed.
        FString PlayFabId;

        FGetPlayerTagsRequest() :
            FPlayFabBaseModel(),
            Namespace(),
            PlayFabId()
            {}

        FGetPlayerTagsRequest(const FGetPlayerTagsRequest& src) :
            FPlayFabBaseModel(),
            Namespace(src.Namespace),
            PlayFabId(src.PlayFabId)
            {}

        FGetPlayerTagsRequest(const TSharedPtr<FJsonObject>& obj) : FGetPlayerTagsRequest()
        {
            readFromValue(obj);
        }

        ~FGetPlayerTagsRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetPlayerTagsResult : public FPlayFabBaseModel
    {
        // Unique PlayFab assigned ID of the user on whom the operation will be performed.
        FString PlayFabId;

        // Canonical tags (including namespace and tag's name) for the requested user
        TArray<FString> Tags;
        FGetPlayerTagsResult() :
            FPlayFabBaseModel(),
            PlayFabId(),
            Tags()
            {}

        FGetPlayerTagsResult(const FGetPlayerTagsResult& src) :
            FPlayFabBaseModel(),
            PlayFabId(src.PlayFabId),
            Tags(src.Tags)
            {}

        FGetPlayerTagsResult(const TSharedPtr<FJsonObject>& obj) : FGetPlayerTagsResult()
        {
            readFromValue(obj);
        }

        ~FGetPlayerTagsResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetPlayFabIDsFromFacebookIDsRequest : public FPlayFabBaseModel
    {
        // Array of unique Facebook identifiers for which the title needs to get PlayFab identifiers.
        TArray<FString> FacebookIDs;
        FGetPlayFabIDsFromFacebookIDsRequest() :
            FPlayFabBaseModel(),
            FacebookIDs()
            {}

        FGetPlayFabIDsFromFacebookIDsRequest(const FGetPlayFabIDsFromFacebookIDsRequest& src) :
            FPlayFabBaseModel(),
            FacebookIDs(src.FacebookIDs)
            {}

        FGetPlayFabIDsFromFacebookIDsRequest(const TSharedPtr<FJsonObject>& obj) : FGetPlayFabIDsFromFacebookIDsRequest()
        {
            readFromValue(obj);
        }

        ~FGetPlayFabIDsFromFacebookIDsRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetPlayFabIDsFromFacebookIDsResult : public FPlayFabBaseModel
    {
        // [optional] Mapping of Facebook identifiers to PlayFab identifiers.
        TArray<FFacebookPlayFabIdPair> Data;
        FGetPlayFabIDsFromFacebookIDsResult() :
            FPlayFabBaseModel(),
            Data()
            {}

        FGetPlayFabIDsFromFacebookIDsResult(const FGetPlayFabIDsFromFacebookIDsResult& src) :
            FPlayFabBaseModel(),
            Data(src.Data)
            {}

        FGetPlayFabIDsFromFacebookIDsResult(const TSharedPtr<FJsonObject>& obj) : FGetPlayFabIDsFromFacebookIDsResult()
        {
            readFromValue(obj);
        }

        ~FGetPlayFabIDsFromFacebookIDsResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetPlayFabIDsFromSteamIDsRequest : public FPlayFabBaseModel
    {
        // [optional] Array of unique Steam identifiers (Steam profile IDs) for which the title needs to get PlayFab identifiers.
        TArray<FString> SteamStringIDs;
        FGetPlayFabIDsFromSteamIDsRequest() :
            FPlayFabBaseModel(),
            SteamStringIDs()
            {}

        FGetPlayFabIDsFromSteamIDsRequest(const FGetPlayFabIDsFromSteamIDsRequest& src) :
            FPlayFabBaseModel(),
            SteamStringIDs(src.SteamStringIDs)
            {}

        FGetPlayFabIDsFromSteamIDsRequest(const TSharedPtr<FJsonObject>& obj) : FGetPlayFabIDsFromSteamIDsRequest()
        {
            readFromValue(obj);
        }

        ~FGetPlayFabIDsFromSteamIDsRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FSteamPlayFabIdPair : public FPlayFabBaseModel
    {
        // [optional] Unique PlayFab identifier for a user, or null if no PlayFab account is linked to the Steam identifier.
        FString PlayFabId;

        // [optional] Unique Steam identifier for a user.
        FString SteamStringId;

        FSteamPlayFabIdPair() :
            FPlayFabBaseModel(),
            PlayFabId(),
            SteamStringId()
            {}

        FSteamPlayFabIdPair(const FSteamPlayFabIdPair& src) :
            FPlayFabBaseModel(),
            PlayFabId(src.PlayFabId),
            SteamStringId(src.SteamStringId)
            {}

        FSteamPlayFabIdPair(const TSharedPtr<FJsonObject>& obj) : FSteamPlayFabIdPair()
        {
            readFromValue(obj);
        }

        ~FSteamPlayFabIdPair();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetPlayFabIDsFromSteamIDsResult : public FPlayFabBaseModel
    {
        // [optional] Mapping of Steam identifiers to PlayFab identifiers.
        TArray<FSteamPlayFabIdPair> Data;
        FGetPlayFabIDsFromSteamIDsResult() :
            FPlayFabBaseModel(),
            Data()
            {}

        FGetPlayFabIDsFromSteamIDsResult(const FGetPlayFabIDsFromSteamIDsResult& src) :
            FPlayFabBaseModel(),
            Data(src.Data)
            {}

        FGetPlayFabIDsFromSteamIDsResult(const TSharedPtr<FJsonObject>& obj) : FGetPlayFabIDsFromSteamIDsResult()
        {
            readFromValue(obj);
        }

        ~FGetPlayFabIDsFromSteamIDsResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetPublisherDataRequest : public FPlayFabBaseModel
    {
        // array of keys to get back data from the Publisher data blob, set by the admin tools
        TArray<FString> Keys;
        FGetPublisherDataRequest() :
            FPlayFabBaseModel(),
            Keys()
            {}

        FGetPublisherDataRequest(const FGetPublisherDataRequest& src) :
            FPlayFabBaseModel(),
            Keys(src.Keys)
            {}

        FGetPublisherDataRequest(const TSharedPtr<FJsonObject>& obj) : FGetPublisherDataRequest()
        {
            readFromValue(obj);
        }

        ~FGetPublisherDataRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetPublisherDataResult : public FPlayFabBaseModel
    {
        // [optional] a dictionary object of key / value pairs
        TMap<FString, FString> Data;
        FGetPublisherDataResult() :
            FPlayFabBaseModel(),
            Data()
            {}

        FGetPublisherDataResult(const FGetPublisherDataResult& src) :
            FPlayFabBaseModel(),
            Data(src.Data)
            {}

        FGetPublisherDataResult(const TSharedPtr<FJsonObject>& obj) : FGetPublisherDataResult()
        {
            readFromValue(obj);
        }

        ~FGetPublisherDataResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetRandomResultTablesRequest : public FPlayFabBaseModel
    {
        /**
         * [optional] Specifies the catalog version that should be used to retrieve the Random Result Tables. If unspecified, uses
         * default/primary catalog.
         */
        FString CatalogVersion;

        // The unique identifier of the Random Result Table to use.
        TArray<FString> TableIDs;
        FGetRandomResultTablesRequest() :
            FPlayFabBaseModel(),
            CatalogVersion(),
            TableIDs()
            {}

        FGetRandomResultTablesRequest(const FGetRandomResultTablesRequest& src) :
            FPlayFabBaseModel(),
            CatalogVersion(src.CatalogVersion),
            TableIDs(src.TableIDs)
            {}

        FGetRandomResultTablesRequest(const TSharedPtr<FJsonObject>& obj) : FGetRandomResultTablesRequest()
        {
            readFromValue(obj);
        }

        ~FGetRandomResultTablesRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    enum ResultTableNodeType
    {
        ResultTableNodeTypeItemId,
        ResultTableNodeTypeTableId
    };

    PLAYFAB_API void writeResultTableNodeTypeEnumJSON(ResultTableNodeType enumVal, JsonWriter& writer);
    PLAYFAB_API ResultTableNodeType readResultTableNodeTypeFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFAB_API ResultTableNodeType readResultTableNodeTypeFromValue(const FString& value);

    struct PLAYFAB_API FResultTableNode : public FPlayFabBaseModel
    {
        // Either an ItemId, or the TableId of another random result table
        FString ResultItem;

        // Whether this entry in the table is an item or a link to another table
        ResultTableNodeType ResultItemType;

        // How likely this is to be rolled - larger numbers add more weight
        int32 Weight;

        FResultTableNode() :
            FPlayFabBaseModel(),
            ResultItem(),
            ResultItemType(),
            Weight(0)
            {}

        FResultTableNode(const FResultTableNode& src) :
            FPlayFabBaseModel(),
            ResultItem(src.ResultItem),
            ResultItemType(src.ResultItemType),
            Weight(src.Weight)
            {}

        FResultTableNode(const TSharedPtr<FJsonObject>& obj) : FResultTableNode()
        {
            readFromValue(obj);
        }

        ~FResultTableNode();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FRandomResultTableListing : public FPlayFabBaseModel
    {
        // [optional] Catalog version this table is associated with
        FString CatalogVersion;

        // Child nodes that indicate what kind of drop table item this actually is.
        TArray<FResultTableNode> Nodes;
        // Unique name for this drop table
        FString TableId;

        FRandomResultTableListing() :
            FPlayFabBaseModel(),
            CatalogVersion(),
            Nodes(),
            TableId()
            {}

        FRandomResultTableListing(const FRandomResultTableListing& src) :
            FPlayFabBaseModel(),
            CatalogVersion(src.CatalogVersion),
            Nodes(src.Nodes),
            TableId(src.TableId)
            {}

        FRandomResultTableListing(const TSharedPtr<FJsonObject>& obj) : FRandomResultTableListing()
        {
            readFromValue(obj);
        }

        ~FRandomResultTableListing();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetRandomResultTablesResult : public FPlayFabBaseModel
    {
        // [optional] array of random result tables currently available
        TMap<FString, FRandomResultTableListing> Tables;
        FGetRandomResultTablesResult() :
            FPlayFabBaseModel(),
            Tables()
            {}

        FGetRandomResultTablesResult(const FGetRandomResultTablesResult& src) :
            FPlayFabBaseModel(),
            Tables(src.Tables)
            {}

        FGetRandomResultTablesResult(const TSharedPtr<FJsonObject>& obj) : FGetRandomResultTablesResult()
        {
            readFromValue(obj);
        }

        ~FGetRandomResultTablesResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetSharedGroupDataRequest : public FPlayFabBaseModel
    {
        // [optional] If true, return the list of all members of the shared group.
        Boxed<bool> GetMembers;

        /**
         * [optional] Specific keys to retrieve from the shared group (if not specified, all keys will be returned, while an empty array
         * indicates that no keys should be returned).
         */
        TArray<FString> Keys;
        // Unique identifier for the shared group.
        FString SharedGroupId;

        FGetSharedGroupDataRequest() :
            FPlayFabBaseModel(),
            GetMembers(),
            Keys(),
            SharedGroupId()
            {}

        FGetSharedGroupDataRequest(const FGetSharedGroupDataRequest& src) :
            FPlayFabBaseModel(),
            GetMembers(src.GetMembers),
            Keys(src.Keys),
            SharedGroupId(src.SharedGroupId)
            {}

        FGetSharedGroupDataRequest(const TSharedPtr<FJsonObject>& obj) : FGetSharedGroupDataRequest()
        {
            readFromValue(obj);
        }

        ~FGetSharedGroupDataRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FSharedGroupDataRecord : public FPlayFabBaseModel
    {
        // Timestamp for when this data was last updated.
        FDateTime LastUpdated;

        // [optional] PlayFabId of the user to last update this value.
        FString LastUpdatedBy;

        // [optional] Indicates whether this data can be read by all users (public) or only members of the group (private).
        Boxed<UserDataPermission> Permission;

        // [optional] Data stored for the specified group data key.
        FString Value;

        FSharedGroupDataRecord() :
            FPlayFabBaseModel(),
            LastUpdated(0),
            LastUpdatedBy(),
            Permission(),
            Value()
            {}

        FSharedGroupDataRecord(const FSharedGroupDataRecord& src) :
            FPlayFabBaseModel(),
            LastUpdated(src.LastUpdated),
            LastUpdatedBy(src.LastUpdatedBy),
            Permission(src.Permission),
            Value(src.Value)
            {}

        FSharedGroupDataRecord(const TSharedPtr<FJsonObject>& obj) : FSharedGroupDataRecord()
        {
            readFromValue(obj);
        }

        ~FSharedGroupDataRecord();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetSharedGroupDataResult : public FPlayFabBaseModel
    {
        // [optional] Data for the requested keys.
        TMap<FString, FSharedGroupDataRecord> Data;
        // [optional] List of PlayFabId identifiers for the members of this group, if requested.
        TArray<FString> Members;
        FGetSharedGroupDataResult() :
            FPlayFabBaseModel(),
            Data(),
            Members()
            {}

        FGetSharedGroupDataResult(const FGetSharedGroupDataResult& src) :
            FPlayFabBaseModel(),
            Data(src.Data),
            Members(src.Members)
            {}

        FGetSharedGroupDataResult(const TSharedPtr<FJsonObject>& obj) : FGetSharedGroupDataResult()
        {
            readFromValue(obj);
        }

        ~FGetSharedGroupDataResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetTimeRequest : public FPlayFabBaseModel
    {
        FGetTimeRequest() :
            FPlayFabBaseModel()
            {}

        FGetTimeRequest(const FGetTimeRequest& src) :
            FPlayFabBaseModel()
            {}

        FGetTimeRequest(const TSharedPtr<FJsonObject>& obj) : FGetTimeRequest()
        {
            readFromValue(obj);
        }

        ~FGetTimeRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetTimeResult : public FPlayFabBaseModel
    {
        // Current server time when the request was received, in UTC
        FDateTime Time;

        FGetTimeResult() :
            FPlayFabBaseModel(),
            Time(0)
            {}

        FGetTimeResult(const FGetTimeResult& src) :
            FPlayFabBaseModel(),
            Time(src.Time)
            {}

        FGetTimeResult(const TSharedPtr<FJsonObject>& obj) : FGetTimeResult()
        {
            readFromValue(obj);
        }

        ~FGetTimeResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetTitleDataRequest : public FPlayFabBaseModel
    {
        // [optional] Specific keys to search for in the title data (leave null to get all keys)
        TArray<FString> Keys;
        FGetTitleDataRequest() :
            FPlayFabBaseModel(),
            Keys()
            {}

        FGetTitleDataRequest(const FGetTitleDataRequest& src) :
            FPlayFabBaseModel(),
            Keys(src.Keys)
            {}

        FGetTitleDataRequest(const TSharedPtr<FJsonObject>& obj) : FGetTitleDataRequest()
        {
            readFromValue(obj);
        }

        ~FGetTitleDataRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetTitleDataResult : public FPlayFabBaseModel
    {
        // [optional] a dictionary object of key / value pairs
        TMap<FString, FString> Data;
        FGetTitleDataResult() :
            FPlayFabBaseModel(),
            Data()
            {}

        FGetTitleDataResult(const FGetTitleDataResult& src) :
            FPlayFabBaseModel(),
            Data(src.Data)
            {}

        FGetTitleDataResult(const TSharedPtr<FJsonObject>& obj) : FGetTitleDataResult()
        {
            readFromValue(obj);
        }

        ~FGetTitleDataResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetTitleNewsRequest : public FPlayFabBaseModel
    {
        // [optional] Limits the results to the last n entries. Defaults to 10 if not set.
        Boxed<int32> Count;

        FGetTitleNewsRequest() :
            FPlayFabBaseModel(),
            Count()
            {}

        FGetTitleNewsRequest(const FGetTitleNewsRequest& src) :
            FPlayFabBaseModel(),
            Count(src.Count)
            {}

        FGetTitleNewsRequest(const TSharedPtr<FJsonObject>& obj) : FGetTitleNewsRequest()
        {
            readFromValue(obj);
        }

        ~FGetTitleNewsRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FTitleNewsItem : public FPlayFabBaseModel
    {
        // [optional] News item text.
        FString Body;

        // [optional] Unique identifier of news item.
        FString NewsId;

        // Date and time when the news items was posted.
        FDateTime Timestamp;

        // [optional] Title of the news item.
        FString Title;

        FTitleNewsItem() :
            FPlayFabBaseModel(),
            Body(),
            NewsId(),
            Timestamp(0),
            Title()
            {}

        FTitleNewsItem(const FTitleNewsItem& src) :
            FPlayFabBaseModel(),
            Body(src.Body),
            NewsId(src.NewsId),
            Timestamp(src.Timestamp),
            Title(src.Title)
            {}

        FTitleNewsItem(const TSharedPtr<FJsonObject>& obj) : FTitleNewsItem()
        {
            readFromValue(obj);
        }

        ~FTitleNewsItem();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetTitleNewsResult : public FPlayFabBaseModel
    {
        // [optional] Array of news items.
        TArray<FTitleNewsItem> News;
        FGetTitleNewsResult() :
            FPlayFabBaseModel(),
            News()
            {}

        FGetTitleNewsResult(const FGetTitleNewsResult& src) :
            FPlayFabBaseModel(),
            News(src.News)
            {}

        FGetTitleNewsResult(const TSharedPtr<FJsonObject>& obj) : FGetTitleNewsResult()
        {
            readFromValue(obj);
        }

        ~FGetTitleNewsResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetUserAccountInfoRequest : public FPlayFabBaseModel
    {
        // Unique PlayFab assigned ID of the user on whom the operation will be performed.
        FString PlayFabId;

        FGetUserAccountInfoRequest() :
            FPlayFabBaseModel(),
            PlayFabId()
            {}

        FGetUserAccountInfoRequest(const FGetUserAccountInfoRequest& src) :
            FPlayFabBaseModel(),
            PlayFabId(src.PlayFabId)
            {}

        FGetUserAccountInfoRequest(const TSharedPtr<FJsonObject>& obj) : FGetUserAccountInfoRequest()
        {
            readFromValue(obj);
        }

        ~FGetUserAccountInfoRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetUserAccountInfoResult : public FPlayFabBaseModel
    {
        // [optional] Account details for the user whose information was requested.
        TSharedPtr<FUserAccountInfo> UserInfo;

        FGetUserAccountInfoResult() :
            FPlayFabBaseModel(),
            UserInfo(nullptr)
            {}

        FGetUserAccountInfoResult(const FGetUserAccountInfoResult& src) :
            FPlayFabBaseModel(),
            UserInfo(src.UserInfo.IsValid() ? MakeShareable(new FUserAccountInfo(*src.UserInfo)) : nullptr)
            {}

        FGetUserAccountInfoResult(const TSharedPtr<FJsonObject>& obj) : FGetUserAccountInfoResult()
        {
            readFromValue(obj);
        }

        ~FGetUserAccountInfoResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetUserBansRequest : public FPlayFabBaseModel
    {
        // Unique PlayFab assigned ID of the user on whom the operation will be performed.
        FString PlayFabId;

        FGetUserBansRequest() :
            FPlayFabBaseModel(),
            PlayFabId()
            {}

        FGetUserBansRequest(const FGetUserBansRequest& src) :
            FPlayFabBaseModel(),
            PlayFabId(src.PlayFabId)
            {}

        FGetUserBansRequest(const TSharedPtr<FJsonObject>& obj) : FGetUserBansRequest()
        {
            readFromValue(obj);
        }

        ~FGetUserBansRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetUserBansResult : public FPlayFabBaseModel
    {
        // [optional] Information about the bans
        TArray<FBanInfo> BanData;
        FGetUserBansResult() :
            FPlayFabBaseModel(),
            BanData()
            {}

        FGetUserBansResult(const FGetUserBansResult& src) :
            FPlayFabBaseModel(),
            BanData(src.BanData)
            {}

        FGetUserBansResult(const TSharedPtr<FJsonObject>& obj) : FGetUserBansResult()
        {
            readFromValue(obj);
        }

        ~FGetUserBansResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetUserDataRequest : public FPlayFabBaseModel
    {
        /**
         * [optional] The version that currently exists according to the caller. The call will return the data for all of the keys if the
         * version in the system is greater than this.
         */
        Boxed<uint32> IfChangedFromDataVersion;

        // [optional] Specific keys to search for in the custom user data.
        TArray<FString> Keys;
        // Unique PlayFab assigned ID of the user on whom the operation will be performed.
        FString PlayFabId;

        FGetUserDataRequest() :
            FPlayFabBaseModel(),
            IfChangedFromDataVersion(),
            Keys(),
            PlayFabId()
            {}

        FGetUserDataRequest(const FGetUserDataRequest& src) :
            FPlayFabBaseModel(),
            IfChangedFromDataVersion(src.IfChangedFromDataVersion),
            Keys(src.Keys),
            PlayFabId(src.PlayFabId)
            {}

        FGetUserDataRequest(const TSharedPtr<FJsonObject>& obj) : FGetUserDataRequest()
        {
            readFromValue(obj);
        }

        ~FGetUserDataRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetUserDataResult : public FPlayFabBaseModel
    {
        // [optional] User specific data for this title.
        TMap<FString, FUserDataRecord> Data;
        /**
         * Indicates the current version of the data that has been set. This is incremented with every set call for that type of
         * data (read-only, internal, etc). This version can be provided in Get calls to find updated data.
         */
        uint32 DataVersion;

        // [optional] PlayFab unique identifier of the user whose custom data is being returned.
        FString PlayFabId;

        FGetUserDataResult() :
            FPlayFabBaseModel(),
            Data(),
            DataVersion(0),
            PlayFabId()
            {}

        FGetUserDataResult(const FGetUserDataResult& src) :
            FPlayFabBaseModel(),
            Data(src.Data),
            DataVersion(src.DataVersion),
            PlayFabId(src.PlayFabId)
            {}

        FGetUserDataResult(const TSharedPtr<FJsonObject>& obj) : FGetUserDataResult()
        {
            readFromValue(obj);
        }

        ~FGetUserDataResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetUserInventoryRequest : public FPlayFabBaseModel
    {
        // Unique PlayFab assigned ID of the user on whom the operation will be performed.
        FString PlayFabId;

        FGetUserInventoryRequest() :
            FPlayFabBaseModel(),
            PlayFabId()
            {}

        FGetUserInventoryRequest(const FGetUserInventoryRequest& src) :
            FPlayFabBaseModel(),
            PlayFabId(src.PlayFabId)
            {}

        FGetUserInventoryRequest(const TSharedPtr<FJsonObject>& obj) : FGetUserInventoryRequest()
        {
            readFromValue(obj);
        }

        ~FGetUserInventoryRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetUserInventoryResult : public FPlayFabBaseModel
    {
        // [optional] Array of inventory items belonging to the user.
        TArray<FItemInstance> Inventory;
        // [optional] Unique PlayFab assigned ID of the user on whom the operation will be performed.
        FString PlayFabId;

        // [optional] Array of virtual currency balance(s) belonging to the user.
        TMap<FString, int32> VirtualCurrency;
        // [optional] Array of remaining times and timestamps for virtual currencies.
        TMap<FString, FVirtualCurrencyRechargeTime> VirtualCurrencyRechargeTimes;
        FGetUserInventoryResult() :
            FPlayFabBaseModel(),
            Inventory(),
            PlayFabId(),
            VirtualCurrency(),
            VirtualCurrencyRechargeTimes()
            {}

        FGetUserInventoryResult(const FGetUserInventoryResult& src) :
            FPlayFabBaseModel(),
            Inventory(src.Inventory),
            PlayFabId(src.PlayFabId),
            VirtualCurrency(src.VirtualCurrency),
            VirtualCurrencyRechargeTimes(src.VirtualCurrencyRechargeTimes)
            {}

        FGetUserInventoryResult(const TSharedPtr<FJsonObject>& obj) : FGetUserInventoryResult()
        {
            readFromValue(obj);
        }

        ~FGetUserInventoryResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGrantCharacterToUserRequest : public FPlayFabBaseModel
    {
        // Non-unique display name of the character being granted (1-20 characters in length).
        FString CharacterName;

        // Type of the character being granted; statistics can be sliced based on this value.
        FString CharacterType;

        // Unique PlayFab assigned ID of the user on whom the operation will be performed.
        FString PlayFabId;

        FGrantCharacterToUserRequest() :
            FPlayFabBaseModel(),
            CharacterName(),
            CharacterType(),
            PlayFabId()
            {}

        FGrantCharacterToUserRequest(const FGrantCharacterToUserRequest& src) :
            FPlayFabBaseModel(),
            CharacterName(src.CharacterName),
            CharacterType(src.CharacterType),
            PlayFabId(src.PlayFabId)
            {}

        FGrantCharacterToUserRequest(const TSharedPtr<FJsonObject>& obj) : FGrantCharacterToUserRequest()
        {
            readFromValue(obj);
        }

        ~FGrantCharacterToUserRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGrantCharacterToUserResult : public FPlayFabBaseModel
    {
        // [optional] Unique identifier tagged to this character.
        FString CharacterId;

        FGrantCharacterToUserResult() :
            FPlayFabBaseModel(),
            CharacterId()
            {}

        FGrantCharacterToUserResult(const FGrantCharacterToUserResult& src) :
            FPlayFabBaseModel(),
            CharacterId(src.CharacterId)
            {}

        FGrantCharacterToUserResult(const TSharedPtr<FJsonObject>& obj) : FGrantCharacterToUserResult()
        {
            readFromValue(obj);
        }

        ~FGrantCharacterToUserResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGrantedItemInstance : public FPlayFabBaseModel
    {
        // [optional] Game specific comment associated with this instance when it was added to the user inventory.
        FString Annotation;

        // [optional] Array of unique items that were awarded when this catalog item was purchased.
        TArray<FString> BundleContents;
        /**
         * [optional] Unique identifier for the parent inventory item, as defined in the catalog, for object which were added from a bundle or
         * container.
         */
        FString BundleParent;

        // [optional] Catalog version for the inventory item, when this instance was created.
        FString CatalogVersion;

        // [optional] Unique PlayFab assigned ID for a specific character owned by a user
        FString CharacterId;

        // [optional] A set of custom key-value pairs on the inventory item.
        TMap<FString, FString> CustomData;
        // [optional] CatalogItem.DisplayName at the time this item was purchased.
        FString DisplayName;

        // [optional] Timestamp for when this instance will expire.
        Boxed<FDateTime> Expiration;

        // [optional] Class name for the inventory item, as defined in the catalog.
        FString ItemClass;

        // [optional] Unique identifier for the inventory item, as defined in the catalog.
        FString ItemId;

        // [optional] Unique item identifier for this specific instance of the item.
        FString ItemInstanceId;

        // [optional] Unique PlayFab assigned ID of the user on whom the operation will be performed.
        FString PlayFabId;

        // [optional] Timestamp for when this instance was purchased.
        Boxed<FDateTime> PurchaseDate;

        // [optional] Total number of remaining uses, if this is a consumable item.
        Boxed<int32> RemainingUses;

        // Result of this operation.
        bool Result;

        // [optional] Currency type for the cost of the catalog item.
        FString UnitCurrency;

        // Cost of the catalog item in the given currency.
        uint32 UnitPrice;

        // [optional] The number of uses that were added or removed to this item in this call.
        Boxed<int32> UsesIncrementedBy;

        FGrantedItemInstance() :
            FPlayFabBaseModel(),
            Annotation(),
            BundleContents(),
            BundleParent(),
            CatalogVersion(),
            CharacterId(),
            CustomData(),
            DisplayName(),
            Expiration(),
            ItemClass(),
            ItemId(),
            ItemInstanceId(),
            PlayFabId(),
            PurchaseDate(),
            RemainingUses(),
            Result(false),
            UnitCurrency(),
            UnitPrice(0),
            UsesIncrementedBy()
            {}

        FGrantedItemInstance(const FGrantedItemInstance& src) :
            FPlayFabBaseModel(),
            Annotation(src.Annotation),
            BundleContents(src.BundleContents),
            BundleParent(src.BundleParent),
            CatalogVersion(src.CatalogVersion),
            CharacterId(src.CharacterId),
            CustomData(src.CustomData),
            DisplayName(src.DisplayName),
            Expiration(src.Expiration),
            ItemClass(src.ItemClass),
            ItemId(src.ItemId),
            ItemInstanceId(src.ItemInstanceId),
            PlayFabId(src.PlayFabId),
            PurchaseDate(src.PurchaseDate),
            RemainingUses(src.RemainingUses),
            Result(src.Result),
            UnitCurrency(src.UnitCurrency),
            UnitPrice(src.UnitPrice),
            UsesIncrementedBy(src.UsesIncrementedBy)
            {}

        FGrantedItemInstance(const TSharedPtr<FJsonObject>& obj) : FGrantedItemInstance()
        {
            readFromValue(obj);
        }

        ~FGrantedItemInstance();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGrantItemsToCharacterRequest : public FPlayFabBaseModel
    {
        // [optional] String detailing any additional information concerning this operation.
        FString Annotation;

        // [optional] Catalog version from which items are to be granted.
        FString CatalogVersion;

        // Unique PlayFab assigned ID for a specific character owned by a user
        FString CharacterId;

        // [optional] Array of itemIds to grant to the user.
        TArray<FString> ItemIds;
        // Unique PlayFab assigned ID of the user on whom the operation will be performed.
        FString PlayFabId;

        FGrantItemsToCharacterRequest() :
            FPlayFabBaseModel(),
            Annotation(),
            CatalogVersion(),
            CharacterId(),
            ItemIds(),
            PlayFabId()
            {}

        FGrantItemsToCharacterRequest(const FGrantItemsToCharacterRequest& src) :
            FPlayFabBaseModel(),
            Annotation(src.Annotation),
            CatalogVersion(src.CatalogVersion),
            CharacterId(src.CharacterId),
            ItemIds(src.ItemIds),
            PlayFabId(src.PlayFabId)
            {}

        FGrantItemsToCharacterRequest(const TSharedPtr<FJsonObject>& obj) : FGrantItemsToCharacterRequest()
        {
            readFromValue(obj);
        }

        ~FGrantItemsToCharacterRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGrantItemsToCharacterResult : public FPlayFabBaseModel
    {
        // [optional] Array of items granted to users.
        TArray<FGrantedItemInstance> ItemGrantResults;
        FGrantItemsToCharacterResult() :
            FPlayFabBaseModel(),
            ItemGrantResults()
            {}

        FGrantItemsToCharacterResult(const FGrantItemsToCharacterResult& src) :
            FPlayFabBaseModel(),
            ItemGrantResults(src.ItemGrantResults)
            {}

        FGrantItemsToCharacterResult(const TSharedPtr<FJsonObject>& obj) : FGrantItemsToCharacterResult()
        {
            readFromValue(obj);
        }

        ~FGrantItemsToCharacterResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGrantItemsToUserRequest : public FPlayFabBaseModel
    {
        // [optional] String detailing any additional information concerning this operation.
        FString Annotation;

        // [optional] Catalog version from which items are to be granted.
        FString CatalogVersion;

        // Array of itemIds to grant to the user.
        TArray<FString> ItemIds;
        // Unique PlayFab assigned ID of the user on whom the operation will be performed.
        FString PlayFabId;

        FGrantItemsToUserRequest() :
            FPlayFabBaseModel(),
            Annotation(),
            CatalogVersion(),
            ItemIds(),
            PlayFabId()
            {}

        FGrantItemsToUserRequest(const FGrantItemsToUserRequest& src) :
            FPlayFabBaseModel(),
            Annotation(src.Annotation),
            CatalogVersion(src.CatalogVersion),
            ItemIds(src.ItemIds),
            PlayFabId(src.PlayFabId)
            {}

        FGrantItemsToUserRequest(const TSharedPtr<FJsonObject>& obj) : FGrantItemsToUserRequest()
        {
            readFromValue(obj);
        }

        ~FGrantItemsToUserRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGrantItemsToUserResult : public FPlayFabBaseModel
    {
        // [optional] Array of items granted to users.
        TArray<FGrantedItemInstance> ItemGrantResults;
        FGrantItemsToUserResult() :
            FPlayFabBaseModel(),
            ItemGrantResults()
            {}

        FGrantItemsToUserResult(const FGrantItemsToUserResult& src) :
            FPlayFabBaseModel(),
            ItemGrantResults(src.ItemGrantResults)
            {}

        FGrantItemsToUserResult(const TSharedPtr<FJsonObject>& obj) : FGrantItemsToUserResult()
        {
            readFromValue(obj);
        }

        ~FGrantItemsToUserResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FItemGrant : public FPlayFabBaseModel
    {
        // [optional] String detailing any additional information concerning this operation.
        FString Annotation;

        // [optional] Unique PlayFab assigned ID for a specific character owned by a user
        FString CharacterId;

        /**
         * [optional] Key-value pairs to be written to the custom data. Note that keys are trimmed of whitespace, are limited in size, and may
         * not begin with a '!' character or be null.
         */
        TMap<FString, FString> Data;
        // Unique identifier of the catalog item to be granted to the user.
        FString ItemId;

        /**
         * [optional] Optional list of Data-keys to remove from UserData. Some SDKs cannot insert null-values into Data due to language
         * constraints. Use this to delete the keys directly.
         */
        TArray<FString> KeysToRemove;
        // Unique PlayFab assigned ID of the user on whom the operation will be performed.
        FString PlayFabId;

        FItemGrant() :
            FPlayFabBaseModel(),
            Annotation(),
            CharacterId(),
            Data(),
            ItemId(),
            KeysToRemove(),
            PlayFabId()
            {}

        FItemGrant(const FItemGrant& src) :
            FPlayFabBaseModel(),
            Annotation(src.Annotation),
            CharacterId(src.CharacterId),
            Data(src.Data),
            ItemId(src.ItemId),
            KeysToRemove(src.KeysToRemove),
            PlayFabId(src.PlayFabId)
            {}

        FItemGrant(const TSharedPtr<FJsonObject>& obj) : FItemGrant()
        {
            readFromValue(obj);
        }

        ~FItemGrant();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGrantItemsToUsersRequest : public FPlayFabBaseModel
    {
        // [optional] Catalog version from which items are to be granted.
        FString CatalogVersion;

        // Array of items to grant and the users to whom the items are to be granted.
        TArray<FItemGrant> ItemGrants;
        FGrantItemsToUsersRequest() :
            FPlayFabBaseModel(),
            CatalogVersion(),
            ItemGrants()
            {}

        FGrantItemsToUsersRequest(const FGrantItemsToUsersRequest& src) :
            FPlayFabBaseModel(),
            CatalogVersion(src.CatalogVersion),
            ItemGrants(src.ItemGrants)
            {}

        FGrantItemsToUsersRequest(const TSharedPtr<FJsonObject>& obj) : FGrantItemsToUsersRequest()
        {
            readFromValue(obj);
        }

        ~FGrantItemsToUsersRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGrantItemsToUsersResult : public FPlayFabBaseModel
    {
        // [optional] Array of items granted to users.
        TArray<FGrantedItemInstance> ItemGrantResults;
        FGrantItemsToUsersResult() :
            FPlayFabBaseModel(),
            ItemGrantResults()
            {}

        FGrantItemsToUsersResult(const FGrantItemsToUsersResult& src) :
            FPlayFabBaseModel(),
            ItemGrantResults(src.ItemGrantResults)
            {}

        FGrantItemsToUsersResult(const TSharedPtr<FJsonObject>& obj) : FGrantItemsToUsersResult()
        {
            readFromValue(obj);
        }

        ~FGrantItemsToUsersResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FListUsersCharactersRequest : public FPlayFabBaseModel
    {
        // Unique PlayFab assigned ID of the user on whom the operation will be performed.
        FString PlayFabId;

        FListUsersCharactersRequest() :
            FPlayFabBaseModel(),
            PlayFabId()
            {}

        FListUsersCharactersRequest(const FListUsersCharactersRequest& src) :
            FPlayFabBaseModel(),
            PlayFabId(src.PlayFabId)
            {}

        FListUsersCharactersRequest(const TSharedPtr<FJsonObject>& obj) : FListUsersCharactersRequest()
        {
            readFromValue(obj);
        }

        ~FListUsersCharactersRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FListUsersCharactersResult : public FPlayFabBaseModel
    {
        // [optional] The requested list of characters.
        TArray<FCharacterResult> Characters;
        FListUsersCharactersResult() :
            FPlayFabBaseModel(),
            Characters()
            {}

        FListUsersCharactersResult(const FListUsersCharactersResult& src) :
            FPlayFabBaseModel(),
            Characters(src.Characters)
            {}

        FListUsersCharactersResult(const TSharedPtr<FJsonObject>& obj) : FListUsersCharactersResult()
        {
            readFromValue(obj);
        }

        ~FListUsersCharactersResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FModifyCharacterVirtualCurrencyResult : public FPlayFabBaseModel
    {
        // Balance of the virtual currency after modification.
        int32 Balance;

        // [optional] Name of the virtual currency which was modified.
        FString VirtualCurrency;

        FModifyCharacterVirtualCurrencyResult() :
            FPlayFabBaseModel(),
            Balance(0),
            VirtualCurrency()
            {}

        FModifyCharacterVirtualCurrencyResult(const FModifyCharacterVirtualCurrencyResult& src) :
            FPlayFabBaseModel(),
            Balance(src.Balance),
            VirtualCurrency(src.VirtualCurrency)
            {}

        FModifyCharacterVirtualCurrencyResult(const TSharedPtr<FJsonObject>& obj) : FModifyCharacterVirtualCurrencyResult()
        {
            readFromValue(obj);
        }

        ~FModifyCharacterVirtualCurrencyResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FModifyItemUsesRequest : public FPlayFabBaseModel
    {
        // Unique instance identifier of the item to be modified.
        FString ItemInstanceId;

        // PlayFab unique identifier of the user whose item is being modified.
        FString PlayFabId;

        // Number of uses to add to the item. Can be negative to remove uses.
        int32 UsesToAdd;

        FModifyItemUsesRequest() :
            FPlayFabBaseModel(),
            ItemInstanceId(),
            PlayFabId(),
            UsesToAdd(0)
            {}

        FModifyItemUsesRequest(const FModifyItemUsesRequest& src) :
            FPlayFabBaseModel(),
            ItemInstanceId(src.ItemInstanceId),
            PlayFabId(src.PlayFabId),
            UsesToAdd(src.UsesToAdd)
            {}

        FModifyItemUsesRequest(const TSharedPtr<FJsonObject>& obj) : FModifyItemUsesRequest()
        {
            readFromValue(obj);
        }

        ~FModifyItemUsesRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FModifyItemUsesResult : public FPlayFabBaseModel
    {
        // [optional] Unique instance identifier of the item with uses consumed.
        FString ItemInstanceId;

        // Number of uses remaining on the item.
        int32 RemainingUses;

        FModifyItemUsesResult() :
            FPlayFabBaseModel(),
            ItemInstanceId(),
            RemainingUses(0)
            {}

        FModifyItemUsesResult(const FModifyItemUsesResult& src) :
            FPlayFabBaseModel(),
            ItemInstanceId(src.ItemInstanceId),
            RemainingUses(src.RemainingUses)
            {}

        FModifyItemUsesResult(const TSharedPtr<FJsonObject>& obj) : FModifyItemUsesResult()
        {
            readFromValue(obj);
        }

        ~FModifyItemUsesResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FModifyUserVirtualCurrencyResult : public FPlayFabBaseModel
    {
        // Balance of the virtual currency after modification.
        int32 Balance;

        /**
         * Amount added or subtracted from the user's virtual currency. Maximum VC balance is Int32 (2,147,483,647). Any increase
         * over this value will be discarded.
         */
        int32 BalanceChange;

        // [optional] User currency was subtracted from.
        FString PlayFabId;

        // [optional] Name of the virtual currency which was modified.
        FString VirtualCurrency;

        FModifyUserVirtualCurrencyResult() :
            FPlayFabBaseModel(),
            Balance(0),
            BalanceChange(0),
            PlayFabId(),
            VirtualCurrency()
            {}

        FModifyUserVirtualCurrencyResult(const FModifyUserVirtualCurrencyResult& src) :
            FPlayFabBaseModel(),
            Balance(src.Balance),
            BalanceChange(src.BalanceChange),
            PlayFabId(src.PlayFabId),
            VirtualCurrency(src.VirtualCurrency)
            {}

        FModifyUserVirtualCurrencyResult(const TSharedPtr<FJsonObject>& obj) : FModifyUserVirtualCurrencyResult()
        {
            readFromValue(obj);
        }

        ~FModifyUserVirtualCurrencyResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FMoveItemToCharacterFromCharacterRequest : public FPlayFabBaseModel
    {
        // Unique identifier of the character that currently has the item.
        FString GivingCharacterId;

        // Unique PlayFab assigned instance identifier of the item
        FString ItemInstanceId;

        // Unique PlayFab assigned ID of the user on whom the operation will be performed.
        FString PlayFabId;

        // Unique identifier of the character that will be receiving the item.
        FString ReceivingCharacterId;

        FMoveItemToCharacterFromCharacterRequest() :
            FPlayFabBaseModel(),
            GivingCharacterId(),
            ItemInstanceId(),
            PlayFabId(),
            ReceivingCharacterId()
            {}

        FMoveItemToCharacterFromCharacterRequest(const FMoveItemToCharacterFromCharacterRequest& src) :
            FPlayFabBaseModel(),
            GivingCharacterId(src.GivingCharacterId),
            ItemInstanceId(src.ItemInstanceId),
            PlayFabId(src.PlayFabId),
            ReceivingCharacterId(src.ReceivingCharacterId)
            {}

        FMoveItemToCharacterFromCharacterRequest(const TSharedPtr<FJsonObject>& obj) : FMoveItemToCharacterFromCharacterRequest()
        {
            readFromValue(obj);
        }

        ~FMoveItemToCharacterFromCharacterRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FMoveItemToCharacterFromCharacterResult : public FPlayFabBaseModel
    {
        FMoveItemToCharacterFromCharacterResult() :
            FPlayFabBaseModel()
            {}

        FMoveItemToCharacterFromCharacterResult(const FMoveItemToCharacterFromCharacterResult& src) :
            FPlayFabBaseModel()
            {}

        FMoveItemToCharacterFromCharacterResult(const TSharedPtr<FJsonObject>& obj) : FMoveItemToCharacterFromCharacterResult()
        {
            readFromValue(obj);
        }

        ~FMoveItemToCharacterFromCharacterResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FMoveItemToCharacterFromUserRequest : public FPlayFabBaseModel
    {
        // Unique PlayFab assigned ID for a specific character owned by a user
        FString CharacterId;

        // Unique PlayFab assigned instance identifier of the item
        FString ItemInstanceId;

        // Unique PlayFab assigned ID of the user on whom the operation will be performed.
        FString PlayFabId;

        FMoveItemToCharacterFromUserRequest() :
            FPlayFabBaseModel(),
            CharacterId(),
            ItemInstanceId(),
            PlayFabId()
            {}

        FMoveItemToCharacterFromUserRequest(const FMoveItemToCharacterFromUserRequest& src) :
            FPlayFabBaseModel(),
            CharacterId(src.CharacterId),
            ItemInstanceId(src.ItemInstanceId),
            PlayFabId(src.PlayFabId)
            {}

        FMoveItemToCharacterFromUserRequest(const TSharedPtr<FJsonObject>& obj) : FMoveItemToCharacterFromUserRequest()
        {
            readFromValue(obj);
        }

        ~FMoveItemToCharacterFromUserRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FMoveItemToCharacterFromUserResult : public FPlayFabBaseModel
    {
        FMoveItemToCharacterFromUserResult() :
            FPlayFabBaseModel()
            {}

        FMoveItemToCharacterFromUserResult(const FMoveItemToCharacterFromUserResult& src) :
            FPlayFabBaseModel()
            {}

        FMoveItemToCharacterFromUserResult(const TSharedPtr<FJsonObject>& obj) : FMoveItemToCharacterFromUserResult()
        {
            readFromValue(obj);
        }

        ~FMoveItemToCharacterFromUserResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FMoveItemToUserFromCharacterRequest : public FPlayFabBaseModel
    {
        // Unique PlayFab assigned ID for a specific character owned by a user
        FString CharacterId;

        // Unique PlayFab assigned instance identifier of the item
        FString ItemInstanceId;

        // Unique PlayFab assigned ID of the user on whom the operation will be performed.
        FString PlayFabId;

        FMoveItemToUserFromCharacterRequest() :
            FPlayFabBaseModel(),
            CharacterId(),
            ItemInstanceId(),
            PlayFabId()
            {}

        FMoveItemToUserFromCharacterRequest(const FMoveItemToUserFromCharacterRequest& src) :
            FPlayFabBaseModel(),
            CharacterId(src.CharacterId),
            ItemInstanceId(src.ItemInstanceId),
            PlayFabId(src.PlayFabId)
            {}

        FMoveItemToUserFromCharacterRequest(const TSharedPtr<FJsonObject>& obj) : FMoveItemToUserFromCharacterRequest()
        {
            readFromValue(obj);
        }

        ~FMoveItemToUserFromCharacterRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FMoveItemToUserFromCharacterResult : public FPlayFabBaseModel
    {
        FMoveItemToUserFromCharacterResult() :
            FPlayFabBaseModel()
            {}

        FMoveItemToUserFromCharacterResult(const FMoveItemToUserFromCharacterResult& src) :
            FPlayFabBaseModel()
            {}

        FMoveItemToUserFromCharacterResult(const TSharedPtr<FJsonObject>& obj) : FMoveItemToUserFromCharacterResult()
        {
            readFromValue(obj);
        }

        ~FMoveItemToUserFromCharacterResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FNotifyMatchmakerPlayerLeftRequest : public FPlayFabBaseModel
    {
        // Unique identifier of the Game Instance the user is leaving.
        FString LobbyId;

        // Unique PlayFab assigned ID of the user on whom the operation will be performed.
        FString PlayFabId;

        FNotifyMatchmakerPlayerLeftRequest() :
            FPlayFabBaseModel(),
            LobbyId(),
            PlayFabId()
            {}

        FNotifyMatchmakerPlayerLeftRequest(const FNotifyMatchmakerPlayerLeftRequest& src) :
            FPlayFabBaseModel(),
            LobbyId(src.LobbyId),
            PlayFabId(src.PlayFabId)
            {}

        FNotifyMatchmakerPlayerLeftRequest(const TSharedPtr<FJsonObject>& obj) : FNotifyMatchmakerPlayerLeftRequest()
        {
            readFromValue(obj);
        }

        ~FNotifyMatchmakerPlayerLeftRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    enum PlayerConnectionState
    {
        PlayerConnectionStateUnassigned,
        PlayerConnectionStateConnecting,
        PlayerConnectionStateParticipating,
        PlayerConnectionStateParticipated
    };

    PLAYFAB_API void writePlayerConnectionStateEnumJSON(PlayerConnectionState enumVal, JsonWriter& writer);
    PLAYFAB_API PlayerConnectionState readPlayerConnectionStateFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFAB_API PlayerConnectionState readPlayerConnectionStateFromValue(const FString& value);

    struct PLAYFAB_API FNotifyMatchmakerPlayerLeftResult : public FPlayFabBaseModel
    {
        // [optional] State of user leaving the Game Server Instance.
        Boxed<PlayerConnectionState> PlayerState;

        FNotifyMatchmakerPlayerLeftResult() :
            FPlayFabBaseModel(),
            PlayerState()
            {}

        FNotifyMatchmakerPlayerLeftResult(const FNotifyMatchmakerPlayerLeftResult& src) :
            FPlayFabBaseModel(),
            PlayerState(src.PlayerState)
            {}

        FNotifyMatchmakerPlayerLeftResult(const TSharedPtr<FJsonObject>& obj) : FNotifyMatchmakerPlayerLeftResult()
        {
            readFromValue(obj);
        }

        ~FNotifyMatchmakerPlayerLeftResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FPushNotificationPackage : public FPlayFabBaseModel
    {
        // Numerical badge to display on App icon (iOS only)
        int32 Badge;

        // [optional] This must be a JSON formatted object. For use with developer-created custom Push Notification plugins
        FString CustomData;

        // [optional] Icon file to display with the message (Not supported for iOS)
        FString Icon;

        // Content of the message (all platforms)
        FString Message;

        // [optional] Sound file to play with the message (all platforms)
        FString Sound;

        // Title/Subject of the message. Not supported for iOS
        FString Title;

        FPushNotificationPackage() :
            FPlayFabBaseModel(),
            Badge(0),
            CustomData(),
            Icon(),
            Message(),
            Sound(),
            Title()
            {}

        FPushNotificationPackage(const FPushNotificationPackage& src) :
            FPlayFabBaseModel(),
            Badge(src.Badge),
            CustomData(src.CustomData),
            Icon(src.Icon),
            Message(src.Message),
            Sound(src.Sound),
            Title(src.Title)
            {}

        FPushNotificationPackage(const TSharedPtr<FJsonObject>& obj) : FPushNotificationPackage()
        {
            readFromValue(obj);
        }

        ~FPushNotificationPackage();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FRedeemCouponRequest : public FPlayFabBaseModel
    {
        // [optional] Catalog version of the coupon.
        FString CatalogVersion;

        // [optional] Optional identifier for the Character that should receive the item. If null, item is added to the player
        FString CharacterId;

        // Generated coupon code to redeem.
        FString CouponCode;

        // Unique PlayFab assigned ID of the user on whom the operation will be performed.
        FString PlayFabId;

        FRedeemCouponRequest() :
            FPlayFabBaseModel(),
            CatalogVersion(),
            CharacterId(),
            CouponCode(),
            PlayFabId()
            {}

        FRedeemCouponRequest(const FRedeemCouponRequest& src) :
            FPlayFabBaseModel(),
            CatalogVersion(src.CatalogVersion),
            CharacterId(src.CharacterId),
            CouponCode(src.CouponCode),
            PlayFabId(src.PlayFabId)
            {}

        FRedeemCouponRequest(const TSharedPtr<FJsonObject>& obj) : FRedeemCouponRequest()
        {
            readFromValue(obj);
        }

        ~FRedeemCouponRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FRedeemCouponResult : public FPlayFabBaseModel
    {
        // [optional] Items granted to the player as a result of redeeming the coupon.
        TArray<FItemInstance> GrantedItems;
        FRedeemCouponResult() :
            FPlayFabBaseModel(),
            GrantedItems()
            {}

        FRedeemCouponResult(const FRedeemCouponResult& src) :
            FPlayFabBaseModel(),
            GrantedItems(src.GrantedItems)
            {}

        FRedeemCouponResult(const TSharedPtr<FJsonObject>& obj) : FRedeemCouponResult()
        {
            readFromValue(obj);
        }

        ~FRedeemCouponResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FRedeemMatchmakerTicketRequest : public FPlayFabBaseModel
    {
        // Unique identifier of the Game Server Instance that is asking for validation of the authorization ticket.
        FString LobbyId;

        // Server authorization ticket passed back from a call to Matchmake or StartGame.
        FString Ticket;

        FRedeemMatchmakerTicketRequest() :
            FPlayFabBaseModel(),
            LobbyId(),
            Ticket()
            {}

        FRedeemMatchmakerTicketRequest(const FRedeemMatchmakerTicketRequest& src) :
            FPlayFabBaseModel(),
            LobbyId(src.LobbyId),
            Ticket(src.Ticket)
            {}

        FRedeemMatchmakerTicketRequest(const TSharedPtr<FJsonObject>& obj) : FRedeemMatchmakerTicketRequest()
        {
            readFromValue(obj);
        }

        ~FRedeemMatchmakerTicketRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FRedeemMatchmakerTicketResult : public FPlayFabBaseModel
    {
        // [optional] Error value if the ticket was not validated.
        FString Error;

        // Boolean indicating whether the ticket was validated by the PlayFab service.
        bool TicketIsValid;

        // [optional] User account information for the user validated.
        TSharedPtr<FUserAccountInfo> UserInfo;

        FRedeemMatchmakerTicketResult() :
            FPlayFabBaseModel(),
            Error(),
            TicketIsValid(false),
            UserInfo(nullptr)
            {}

        FRedeemMatchmakerTicketResult(const FRedeemMatchmakerTicketResult& src) :
            FPlayFabBaseModel(),
            Error(src.Error),
            TicketIsValid(src.TicketIsValid),
            UserInfo(src.UserInfo.IsValid() ? MakeShareable(new FUserAccountInfo(*src.UserInfo)) : nullptr)
            {}

        FRedeemMatchmakerTicketResult(const TSharedPtr<FJsonObject>& obj) : FRedeemMatchmakerTicketResult()
        {
            readFromValue(obj);
        }

        ~FRedeemMatchmakerTicketResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FRefreshGameServerInstanceHeartbeatRequest : public FPlayFabBaseModel
    {
        // Unique identifier of the Game Server Instance for which the heartbeat is updated.
        FString LobbyId;

        FRefreshGameServerInstanceHeartbeatRequest() :
            FPlayFabBaseModel(),
            LobbyId()
            {}

        FRefreshGameServerInstanceHeartbeatRequest(const FRefreshGameServerInstanceHeartbeatRequest& src) :
            FPlayFabBaseModel(),
            LobbyId(src.LobbyId)
            {}

        FRefreshGameServerInstanceHeartbeatRequest(const TSharedPtr<FJsonObject>& obj) : FRefreshGameServerInstanceHeartbeatRequest()
        {
            readFromValue(obj);
        }

        ~FRefreshGameServerInstanceHeartbeatRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FRefreshGameServerInstanceHeartbeatResult : public FPlayFabBaseModel
    {
        FRefreshGameServerInstanceHeartbeatResult() :
            FPlayFabBaseModel()
            {}

        FRefreshGameServerInstanceHeartbeatResult(const FRefreshGameServerInstanceHeartbeatResult& src) :
            FPlayFabBaseModel()
            {}

        FRefreshGameServerInstanceHeartbeatResult(const TSharedPtr<FJsonObject>& obj) : FRefreshGameServerInstanceHeartbeatResult()
        {
            readFromValue(obj);
        }

        ~FRefreshGameServerInstanceHeartbeatResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    enum Region
    {
        RegionUSCentral,
        RegionUSEast,
        RegionEUWest,
        RegionSingapore,
        RegionJapan,
        RegionBrazil,
        RegionAustralia
    };

    PLAYFAB_API void writeRegionEnumJSON(Region enumVal, JsonWriter& writer);
    PLAYFAB_API Region readRegionFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFAB_API Region readRegionFromValue(const FString& value);

    struct PLAYFAB_API FRegisterGameRequest : public FPlayFabBaseModel
    {
        // Unique identifier of the build running on the Game Server Instance.
        FString Build;

        /**
         * Game Mode the Game Server instance is running. Note that this must be defined in the Game Modes tab in the PlayFab Game
         * Manager, along with the Build ID (the same Game Mode can be defined for multiple Build IDs).
         */
        FString GameMode;

        // [optional] Previous lobby id if re-registering an existing game.
        FString LobbyId;

        /**
         * Region in which the Game Server Instance is running. For matchmaking using non-AWS region names, set this to any AWS
         * region and use Tags (below) to specify your custom region.
         */
        Region pfRegion;

        // IPV4 address of the Game Server Instance.
        FString ServerHost;

        // [optional] IPV6 address of the Game Server Instance.
        FString ServerIPV6Address;

        // Port number for communication with the Game Server Instance.
        FString ServerPort;

        // [optional] Tags for the Game Server Instance
        TMap<FString, FString> Tags;
        FRegisterGameRequest() :
            FPlayFabBaseModel(),
            Build(),
            GameMode(),
            LobbyId(),
            pfRegion(),
            ServerHost(),
            ServerIPV6Address(),
            ServerPort(),
            Tags()
            {}

        FRegisterGameRequest(const FRegisterGameRequest& src) :
            FPlayFabBaseModel(),
            Build(src.Build),
            GameMode(src.GameMode),
            LobbyId(src.LobbyId),
            pfRegion(src.pfRegion),
            ServerHost(src.ServerHost),
            ServerIPV6Address(src.ServerIPV6Address),
            ServerPort(src.ServerPort),
            Tags(src.Tags)
            {}

        FRegisterGameRequest(const TSharedPtr<FJsonObject>& obj) : FRegisterGameRequest()
        {
            readFromValue(obj);
        }

        ~FRegisterGameRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FRegisterGameResponse : public FPlayFabBaseModel
    {
        /**
         * [optional] Unique identifier generated for the Game Server Instance that is registered. If LobbyId is specified in request and the
         * game still exists in PlayFab, the LobbyId in request is returned. Otherwise a new lobby id will be returned.
         */
        FString LobbyId;

        FRegisterGameResponse() :
            FPlayFabBaseModel(),
            LobbyId()
            {}

        FRegisterGameResponse(const FRegisterGameResponse& src) :
            FPlayFabBaseModel(),
            LobbyId(src.LobbyId)
            {}

        FRegisterGameResponse(const TSharedPtr<FJsonObject>& obj) : FRegisterGameResponse()
        {
            readFromValue(obj);
        }

        ~FRegisterGameResponse();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FRemoveFriendRequest : public FPlayFabBaseModel
    {
        // PlayFab identifier of the friend account which is to be removed.
        FString FriendPlayFabId;

        // Unique PlayFab assigned ID of the user on whom the operation will be performed.
        FString PlayFabId;

        FRemoveFriendRequest() :
            FPlayFabBaseModel(),
            FriendPlayFabId(),
            PlayFabId()
            {}

        FRemoveFriendRequest(const FRemoveFriendRequest& src) :
            FPlayFabBaseModel(),
            FriendPlayFabId(src.FriendPlayFabId),
            PlayFabId(src.PlayFabId)
            {}

        FRemoveFriendRequest(const TSharedPtr<FJsonObject>& obj) : FRemoveFriendRequest()
        {
            readFromValue(obj);
        }

        ~FRemoveFriendRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FRemovePlayerTagRequest : public FPlayFabBaseModel
    {
        // Unique PlayFab assigned ID of the user on whom the operation will be performed.
        FString PlayFabId;

        // Unique tag for player profile.
        FString TagName;

        FRemovePlayerTagRequest() :
            FPlayFabBaseModel(),
            PlayFabId(),
            TagName()
            {}

        FRemovePlayerTagRequest(const FRemovePlayerTagRequest& src) :
            FPlayFabBaseModel(),
            PlayFabId(src.PlayFabId),
            TagName(src.TagName)
            {}

        FRemovePlayerTagRequest(const TSharedPtr<FJsonObject>& obj) : FRemovePlayerTagRequest()
        {
            readFromValue(obj);
        }

        ~FRemovePlayerTagRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FRemovePlayerTagResult : public FPlayFabBaseModel
    {
        FRemovePlayerTagResult() :
            FPlayFabBaseModel()
            {}

        FRemovePlayerTagResult(const FRemovePlayerTagResult& src) :
            FPlayFabBaseModel()
            {}

        FRemovePlayerTagResult(const TSharedPtr<FJsonObject>& obj) : FRemovePlayerTagResult()
        {
            readFromValue(obj);
        }

        ~FRemovePlayerTagResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FRemoveSharedGroupMembersRequest : public FPlayFabBaseModel
    {
        // An array of unique PlayFab assigned ID of the user on whom the operation will be performed.
        TArray<FString> PlayFabIds;
        // Unique identifier for the shared group.
        FString SharedGroupId;

        FRemoveSharedGroupMembersRequest() :
            FPlayFabBaseModel(),
            PlayFabIds(),
            SharedGroupId()
            {}

        FRemoveSharedGroupMembersRequest(const FRemoveSharedGroupMembersRequest& src) :
            FPlayFabBaseModel(),
            PlayFabIds(src.PlayFabIds),
            SharedGroupId(src.SharedGroupId)
            {}

        FRemoveSharedGroupMembersRequest(const TSharedPtr<FJsonObject>& obj) : FRemoveSharedGroupMembersRequest()
        {
            readFromValue(obj);
        }

        ~FRemoveSharedGroupMembersRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FRemoveSharedGroupMembersResult : public FPlayFabBaseModel
    {
        FRemoveSharedGroupMembersResult() :
            FPlayFabBaseModel()
            {}

        FRemoveSharedGroupMembersResult(const FRemoveSharedGroupMembersResult& src) :
            FPlayFabBaseModel()
            {}

        FRemoveSharedGroupMembersResult(const TSharedPtr<FJsonObject>& obj) : FRemoveSharedGroupMembersResult()
        {
            readFromValue(obj);
        }

        ~FRemoveSharedGroupMembersResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FReportPlayerServerRequest : public FPlayFabBaseModel
    {
        // [optional] Optional additional comment by reporting player.
        FString Comment;

        // Unique PlayFab identifier of the reported player.
        FString ReporteeId;

        // PlayFabId of the reporting player.
        FString ReporterId;

        FReportPlayerServerRequest() :
            FPlayFabBaseModel(),
            Comment(),
            ReporteeId(),
            ReporterId()
            {}

        FReportPlayerServerRequest(const FReportPlayerServerRequest& src) :
            FPlayFabBaseModel(),
            Comment(src.Comment),
            ReporteeId(src.ReporteeId),
            ReporterId(src.ReporterId)
            {}

        FReportPlayerServerRequest(const TSharedPtr<FJsonObject>& obj) : FReportPlayerServerRequest()
        {
            readFromValue(obj);
        }

        ~FReportPlayerServerRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FReportPlayerServerResult : public FPlayFabBaseModel
    {
        // The number of remaining reports which may be filed today by this reporting player.
        int32 SubmissionsRemaining;

        FReportPlayerServerResult() :
            FPlayFabBaseModel(),
            SubmissionsRemaining(0)
            {}

        FReportPlayerServerResult(const FReportPlayerServerResult& src) :
            FPlayFabBaseModel(),
            SubmissionsRemaining(src.SubmissionsRemaining)
            {}

        FReportPlayerServerResult(const TSharedPtr<FJsonObject>& obj) : FReportPlayerServerResult()
        {
            readFromValue(obj);
        }

        ~FReportPlayerServerResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FRevokeAllBansForUserRequest : public FPlayFabBaseModel
    {
        // Unique PlayFab assigned ID of the user on whom the operation will be performed.
        FString PlayFabId;

        FRevokeAllBansForUserRequest() :
            FPlayFabBaseModel(),
            PlayFabId()
            {}

        FRevokeAllBansForUserRequest(const FRevokeAllBansForUserRequest& src) :
            FPlayFabBaseModel(),
            PlayFabId(src.PlayFabId)
            {}

        FRevokeAllBansForUserRequest(const TSharedPtr<FJsonObject>& obj) : FRevokeAllBansForUserRequest()
        {
            readFromValue(obj);
        }

        ~FRevokeAllBansForUserRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FRevokeAllBansForUserResult : public FPlayFabBaseModel
    {
        // [optional] Information on the bans that were revoked.
        TArray<FBanInfo> BanData;
        FRevokeAllBansForUserResult() :
            FPlayFabBaseModel(),
            BanData()
            {}

        FRevokeAllBansForUserResult(const FRevokeAllBansForUserResult& src) :
            FPlayFabBaseModel(),
            BanData(src.BanData)
            {}

        FRevokeAllBansForUserResult(const TSharedPtr<FJsonObject>& obj) : FRevokeAllBansForUserResult()
        {
            readFromValue(obj);
        }

        ~FRevokeAllBansForUserResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FRevokeBansRequest : public FPlayFabBaseModel
    {
        // Ids of the bans to be revoked. Maximum 100.
        TArray<FString> BanIds;
        FRevokeBansRequest() :
            FPlayFabBaseModel(),
            BanIds()
            {}

        FRevokeBansRequest(const FRevokeBansRequest& src) :
            FPlayFabBaseModel(),
            BanIds(src.BanIds)
            {}

        FRevokeBansRequest(const TSharedPtr<FJsonObject>& obj) : FRevokeBansRequest()
        {
            readFromValue(obj);
        }

        ~FRevokeBansRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FRevokeBansResult : public FPlayFabBaseModel
    {
        // [optional] Information on the bans that were revoked
        TArray<FBanInfo> BanData;
        FRevokeBansResult() :
            FPlayFabBaseModel(),
            BanData()
            {}

        FRevokeBansResult(const FRevokeBansResult& src) :
            FPlayFabBaseModel(),
            BanData(src.BanData)
            {}

        FRevokeBansResult(const TSharedPtr<FJsonObject>& obj) : FRevokeBansResult()
        {
            readFromValue(obj);
        }

        ~FRevokeBansResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FRevokeInventoryItem : public FPlayFabBaseModel
    {
        // [optional] Unique PlayFab assigned ID for a specific character owned by a user
        FString CharacterId;

        // Unique PlayFab assigned instance identifier of the item
        FString ItemInstanceId;

        // Unique PlayFab assigned ID of the user on whom the operation will be performed.
        FString PlayFabId;

        FRevokeInventoryItem() :
            FPlayFabBaseModel(),
            CharacterId(),
            ItemInstanceId(),
            PlayFabId()
            {}

        FRevokeInventoryItem(const FRevokeInventoryItem& src) :
            FPlayFabBaseModel(),
            CharacterId(src.CharacterId),
            ItemInstanceId(src.ItemInstanceId),
            PlayFabId(src.PlayFabId)
            {}

        FRevokeInventoryItem(const TSharedPtr<FJsonObject>& obj) : FRevokeInventoryItem()
        {
            readFromValue(obj);
        }

        ~FRevokeInventoryItem();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FRevokeInventoryItemRequest : public FPlayFabBaseModel
    {
        // [optional] Unique PlayFab assigned ID for a specific character owned by a user
        FString CharacterId;

        // Unique PlayFab assigned instance identifier of the item
        FString ItemInstanceId;

        // Unique PlayFab assigned ID of the user on whom the operation will be performed.
        FString PlayFabId;

        FRevokeInventoryItemRequest() :
            FPlayFabBaseModel(),
            CharacterId(),
            ItemInstanceId(),
            PlayFabId()
            {}

        FRevokeInventoryItemRequest(const FRevokeInventoryItemRequest& src) :
            FPlayFabBaseModel(),
            CharacterId(src.CharacterId),
            ItemInstanceId(src.ItemInstanceId),
            PlayFabId(src.PlayFabId)
            {}

        FRevokeInventoryItemRequest(const TSharedPtr<FJsonObject>& obj) : FRevokeInventoryItemRequest()
        {
            readFromValue(obj);
        }

        ~FRevokeInventoryItemRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FRevokeInventoryItemsRequest : public FPlayFabBaseModel
    {
        // Array of player items to revoke, between 1 and 25 items.
        TArray<FRevokeInventoryItem> Items;
        FRevokeInventoryItemsRequest() :
            FPlayFabBaseModel(),
            Items()
            {}

        FRevokeInventoryItemsRequest(const FRevokeInventoryItemsRequest& src) :
            FPlayFabBaseModel(),
            Items(src.Items)
            {}

        FRevokeInventoryItemsRequest(const TSharedPtr<FJsonObject>& obj) : FRevokeInventoryItemsRequest()
        {
            readFromValue(obj);
        }

        ~FRevokeInventoryItemsRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FRevokeItemError : public FPlayFabBaseModel
    {
        // [optional] Specific error that was encountered.
        FString Error;

        // [optional] Item information that failed to be revoked.
        TSharedPtr<FRevokeInventoryItem> Item;

        FRevokeItemError() :
            FPlayFabBaseModel(),
            Error(),
            Item(nullptr)
            {}

        FRevokeItemError(const FRevokeItemError& src) :
            FPlayFabBaseModel(),
            Error(src.Error),
            Item(src.Item.IsValid() ? MakeShareable(new FRevokeInventoryItem(*src.Item)) : nullptr)
            {}

        FRevokeItemError(const TSharedPtr<FJsonObject>& obj) : FRevokeItemError()
        {
            readFromValue(obj);
        }

        ~FRevokeItemError();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FRevokeInventoryItemsResult : public FPlayFabBaseModel
    {
        // [optional] Collection of any errors that occurred during processing.
        TArray<FRevokeItemError> Errors;
        FRevokeInventoryItemsResult() :
            FPlayFabBaseModel(),
            Errors()
            {}

        FRevokeInventoryItemsResult(const FRevokeInventoryItemsResult& src) :
            FPlayFabBaseModel(),
            Errors(src.Errors)
            {}

        FRevokeInventoryItemsResult(const TSharedPtr<FJsonObject>& obj) : FRevokeInventoryItemsResult()
        {
            readFromValue(obj);
        }

        ~FRevokeInventoryItemsResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FRevokeInventoryResult : public FPlayFabBaseModel
    {
        FRevokeInventoryResult() :
            FPlayFabBaseModel()
            {}

        FRevokeInventoryResult(const FRevokeInventoryResult& src) :
            FPlayFabBaseModel()
            {}

        FRevokeInventoryResult(const TSharedPtr<FJsonObject>& obj) : FRevokeInventoryResult()
        {
            readFromValue(obj);
        }

        ~FRevokeInventoryResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FSendCustomAccountRecoveryEmailRequest : public FPlayFabBaseModel
    {
        // [optional] User email address attached to their account
        FString Email;

        // The email template id of the account recovery email template to send.
        FString EmailTemplateId;

        // [optional] The user's username requesting an account recovery.
        FString Username;

        FSendCustomAccountRecoveryEmailRequest() :
            FPlayFabBaseModel(),
            Email(),
            EmailTemplateId(),
            Username()
            {}

        FSendCustomAccountRecoveryEmailRequest(const FSendCustomAccountRecoveryEmailRequest& src) :
            FPlayFabBaseModel(),
            Email(src.Email),
            EmailTemplateId(src.EmailTemplateId),
            Username(src.Username)
            {}

        FSendCustomAccountRecoveryEmailRequest(const TSharedPtr<FJsonObject>& obj) : FSendCustomAccountRecoveryEmailRequest()
        {
            readFromValue(obj);
        }

        ~FSendCustomAccountRecoveryEmailRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FSendCustomAccountRecoveryEmailResult : public FPlayFabBaseModel
    {
        FSendCustomAccountRecoveryEmailResult() :
            FPlayFabBaseModel()
            {}

        FSendCustomAccountRecoveryEmailResult(const FSendCustomAccountRecoveryEmailResult& src) :
            FPlayFabBaseModel()
            {}

        FSendCustomAccountRecoveryEmailResult(const TSharedPtr<FJsonObject>& obj) : FSendCustomAccountRecoveryEmailResult()
        {
            readFromValue(obj);
        }

        ~FSendCustomAccountRecoveryEmailResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FSendEmailFromTemplateRequest : public FPlayFabBaseModel
    {
        // The email template id of the email template to send.
        FString EmailTemplateId;

        // Unique PlayFab assigned ID of the user on whom the operation will be performed.
        FString PlayFabId;

        FSendEmailFromTemplateRequest() :
            FPlayFabBaseModel(),
            EmailTemplateId(),
            PlayFabId()
            {}

        FSendEmailFromTemplateRequest(const FSendEmailFromTemplateRequest& src) :
            FPlayFabBaseModel(),
            EmailTemplateId(src.EmailTemplateId),
            PlayFabId(src.PlayFabId)
            {}

        FSendEmailFromTemplateRequest(const TSharedPtr<FJsonObject>& obj) : FSendEmailFromTemplateRequest()
        {
            readFromValue(obj);
        }

        ~FSendEmailFromTemplateRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FSendEmailFromTemplateResult : public FPlayFabBaseModel
    {
        FSendEmailFromTemplateResult() :
            FPlayFabBaseModel()
            {}

        FSendEmailFromTemplateResult(const FSendEmailFromTemplateResult& src) :
            FPlayFabBaseModel()
            {}

        FSendEmailFromTemplateResult(const TSharedPtr<FJsonObject>& obj) : FSendEmailFromTemplateResult()
        {
            readFromValue(obj);
        }

        ~FSendEmailFromTemplateResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FSendPushNotificationRequest : public FPlayFabBaseModel
    {
        /**
         * [optional] Allows you to provide precisely formatted json to target devices. This is an advanced feature, allowing you to deliver
         * to custom plugin logic, fields, or functionality not natively supported by PlayFab.
         */
        TArray<FAdvancedPushPlatformMsg> AdvancedPlatformDelivery;
        // [optional] Text of message to send.
        FString Message;

        /**
         * [optional] Defines all possible push attributes like message, title, icon, etc. Some parameters are device specific - please see
         * the PushNotificationPackage documentation for details.
         */
        TSharedPtr<FPushNotificationPackage> Package;

        // PlayFabId of the recipient of the push notification.
        FString Recipient;

        // [optional] Subject of message to send (may not be displayed in all platforms)
        FString Subject;

        // [optional] Target Platforms that should receive the Message or Package. If omitted, we will send to all available platforms.
        TArray<PushNotificationPlatform> TargetPlatforms;
        FSendPushNotificationRequest() :
            FPlayFabBaseModel(),
            AdvancedPlatformDelivery(),
            Message(),
            Package(nullptr),
            Recipient(),
            Subject(),
            TargetPlatforms()
            {}

        FSendPushNotificationRequest(const FSendPushNotificationRequest& src) :
            FPlayFabBaseModel(),
            AdvancedPlatformDelivery(src.AdvancedPlatformDelivery),
            Message(src.Message),
            Package(src.Package.IsValid() ? MakeShareable(new FPushNotificationPackage(*src.Package)) : nullptr),
            Recipient(src.Recipient),
            Subject(src.Subject),
            TargetPlatforms(src.TargetPlatforms)
            {}

        FSendPushNotificationRequest(const TSharedPtr<FJsonObject>& obj) : FSendPushNotificationRequest()
        {
            readFromValue(obj);
        }

        ~FSendPushNotificationRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FSendPushNotificationResult : public FPlayFabBaseModel
    {
        FSendPushNotificationResult() :
            FPlayFabBaseModel()
            {}

        FSendPushNotificationResult(const FSendPushNotificationResult& src) :
            FPlayFabBaseModel()
            {}

        FSendPushNotificationResult(const TSharedPtr<FJsonObject>& obj) : FSendPushNotificationResult()
        {
            readFromValue(obj);
        }

        ~FSendPushNotificationResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FSetFriendTagsRequest : public FPlayFabBaseModel
    {
        // PlayFab identifier of the friend account to which the tag(s) should be applied.
        FString FriendPlayFabId;

        // PlayFab identifier of the player whose friend is to be updated.
        FString PlayFabId;

        // Array of tags to set on the friend account.
        TArray<FString> Tags;
        FSetFriendTagsRequest() :
            FPlayFabBaseModel(),
            FriendPlayFabId(),
            PlayFabId(),
            Tags()
            {}

        FSetFriendTagsRequest(const FSetFriendTagsRequest& src) :
            FPlayFabBaseModel(),
            FriendPlayFabId(src.FriendPlayFabId),
            PlayFabId(src.PlayFabId),
            Tags(src.Tags)
            {}

        FSetFriendTagsRequest(const TSharedPtr<FJsonObject>& obj) : FSetFriendTagsRequest()
        {
            readFromValue(obj);
        }

        ~FSetFriendTagsRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FSetGameServerInstanceDataRequest : public FPlayFabBaseModel
    {
        // Custom data to set for the specified game server instance.
        FString GameServerData;

        // Unique identifier of the Game Instance to be updated, in decimal format.
        FString LobbyId;

        FSetGameServerInstanceDataRequest() :
            FPlayFabBaseModel(),
            GameServerData(),
            LobbyId()
            {}

        FSetGameServerInstanceDataRequest(const FSetGameServerInstanceDataRequest& src) :
            FPlayFabBaseModel(),
            GameServerData(src.GameServerData),
            LobbyId(src.LobbyId)
            {}

        FSetGameServerInstanceDataRequest(const TSharedPtr<FJsonObject>& obj) : FSetGameServerInstanceDataRequest()
        {
            readFromValue(obj);
        }

        ~FSetGameServerInstanceDataRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FSetGameServerInstanceDataResult : public FPlayFabBaseModel
    {
        FSetGameServerInstanceDataResult() :
            FPlayFabBaseModel()
            {}

        FSetGameServerInstanceDataResult(const FSetGameServerInstanceDataResult& src) :
            FPlayFabBaseModel()
            {}

        FSetGameServerInstanceDataResult(const TSharedPtr<FJsonObject>& obj) : FSetGameServerInstanceDataResult()
        {
            readFromValue(obj);
        }

        ~FSetGameServerInstanceDataResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FSetGameServerInstanceStateRequest : public FPlayFabBaseModel
    {
        // Unique identifier of the Game Instance to be updated, in decimal format.
        FString LobbyId;

        // State to set for the specified game server instance.
        GameInstanceState State;

        FSetGameServerInstanceStateRequest() :
            FPlayFabBaseModel(),
            LobbyId(),
            State()
            {}

        FSetGameServerInstanceStateRequest(const FSetGameServerInstanceStateRequest& src) :
            FPlayFabBaseModel(),
            LobbyId(src.LobbyId),
            State(src.State)
            {}

        FSetGameServerInstanceStateRequest(const TSharedPtr<FJsonObject>& obj) : FSetGameServerInstanceStateRequest()
        {
            readFromValue(obj);
        }

        ~FSetGameServerInstanceStateRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FSetGameServerInstanceStateResult : public FPlayFabBaseModel
    {
        FSetGameServerInstanceStateResult() :
            FPlayFabBaseModel()
            {}

        FSetGameServerInstanceStateResult(const FSetGameServerInstanceStateResult& src) :
            FPlayFabBaseModel()
            {}

        FSetGameServerInstanceStateResult(const TSharedPtr<FJsonObject>& obj) : FSetGameServerInstanceStateResult()
        {
            readFromValue(obj);
        }

        ~FSetGameServerInstanceStateResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FSetGameServerInstanceTagsRequest : public FPlayFabBaseModel
    {
        // Unique identifier of the Game Server Instance to be updated.
        FString LobbyId;

        /**
         * Tags to set for the specified Game Server Instance. Note that this is the complete list of tags to be associated with
         * the Game Server Instance.
         */
        TMap<FString, FString> Tags;
        FSetGameServerInstanceTagsRequest() :
            FPlayFabBaseModel(),
            LobbyId(),
            Tags()
            {}

        FSetGameServerInstanceTagsRequest(const FSetGameServerInstanceTagsRequest& src) :
            FPlayFabBaseModel(),
            LobbyId(src.LobbyId),
            Tags(src.Tags)
            {}

        FSetGameServerInstanceTagsRequest(const TSharedPtr<FJsonObject>& obj) : FSetGameServerInstanceTagsRequest()
        {
            readFromValue(obj);
        }

        ~FSetGameServerInstanceTagsRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FSetGameServerInstanceTagsResult : public FPlayFabBaseModel
    {
        FSetGameServerInstanceTagsResult() :
            FPlayFabBaseModel()
            {}

        FSetGameServerInstanceTagsResult(const FSetGameServerInstanceTagsResult& src) :
            FPlayFabBaseModel()
            {}

        FSetGameServerInstanceTagsResult(const TSharedPtr<FJsonObject>& obj) : FSetGameServerInstanceTagsResult()
        {
            readFromValue(obj);
        }

        ~FSetGameServerInstanceTagsResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FSetPlayerSecretRequest : public FPlayFabBaseModel
    {
        // Player secret that is used to verify API request signatures (Enterprise Only).
        FString PlayerSecret;

        // Unique PlayFab assigned ID of the user on whom the operation will be performed.
        FString PlayFabId;

        FSetPlayerSecretRequest() :
            FPlayFabBaseModel(),
            PlayerSecret(),
            PlayFabId()
            {}

        FSetPlayerSecretRequest(const FSetPlayerSecretRequest& src) :
            FPlayFabBaseModel(),
            PlayerSecret(src.PlayerSecret),
            PlayFabId(src.PlayFabId)
            {}

        FSetPlayerSecretRequest(const TSharedPtr<FJsonObject>& obj) : FSetPlayerSecretRequest()
        {
            readFromValue(obj);
        }

        ~FSetPlayerSecretRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FSetPlayerSecretResult : public FPlayFabBaseModel
    {
        FSetPlayerSecretResult() :
            FPlayFabBaseModel()
            {}

        FSetPlayerSecretResult(const FSetPlayerSecretResult& src) :
            FPlayFabBaseModel()
            {}

        FSetPlayerSecretResult(const TSharedPtr<FJsonObject>& obj) : FSetPlayerSecretResult()
        {
            readFromValue(obj);
        }

        ~FSetPlayerSecretResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FSetPublisherDataRequest : public FPlayFabBaseModel
    {
        /**
         * key we want to set a value on (note, this is additive - will only replace an existing key's value if they are the same
         * name.) Keys are trimmed of whitespace. Keys may not begin with the '!' character.
         */
        FString Key;

        // [optional] new value to set. Set to null to remove a value
        FString Value;

        FSetPublisherDataRequest() :
            FPlayFabBaseModel(),
            Key(),
            Value()
            {}

        FSetPublisherDataRequest(const FSetPublisherDataRequest& src) :
            FPlayFabBaseModel(),
            Key(src.Key),
            Value(src.Value)
            {}

        FSetPublisherDataRequest(const TSharedPtr<FJsonObject>& obj) : FSetPublisherDataRequest()
        {
            readFromValue(obj);
        }

        ~FSetPublisherDataRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FSetPublisherDataResult : public FPlayFabBaseModel
    {
        FSetPublisherDataResult() :
            FPlayFabBaseModel()
            {}

        FSetPublisherDataResult(const FSetPublisherDataResult& src) :
            FPlayFabBaseModel()
            {}

        FSetPublisherDataResult(const TSharedPtr<FJsonObject>& obj) : FSetPublisherDataResult()
        {
            readFromValue(obj);
        }

        ~FSetPublisherDataResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FSetTitleDataRequest : public FPlayFabBaseModel
    {
        /**
         * key we want to set a value on (note, this is additive - will only replace an existing key's value if they are the same
         * name.) Keys are trimmed of whitespace. Keys may not begin with the '!' character.
         */
        FString Key;

        // [optional] new value to set. Set to null to remove a value
        FString Value;

        FSetTitleDataRequest() :
            FPlayFabBaseModel(),
            Key(),
            Value()
            {}

        FSetTitleDataRequest(const FSetTitleDataRequest& src) :
            FPlayFabBaseModel(),
            Key(src.Key),
            Value(src.Value)
            {}

        FSetTitleDataRequest(const TSharedPtr<FJsonObject>& obj) : FSetTitleDataRequest()
        {
            readFromValue(obj);
        }

        ~FSetTitleDataRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FSetTitleDataResult : public FPlayFabBaseModel
    {
        FSetTitleDataResult() :
            FPlayFabBaseModel()
            {}

        FSetTitleDataResult(const FSetTitleDataResult& src) :
            FPlayFabBaseModel()
            {}

        FSetTitleDataResult(const TSharedPtr<FJsonObject>& obj) : FSetTitleDataResult()
        {
            readFromValue(obj);
        }

        ~FSetTitleDataResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FStatisticUpdate : public FPlayFabBaseModel
    {
        // unique name of the statistic
        FString StatisticName;

        // statistic value for the player
        int32 Value;

        /**
         * [optional] for updates to an existing statistic value for a player, the version of the statistic when it was loaded. Null when
         * setting the statistic value for the first time.
         */
        Boxed<uint32> Version;

        FStatisticUpdate() :
            FPlayFabBaseModel(),
            StatisticName(),
            Value(0),
            Version()
            {}

        FStatisticUpdate(const FStatisticUpdate& src) :
            FPlayFabBaseModel(),
            StatisticName(src.StatisticName),
            Value(src.Value),
            Version(src.Version)
            {}

        FStatisticUpdate(const TSharedPtr<FJsonObject>& obj) : FStatisticUpdate()
        {
            readFromValue(obj);
        }

        ~FStatisticUpdate();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FSubtractCharacterVirtualCurrencyRequest : public FPlayFabBaseModel
    {
        // Amount to be subtracted from the user balance of the specified virtual currency.
        int32 Amount;

        // Unique PlayFab assigned ID for a specific character owned by a user
        FString CharacterId;

        // Unique PlayFab assigned ID of the user on whom the operation will be performed.
        FString PlayFabId;

        // Name of the virtual currency which is to be decremented.
        FString VirtualCurrency;

        FSubtractCharacterVirtualCurrencyRequest() :
            FPlayFabBaseModel(),
            Amount(0),
            CharacterId(),
            PlayFabId(),
            VirtualCurrency()
            {}

        FSubtractCharacterVirtualCurrencyRequest(const FSubtractCharacterVirtualCurrencyRequest& src) :
            FPlayFabBaseModel(),
            Amount(src.Amount),
            CharacterId(src.CharacterId),
            PlayFabId(src.PlayFabId),
            VirtualCurrency(src.VirtualCurrency)
            {}

        FSubtractCharacterVirtualCurrencyRequest(const TSharedPtr<FJsonObject>& obj) : FSubtractCharacterVirtualCurrencyRequest()
        {
            readFromValue(obj);
        }

        ~FSubtractCharacterVirtualCurrencyRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FSubtractUserVirtualCurrencyRequest : public FPlayFabBaseModel
    {
        // Amount to be subtracted from the user balance of the specified virtual currency.
        int32 Amount;

        // PlayFab unique identifier of the user whose virtual currency balance is to be decreased.
        FString PlayFabId;

        // Name of the virtual currency which is to be decremented.
        FString VirtualCurrency;

        FSubtractUserVirtualCurrencyRequest() :
            FPlayFabBaseModel(),
            Amount(0),
            PlayFabId(),
            VirtualCurrency()
            {}

        FSubtractUserVirtualCurrencyRequest(const FSubtractUserVirtualCurrencyRequest& src) :
            FPlayFabBaseModel(),
            Amount(src.Amount),
            PlayFabId(src.PlayFabId),
            VirtualCurrency(src.VirtualCurrency)
            {}

        FSubtractUserVirtualCurrencyRequest(const TSharedPtr<FJsonObject>& obj) : FSubtractUserVirtualCurrencyRequest()
        {
            readFromValue(obj);
        }

        ~FSubtractUserVirtualCurrencyRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUnlockContainerInstanceRequest : public FPlayFabBaseModel
    {
        /**
         * [optional] Specifies the catalog version that should be used to determine container contents. If unspecified, uses catalog
         * associated with the item instance.
         */
        FString CatalogVersion;

        // [optional] Unique PlayFab assigned ID for a specific character owned by a user
        FString CharacterId;

        // ItemInstanceId of the container to unlock.
        FString ContainerItemInstanceId;

        /**
         * [optional] ItemInstanceId of the key that will be consumed by unlocking this container. If the container requires a key, this
         * parameter is required.
         */
        FString KeyItemInstanceId;

        // Unique PlayFab assigned ID of the user on whom the operation will be performed.
        FString PlayFabId;

        FUnlockContainerInstanceRequest() :
            FPlayFabBaseModel(),
            CatalogVersion(),
            CharacterId(),
            ContainerItemInstanceId(),
            KeyItemInstanceId(),
            PlayFabId()
            {}

        FUnlockContainerInstanceRequest(const FUnlockContainerInstanceRequest& src) :
            FPlayFabBaseModel(),
            CatalogVersion(src.CatalogVersion),
            CharacterId(src.CharacterId),
            ContainerItemInstanceId(src.ContainerItemInstanceId),
            KeyItemInstanceId(src.KeyItemInstanceId),
            PlayFabId(src.PlayFabId)
            {}

        FUnlockContainerInstanceRequest(const TSharedPtr<FJsonObject>& obj) : FUnlockContainerInstanceRequest()
        {
            readFromValue(obj);
        }

        ~FUnlockContainerInstanceRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUnlockContainerItemRequest : public FPlayFabBaseModel
    {
        /**
         * [optional] Specifies the catalog version that should be used to determine container contents. If unspecified, uses default/primary
         * catalog.
         */
        FString CatalogVersion;

        // [optional] Unique PlayFab assigned ID for a specific character owned by a user
        FString CharacterId;

        // Catalog ItemId of the container type to unlock.
        FString ContainerItemId;

        // Unique PlayFab assigned ID of the user on whom the operation will be performed.
        FString PlayFabId;

        FUnlockContainerItemRequest() :
            FPlayFabBaseModel(),
            CatalogVersion(),
            CharacterId(),
            ContainerItemId(),
            PlayFabId()
            {}

        FUnlockContainerItemRequest(const FUnlockContainerItemRequest& src) :
            FPlayFabBaseModel(),
            CatalogVersion(src.CatalogVersion),
            CharacterId(src.CharacterId),
            ContainerItemId(src.ContainerItemId),
            PlayFabId(src.PlayFabId)
            {}

        FUnlockContainerItemRequest(const TSharedPtr<FJsonObject>& obj) : FUnlockContainerItemRequest()
        {
            readFromValue(obj);
        }

        ~FUnlockContainerItemRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUnlockContainerItemResult : public FPlayFabBaseModel
    {
        // [optional] Items granted to the player as a result of unlocking the container.
        TArray<FItemInstance> GrantedItems;
        // [optional] Unique instance identifier of the container unlocked.
        FString UnlockedItemInstanceId;

        // [optional] Unique instance identifier of the key used to unlock the container, if applicable.
        FString UnlockedWithItemInstanceId;

        // [optional] Virtual currency granted to the player as a result of unlocking the container.
        TMap<FString, uint32> VirtualCurrency;
        FUnlockContainerItemResult() :
            FPlayFabBaseModel(),
            GrantedItems(),
            UnlockedItemInstanceId(),
            UnlockedWithItemInstanceId(),
            VirtualCurrency()
            {}

        FUnlockContainerItemResult(const FUnlockContainerItemResult& src) :
            FPlayFabBaseModel(),
            GrantedItems(src.GrantedItems),
            UnlockedItemInstanceId(src.UnlockedItemInstanceId),
            UnlockedWithItemInstanceId(src.UnlockedWithItemInstanceId),
            VirtualCurrency(src.VirtualCurrency)
            {}

        FUnlockContainerItemResult(const TSharedPtr<FJsonObject>& obj) : FUnlockContainerItemResult()
        {
            readFromValue(obj);
        }

        ~FUnlockContainerItemResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUpdateAvatarUrlRequest : public FPlayFabBaseModel
    {
        // URL of the avatar image. If empty, it removes the existing avatar URL.
        FString ImageUrl;

        // Unique PlayFab assigned ID of the user on whom the operation will be performed.
        FString PlayFabId;

        FUpdateAvatarUrlRequest() :
            FPlayFabBaseModel(),
            ImageUrl(),
            PlayFabId()
            {}

        FUpdateAvatarUrlRequest(const FUpdateAvatarUrlRequest& src) :
            FPlayFabBaseModel(),
            ImageUrl(src.ImageUrl),
            PlayFabId(src.PlayFabId)
            {}

        FUpdateAvatarUrlRequest(const TSharedPtr<FJsonObject>& obj) : FUpdateAvatarUrlRequest()
        {
            readFromValue(obj);
        }

        ~FUpdateAvatarUrlRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUpdateBanRequest : public FPlayFabBaseModel
    {
        // [optional] The updated active state for the ban. Null for no change.
        Boxed<bool> Active;

        // The id of the ban to be updated.
        FString BanId;

        // [optional] The updated expiration date for the ban. Null for no change.
        Boxed<FDateTime> Expires;

        // [optional] The updated IP address for the ban. Null for no change.
        FString IPAddress;

        // [optional] The updated MAC address for the ban. Null for no change.
        FString MACAddress;

        // [optional] Whether to make this ban permanent. Set to true to make this ban permanent. This will not modify Active state.
        Boxed<bool> Permanent;

        // [optional] The updated reason for the ban to be updated. Maximum 140 characters. Null for no change.
        FString Reason;

        FUpdateBanRequest() :
            FPlayFabBaseModel(),
            Active(),
            BanId(),
            Expires(),
            IPAddress(),
            MACAddress(),
            Permanent(),
            Reason()
            {}

        FUpdateBanRequest(const FUpdateBanRequest& src) :
            FPlayFabBaseModel(),
            Active(src.Active),
            BanId(src.BanId),
            Expires(src.Expires),
            IPAddress(src.IPAddress),
            MACAddress(src.MACAddress),
            Permanent(src.Permanent),
            Reason(src.Reason)
            {}

        FUpdateBanRequest(const TSharedPtr<FJsonObject>& obj) : FUpdateBanRequest()
        {
            readFromValue(obj);
        }

        ~FUpdateBanRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUpdateBansRequest : public FPlayFabBaseModel
    {
        // List of bans to be updated. Maximum 100.
        TArray<FUpdateBanRequest> Bans;
        FUpdateBansRequest() :
            FPlayFabBaseModel(),
            Bans()
            {}

        FUpdateBansRequest(const FUpdateBansRequest& src) :
            FPlayFabBaseModel(),
            Bans(src.Bans)
            {}

        FUpdateBansRequest(const TSharedPtr<FJsonObject>& obj) : FUpdateBansRequest()
        {
            readFromValue(obj);
        }

        ~FUpdateBansRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUpdateBansResult : public FPlayFabBaseModel
    {
        // [optional] Information on the bans that were updated
        TArray<FBanInfo> BanData;
        FUpdateBansResult() :
            FPlayFabBaseModel(),
            BanData()
            {}

        FUpdateBansResult(const FUpdateBansResult& src) :
            FPlayFabBaseModel(),
            BanData(src.BanData)
            {}

        FUpdateBansResult(const TSharedPtr<FJsonObject>& obj) : FUpdateBansResult()
        {
            readFromValue(obj);
        }

        ~FUpdateBansResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUpdateCharacterDataRequest : public FPlayFabBaseModel
    {
        // Unique PlayFab assigned ID for a specific character owned by a user
        FString CharacterId;

        /**
         * [optional] Key-value pairs to be written to the custom data. Note that keys are trimmed of whitespace, are limited in size, and may
         * not begin with a '!' character or be null.
         */
        TMap<FString, FString> Data;
        /**
         * [optional] Optional list of Data-keys to remove from UserData. Some SDKs cannot insert null-values into Data due to language
         * constraints. Use this to delete the keys directly.
         */
        TArray<FString> KeysToRemove;
        // [optional] Permission to be applied to all user data keys written in this request. Defaults to "private" if not set.
        Boxed<UserDataPermission> Permission;

        // Unique PlayFab assigned ID of the user on whom the operation will be performed.
        FString PlayFabId;

        FUpdateCharacterDataRequest() :
            FPlayFabBaseModel(),
            CharacterId(),
            Data(),
            KeysToRemove(),
            Permission(),
            PlayFabId()
            {}

        FUpdateCharacterDataRequest(const FUpdateCharacterDataRequest& src) :
            FPlayFabBaseModel(),
            CharacterId(src.CharacterId),
            Data(src.Data),
            KeysToRemove(src.KeysToRemove),
            Permission(src.Permission),
            PlayFabId(src.PlayFabId)
            {}

        FUpdateCharacterDataRequest(const TSharedPtr<FJsonObject>& obj) : FUpdateCharacterDataRequest()
        {
            readFromValue(obj);
        }

        ~FUpdateCharacterDataRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUpdateCharacterDataResult : public FPlayFabBaseModel
    {
        /**
         * Indicates the current version of the data that has been set. This is incremented with every set call for that type of
         * data (read-only, internal, etc). This version can be provided in Get calls to find updated data.
         */
        uint32 DataVersion;

        FUpdateCharacterDataResult() :
            FPlayFabBaseModel(),
            DataVersion(0)
            {}

        FUpdateCharacterDataResult(const FUpdateCharacterDataResult& src) :
            FPlayFabBaseModel(),
            DataVersion(src.DataVersion)
            {}

        FUpdateCharacterDataResult(const TSharedPtr<FJsonObject>& obj) : FUpdateCharacterDataResult()
        {
            readFromValue(obj);
        }

        ~FUpdateCharacterDataResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUpdateCharacterStatisticsRequest : public FPlayFabBaseModel
    {
        // Unique PlayFab assigned ID for a specific character owned by a user
        FString CharacterId;

        // [optional] Statistics to be updated with the provided values.
        TMap<FString, int32> CharacterStatistics;
        // Unique PlayFab assigned ID of the user on whom the operation will be performed.
        FString PlayFabId;

        FUpdateCharacterStatisticsRequest() :
            FPlayFabBaseModel(),
            CharacterId(),
            CharacterStatistics(),
            PlayFabId()
            {}

        FUpdateCharacterStatisticsRequest(const FUpdateCharacterStatisticsRequest& src) :
            FPlayFabBaseModel(),
            CharacterId(src.CharacterId),
            CharacterStatistics(src.CharacterStatistics),
            PlayFabId(src.PlayFabId)
            {}

        FUpdateCharacterStatisticsRequest(const TSharedPtr<FJsonObject>& obj) : FUpdateCharacterStatisticsRequest()
        {
            readFromValue(obj);
        }

        ~FUpdateCharacterStatisticsRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUpdateCharacterStatisticsResult : public FPlayFabBaseModel
    {
        FUpdateCharacterStatisticsResult() :
            FPlayFabBaseModel()
            {}

        FUpdateCharacterStatisticsResult(const FUpdateCharacterStatisticsResult& src) :
            FPlayFabBaseModel()
            {}

        FUpdateCharacterStatisticsResult(const TSharedPtr<FJsonObject>& obj) : FUpdateCharacterStatisticsResult()
        {
            readFromValue(obj);
        }

        ~FUpdateCharacterStatisticsResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUpdatePlayerStatisticsRequest : public FPlayFabBaseModel
    {
        /**
         * [optional] Indicates whether the statistics provided should be set, regardless of the aggregation method set on the statistic.
         * Default is false.
         */
        Boxed<bool> ForceUpdate;

        // Unique PlayFab assigned ID of the user on whom the operation will be performed.
        FString PlayFabId;

        // Statistics to be updated with the provided values
        TArray<FStatisticUpdate> Statistics;
        FUpdatePlayerStatisticsRequest() :
            FPlayFabBaseModel(),
            ForceUpdate(),
            PlayFabId(),
            Statistics()
            {}

        FUpdatePlayerStatisticsRequest(const FUpdatePlayerStatisticsRequest& src) :
            FPlayFabBaseModel(),
            ForceUpdate(src.ForceUpdate),
            PlayFabId(src.PlayFabId),
            Statistics(src.Statistics)
            {}

        FUpdatePlayerStatisticsRequest(const TSharedPtr<FJsonObject>& obj) : FUpdatePlayerStatisticsRequest()
        {
            readFromValue(obj);
        }

        ~FUpdatePlayerStatisticsRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUpdatePlayerStatisticsResult : public FPlayFabBaseModel
    {
        FUpdatePlayerStatisticsResult() :
            FPlayFabBaseModel()
            {}

        FUpdatePlayerStatisticsResult(const FUpdatePlayerStatisticsResult& src) :
            FPlayFabBaseModel()
            {}

        FUpdatePlayerStatisticsResult(const TSharedPtr<FJsonObject>& obj) : FUpdatePlayerStatisticsResult()
        {
            readFromValue(obj);
        }

        ~FUpdatePlayerStatisticsResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUpdateSharedGroupDataRequest : public FPlayFabBaseModel
    {
        /**
         * [optional] Key-value pairs to be written to the custom data. Note that keys are trimmed of whitespace, are limited in size, and may
         * not begin with a '!' character or be null.
         */
        TMap<FString, FString> Data;
        /**
         * [optional] Optional list of Data-keys to remove from UserData. Some SDKs cannot insert null-values into Data due to language
         * constraints. Use this to delete the keys directly.
         */
        TArray<FString> KeysToRemove;
        // [optional] Permission to be applied to all user data keys in this request.
        Boxed<UserDataPermission> Permission;

        // Unique identifier for the shared group.
        FString SharedGroupId;

        FUpdateSharedGroupDataRequest() :
            FPlayFabBaseModel(),
            Data(),
            KeysToRemove(),
            Permission(),
            SharedGroupId()
            {}

        FUpdateSharedGroupDataRequest(const FUpdateSharedGroupDataRequest& src) :
            FPlayFabBaseModel(),
            Data(src.Data),
            KeysToRemove(src.KeysToRemove),
            Permission(src.Permission),
            SharedGroupId(src.SharedGroupId)
            {}

        FUpdateSharedGroupDataRequest(const TSharedPtr<FJsonObject>& obj) : FUpdateSharedGroupDataRequest()
        {
            readFromValue(obj);
        }

        ~FUpdateSharedGroupDataRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUpdateSharedGroupDataResult : public FPlayFabBaseModel
    {
        FUpdateSharedGroupDataResult() :
            FPlayFabBaseModel()
            {}

        FUpdateSharedGroupDataResult(const FUpdateSharedGroupDataResult& src) :
            FPlayFabBaseModel()
            {}

        FUpdateSharedGroupDataResult(const TSharedPtr<FJsonObject>& obj) : FUpdateSharedGroupDataResult()
        {
            readFromValue(obj);
        }

        ~FUpdateSharedGroupDataResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUpdateUserDataRequest : public FPlayFabBaseModel
    {
        /**
         * [optional] Key-value pairs to be written to the custom data. Note that keys are trimmed of whitespace, are limited in size, and may
         * not begin with a '!' character or be null.
         */
        TMap<FString, FString> Data;
        /**
         * [optional] Optional list of Data-keys to remove from UserData. Some SDKs cannot insert null-values into Data due to language
         * constraints. Use this to delete the keys directly.
         */
        TArray<FString> KeysToRemove;
        // [optional] Permission to be applied to all user data keys written in this request. Defaults to "private" if not set.
        Boxed<UserDataPermission> Permission;

        // Unique PlayFab assigned ID of the user on whom the operation will be performed.
        FString PlayFabId;

        FUpdateUserDataRequest() :
            FPlayFabBaseModel(),
            Data(),
            KeysToRemove(),
            Permission(),
            PlayFabId()
            {}

        FUpdateUserDataRequest(const FUpdateUserDataRequest& src) :
            FPlayFabBaseModel(),
            Data(src.Data),
            KeysToRemove(src.KeysToRemove),
            Permission(src.Permission),
            PlayFabId(src.PlayFabId)
            {}

        FUpdateUserDataRequest(const TSharedPtr<FJsonObject>& obj) : FUpdateUserDataRequest()
        {
            readFromValue(obj);
        }

        ~FUpdateUserDataRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUpdateUserDataResult : public FPlayFabBaseModel
    {
        /**
         * Indicates the current version of the data that has been set. This is incremented with every set call for that type of
         * data (read-only, internal, etc). This version can be provided in Get calls to find updated data.
         */
        uint32 DataVersion;

        FUpdateUserDataResult() :
            FPlayFabBaseModel(),
            DataVersion(0)
            {}

        FUpdateUserDataResult(const FUpdateUserDataResult& src) :
            FPlayFabBaseModel(),
            DataVersion(src.DataVersion)
            {}

        FUpdateUserDataResult(const TSharedPtr<FJsonObject>& obj) : FUpdateUserDataResult()
        {
            readFromValue(obj);
        }

        ~FUpdateUserDataResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUpdateUserInternalDataRequest : public FPlayFabBaseModel
    {
        /**
         * [optional] Key-value pairs to be written to the custom data. Note that keys are trimmed of whitespace, are limited in size, and may
         * not begin with a '!' character or be null.
         */
        TMap<FString, FString> Data;
        /**
         * [optional] Optional list of Data-keys to remove from UserData. Some SDKs cannot insert null-values into Data due to language
         * constraints. Use this to delete the keys directly.
         */
        TArray<FString> KeysToRemove;
        // Unique PlayFab assigned ID of the user on whom the operation will be performed.
        FString PlayFabId;

        FUpdateUserInternalDataRequest() :
            FPlayFabBaseModel(),
            Data(),
            KeysToRemove(),
            PlayFabId()
            {}

        FUpdateUserInternalDataRequest(const FUpdateUserInternalDataRequest& src) :
            FPlayFabBaseModel(),
            Data(src.Data),
            KeysToRemove(src.KeysToRemove),
            PlayFabId(src.PlayFabId)
            {}

        FUpdateUserInternalDataRequest(const TSharedPtr<FJsonObject>& obj) : FUpdateUserInternalDataRequest()
        {
            readFromValue(obj);
        }

        ~FUpdateUserInternalDataRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUpdateUserInventoryItemDataRequest : public FPlayFabBaseModel
    {
        // [optional] Unique PlayFab assigned ID for a specific character owned by a user
        FString CharacterId;

        /**
         * [optional] Key-value pairs to be written to the custom data. Note that keys are trimmed of whitespace, are limited in size, and may
         * not begin with a '!' character or be null.
         */
        TMap<FString, FString> Data;
        // Unique PlayFab assigned instance identifier of the item
        FString ItemInstanceId;

        /**
         * [optional] Optional list of Data-keys to remove from UserData. Some SDKs cannot insert null-values into Data due to language
         * constraints. Use this to delete the keys directly.
         */
        TArray<FString> KeysToRemove;
        // Unique PlayFab assigned ID of the user on whom the operation will be performed.
        FString PlayFabId;

        FUpdateUserInventoryItemDataRequest() :
            FPlayFabBaseModel(),
            CharacterId(),
            Data(),
            ItemInstanceId(),
            KeysToRemove(),
            PlayFabId()
            {}

        FUpdateUserInventoryItemDataRequest(const FUpdateUserInventoryItemDataRequest& src) :
            FPlayFabBaseModel(),
            CharacterId(src.CharacterId),
            Data(src.Data),
            ItemInstanceId(src.ItemInstanceId),
            KeysToRemove(src.KeysToRemove),
            PlayFabId(src.PlayFabId)
            {}

        FUpdateUserInventoryItemDataRequest(const TSharedPtr<FJsonObject>& obj) : FUpdateUserInventoryItemDataRequest()
        {
            readFromValue(obj);
        }

        ~FUpdateUserInventoryItemDataRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FWriteEventResponse : public FPlayFabBaseModel
    {
        /**
         * [optional] The unique identifier of the event. The values of this identifier consist of ASCII characters and are not constrained to
         * any particular format.
         */
        FString EventId;

        FWriteEventResponse() :
            FPlayFabBaseModel(),
            EventId()
            {}

        FWriteEventResponse(const FWriteEventResponse& src) :
            FPlayFabBaseModel(),
            EventId(src.EventId)
            {}

        FWriteEventResponse(const TSharedPtr<FJsonObject>& obj) : FWriteEventResponse()
        {
            readFromValue(obj);
        }

        ~FWriteEventResponse();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FWriteServerCharacterEventRequest : public FPlayFabBaseModel
    {
        // [optional] Custom event properties. Each property consists of a name (string) and a value (JSON object).
        TMap<FString, FJsonKeeper> Body;
        // Unique PlayFab assigned ID for a specific character owned by a user
        FString CharacterId;

        /**
         * The name of the event, within the namespace scoped to the title. The naming convention is up to the caller, but it
         * commonly follows the subject_verb_object pattern (e.g. player_logged_in).
         */
        FString EventName;

        // Unique PlayFab assigned ID of the user on whom the operation will be performed.
        FString PlayFabId;

        // [optional] The time (in UTC) associated with this event. The value dafaults to the current time.
        Boxed<FDateTime> Timestamp;

        FWriteServerCharacterEventRequest() :
            FPlayFabBaseModel(),
            Body(),
            CharacterId(),
            EventName(),
            PlayFabId(),
            Timestamp()
            {}

        FWriteServerCharacterEventRequest(const FWriteServerCharacterEventRequest& src) :
            FPlayFabBaseModel(),
            Body(src.Body),
            CharacterId(src.CharacterId),
            EventName(src.EventName),
            PlayFabId(src.PlayFabId),
            Timestamp(src.Timestamp)
            {}

        FWriteServerCharacterEventRequest(const TSharedPtr<FJsonObject>& obj) : FWriteServerCharacterEventRequest()
        {
            readFromValue(obj);
        }

        ~FWriteServerCharacterEventRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FWriteServerPlayerEventRequest : public FPlayFabBaseModel
    {
        // [optional] Custom data properties associated with the event. Each property consists of a name (string) and a value (JSON object).
        TMap<FString, FJsonKeeper> Body;
        /**
         * The name of the event, within the namespace scoped to the title. The naming convention is up to the caller, but it
         * commonly follows the subject_verb_object pattern (e.g. player_logged_in).
         */
        FString EventName;

        // Unique PlayFab assigned ID of the user on whom the operation will be performed.
        FString PlayFabId;

        // [optional] The time (in UTC) associated with this event. The value dafaults to the current time.
        Boxed<FDateTime> Timestamp;

        FWriteServerPlayerEventRequest() :
            FPlayFabBaseModel(),
            Body(),
            EventName(),
            PlayFabId(),
            Timestamp()
            {}

        FWriteServerPlayerEventRequest(const FWriteServerPlayerEventRequest& src) :
            FPlayFabBaseModel(),
            Body(src.Body),
            EventName(src.EventName),
            PlayFabId(src.PlayFabId),
            Timestamp(src.Timestamp)
            {}

        FWriteServerPlayerEventRequest(const TSharedPtr<FJsonObject>& obj) : FWriteServerPlayerEventRequest()
        {
            readFromValue(obj);
        }

        ~FWriteServerPlayerEventRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FWriteTitleEventRequest : public FPlayFabBaseModel
    {
        // [optional] Custom event properties. Each property consists of a name (string) and a value (JSON object).
        TMap<FString, FJsonKeeper> Body;
        /**
         * The name of the event, within the namespace scoped to the title. The naming convention is up to the caller, but it
         * commonly follows the subject_verb_object pattern (e.g. player_logged_in).
         */
        FString EventName;

        // [optional] The time (in UTC) associated with this event. The value dafaults to the current time.
        Boxed<FDateTime> Timestamp;

        FWriteTitleEventRequest() :
            FPlayFabBaseModel(),
            Body(),
            EventName(),
            Timestamp()
            {}

        FWriteTitleEventRequest(const FWriteTitleEventRequest& src) :
            FPlayFabBaseModel(),
            Body(src.Body),
            EventName(src.EventName),
            Timestamp(src.Timestamp)
            {}

        FWriteTitleEventRequest(const TSharedPtr<FJsonObject>& obj) : FWriteTitleEventRequest()
        {
            readFromValue(obj);
        }

        ~FWriteTitleEventRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

}
}
