// This is automatically generated by PlayFab SDKGenerator. DO NOT modify this manually!
#pragma once

#include "CoreMinimal.h"
#include "Core/PlayFabBaseModel.h"

namespace PlayFab
{
namespace EntityModels
{

    enum EntityTypes
    {
        EntityTypestitle,
        EntityTypesmaster_player_account,
        EntityTypestitle_player_account,
        EntityTypescharacter,
        EntityTypesgroup
    };

    PLAYFAB_API void writeEntityTypesEnumJSON(EntityTypes enumVal, JsonWriter& writer);
    PLAYFAB_API EntityTypes readEntityTypesFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFAB_API EntityTypes readEntityTypesFromValue(const FString& value);

    struct PLAYFAB_API FEntityKey : public FPlayFabBaseModel
    {
        // Entity profile ID.
        FString Id;

        // [optional] Entity type. Optional to be used but one of EntityType or EntityTypeString must be set.
        Boxed<EntityTypes> Type;

        // [optional] Entity type. Optional to be used but one of EntityType or EntityTypeString must be set.
        FString TypeString;

        FEntityKey() :
            FPlayFabBaseModel(),
            Id(),
            Type(),
            TypeString()
            {}

        FEntityKey(const FEntityKey& src) :
            FPlayFabBaseModel(),
            Id(src.Id),
            Type(src.Type),
            TypeString(src.TypeString)
            {}

        FEntityKey(const TSharedPtr<FJsonObject>& obj) : FEntityKey()
        {
            readFromValue(obj);
        }

        ~FEntityKey();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FAbortFileUploadsRequest : public FPlayFabBaseModel
    {
        // The entity to perform this action on.
        FEntityKey Entity;

        // Names of the files to have their pending uploads aborted.
        TArray<FString> FileNames;
        /**
         * [optional] The expected version of the profile, if set and doesn't match the current version of the profile the operation will not
         * be performed.
         */
        Boxed<int32> ProfileVersion;

        FAbortFileUploadsRequest() :
            FPlayFabBaseModel(),
            Entity(),
            FileNames(),
            ProfileVersion()
            {}

        FAbortFileUploadsRequest(const FAbortFileUploadsRequest& src) :
            FPlayFabBaseModel(),
            Entity(src.Entity),
            FileNames(src.FileNames),
            ProfileVersion(src.ProfileVersion)
            {}

        FAbortFileUploadsRequest(const TSharedPtr<FJsonObject>& obj) : FAbortFileUploadsRequest()
        {
            readFromValue(obj);
        }

        ~FAbortFileUploadsRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FAbortFileUploadsResponse : public FPlayFabBaseModel
    {
        // [optional] The entity id and type.
        TSharedPtr<FEntityKey> Entity;

        // The current version of the profile, can be used for concurrency control during updates.
        int32 ProfileVersion;

        FAbortFileUploadsResponse() :
            FPlayFabBaseModel(),
            Entity(nullptr),
            ProfileVersion(0)
            {}

        FAbortFileUploadsResponse(const FAbortFileUploadsResponse& src) :
            FPlayFabBaseModel(),
            Entity(src.Entity.IsValid() ? MakeShareable(new FEntityKey(*src.Entity)) : nullptr),
            ProfileVersion(src.ProfileVersion)
            {}

        FAbortFileUploadsResponse(const TSharedPtr<FJsonObject>& obj) : FAbortFileUploadsResponse()
        {
            readFromValue(obj);
        }

        ~FAbortFileUploadsResponse();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FAcceptGroupApplicationRequest : public FPlayFabBaseModel
    {
        /**
         * Optional. Type of the entity to accept as. If specified, must be the same entity as the claimant or an entity that is a
         * child of the claimant entity. Defaults to the claimant entity.
         */
        FEntityKey Entity;

        // The identifier of the group
        FEntityKey Group;

        FAcceptGroupApplicationRequest() :
            FPlayFabBaseModel(),
            Entity(),
            Group()
            {}

        FAcceptGroupApplicationRequest(const FAcceptGroupApplicationRequest& src) :
            FPlayFabBaseModel(),
            Entity(src.Entity),
            Group(src.Group)
            {}

        FAcceptGroupApplicationRequest(const TSharedPtr<FJsonObject>& obj) : FAcceptGroupApplicationRequest()
        {
            readFromValue(obj);
        }

        ~FAcceptGroupApplicationRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FAcceptGroupInvitationRequest : public FPlayFabBaseModel
    {
        // [optional] The entity to perform this action on.
        TSharedPtr<FEntityKey> Entity;

        // The identifier of the group
        FEntityKey Group;

        FAcceptGroupInvitationRequest() :
            FPlayFabBaseModel(),
            Entity(nullptr),
            Group()
            {}

        FAcceptGroupInvitationRequest(const FAcceptGroupInvitationRequest& src) :
            FPlayFabBaseModel(),
            Entity(src.Entity.IsValid() ? MakeShareable(new FEntityKey(*src.Entity)) : nullptr),
            Group(src.Group)
            {}

        FAcceptGroupInvitationRequest(const TSharedPtr<FJsonObject>& obj) : FAcceptGroupInvitationRequest()
        {
            readFromValue(obj);
        }

        ~FAcceptGroupInvitationRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FAddMembersRequest : public FPlayFabBaseModel
    {
        // The identifier of the group
        FEntityKey Group;

        // List of entities to add to the group. Only entities of type title_player_account and character may be added to groups.
        TArray<FEntityKey> Members;
        /**
         * [optional] Optional: The ID of the existing role to add the entities to. If this is not specified, the default member role for the
         * group will be used. Role IDs must be between 1 and 64 characters long.
         */
        FString RoleId;

        FAddMembersRequest() :
            FPlayFabBaseModel(),
            Group(),
            Members(),
            RoleId()
            {}

        FAddMembersRequest(const FAddMembersRequest& src) :
            FPlayFabBaseModel(),
            Group(src.Group),
            Members(src.Members),
            RoleId(src.RoleId)
            {}

        FAddMembersRequest(const TSharedPtr<FJsonObject>& obj) : FAddMembersRequest()
        {
            readFromValue(obj);
        }

        ~FAddMembersRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FApplyToGroupRequest : public FPlayFabBaseModel
    {
        // [optional] Optional, default true. Automatically accept an outstanding invitation if one exists instead of creating an application
        Boxed<bool> AutoAcceptOutstandingInvite;

        // [optional] The entity to perform this action on.
        TSharedPtr<FEntityKey> Entity;

        // The identifier of the group
        FEntityKey Group;

        FApplyToGroupRequest() :
            FPlayFabBaseModel(),
            AutoAcceptOutstandingInvite(),
            Entity(nullptr),
            Group()
            {}

        FApplyToGroupRequest(const FApplyToGroupRequest& src) :
            FPlayFabBaseModel(),
            AutoAcceptOutstandingInvite(src.AutoAcceptOutstandingInvite),
            Entity(src.Entity.IsValid() ? MakeShareable(new FEntityKey(*src.Entity)) : nullptr),
            Group(src.Group)
            {}

        FApplyToGroupRequest(const TSharedPtr<FJsonObject>& obj) : FApplyToGroupRequest()
        {
            readFromValue(obj);
        }

        ~FApplyToGroupRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FEntityWithLineage : public FPlayFabBaseModel
    {
        // [optional] The entity key for the specified entity
        TSharedPtr<FEntityKey> Key;

        // [optional] Dictionary of entity keys for related entities. Dictionary key is entity type.
        TMap<FString, FEntityKey> Lineage;
        FEntityWithLineage() :
            FPlayFabBaseModel(),
            Key(nullptr),
            Lineage()
            {}

        FEntityWithLineage(const FEntityWithLineage& src) :
            FPlayFabBaseModel(),
            Key(src.Key.IsValid() ? MakeShareable(new FEntityKey(*src.Key)) : nullptr),
            Lineage(src.Lineage)
            {}

        FEntityWithLineage(const TSharedPtr<FJsonObject>& obj) : FEntityWithLineage()
        {
            readFromValue(obj);
        }

        ~FEntityWithLineage();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FApplyToGroupResponse : public FPlayFabBaseModel
    {
        // [optional] Type of entity that requested membership
        TSharedPtr<FEntityWithLineage> Entity;

        // When the application to join will expire and be deleted
        FDateTime Expires;

        // [optional] ID of the group that the entity requesting membership to
        TSharedPtr<FEntityKey> Group;

        FApplyToGroupResponse() :
            FPlayFabBaseModel(),
            Entity(nullptr),
            Expires(0),
            Group(nullptr)
            {}

        FApplyToGroupResponse(const FApplyToGroupResponse& src) :
            FPlayFabBaseModel(),
            Entity(src.Entity.IsValid() ? MakeShareable(new FEntityWithLineage(*src.Entity)) : nullptr),
            Expires(src.Expires),
            Group(src.Group.IsValid() ? MakeShareable(new FEntityKey(*src.Group)) : nullptr)
            {}

        FApplyToGroupResponse(const TSharedPtr<FJsonObject>& obj) : FApplyToGroupResponse()
        {
            readFromValue(obj);
        }

        ~FApplyToGroupResponse();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FBlockEntityRequest : public FPlayFabBaseModel
    {
        // The entity to perform this action on.
        FEntityKey Entity;

        // The identifier of the group
        FEntityKey Group;

        FBlockEntityRequest() :
            FPlayFabBaseModel(),
            Entity(),
            Group()
            {}

        FBlockEntityRequest(const FBlockEntityRequest& src) :
            FPlayFabBaseModel(),
            Entity(src.Entity),
            Group(src.Group)
            {}

        FBlockEntityRequest(const TSharedPtr<FJsonObject>& obj) : FBlockEntityRequest()
        {
            readFromValue(obj);
        }

        ~FBlockEntityRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FChangeMemberRoleRequest : public FPlayFabBaseModel
    {
        /**
         * [optional] The ID of the role that the entities will become a member of. This must be an existing role. Role IDs must be between 1
         * and 64 characters long.
         */
        FString DestinationRoleId;

        // The identifier of the group
        FEntityKey Group;

        /**
         * List of entities to move between roles in the group. All entities in this list must be members of the group and origin
         * role.
         */
        TArray<FEntityKey> Members;
        // The ID of the role that the entities currently are a member of. Role IDs must be between 1 and 64 characters long.
        FString OriginRoleId;

        FChangeMemberRoleRequest() :
            FPlayFabBaseModel(),
            DestinationRoleId(),
            Group(),
            Members(),
            OriginRoleId()
            {}

        FChangeMemberRoleRequest(const FChangeMemberRoleRequest& src) :
            FPlayFabBaseModel(),
            DestinationRoleId(src.DestinationRoleId),
            Group(src.Group),
            Members(src.Members),
            OriginRoleId(src.OriginRoleId)
            {}

        FChangeMemberRoleRequest(const TSharedPtr<FJsonObject>& obj) : FChangeMemberRoleRequest()
        {
            readFromValue(obj);
        }

        ~FChangeMemberRoleRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FCreateGroupRequest : public FPlayFabBaseModel
    {
        // [optional] The entity to perform this action on.
        TSharedPtr<FEntityKey> Entity;

        // The name of the group. This is unique at the title level by default.
        FString GroupName;

        FCreateGroupRequest() :
            FPlayFabBaseModel(),
            Entity(nullptr),
            GroupName()
            {}

        FCreateGroupRequest(const FCreateGroupRequest& src) :
            FPlayFabBaseModel(),
            Entity(src.Entity.IsValid() ? MakeShareable(new FEntityKey(*src.Entity)) : nullptr),
            GroupName(src.GroupName)
            {}

        FCreateGroupRequest(const TSharedPtr<FJsonObject>& obj) : FCreateGroupRequest()
        {
            readFromValue(obj);
        }

        ~FCreateGroupRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FCreateGroupResponse : public FPlayFabBaseModel
    {
        // [optional] The ID of the administrator role for the group.
        FString AdminRoleId;

        // The server date and time the group was created.
        FDateTime Created;

        // The identifier of the group
        FEntityKey Group;

        // [optional] The name of the group.
        FString GroupName;

        // [optional] The ID of the default member role for the group.
        FString MemberRoleId;

        // The current version of the profile, can be used for concurrency control during updates.
        int32 ProfileVersion;

        // [optional] The list of roles and names that belong to the group.
        TMap<FString, FString> Roles;
        FCreateGroupResponse() :
            FPlayFabBaseModel(),
            AdminRoleId(),
            Created(0),
            Group(),
            GroupName(),
            MemberRoleId(),
            ProfileVersion(0),
            Roles()
            {}

        FCreateGroupResponse(const FCreateGroupResponse& src) :
            FPlayFabBaseModel(),
            AdminRoleId(src.AdminRoleId),
            Created(src.Created),
            Group(src.Group),
            GroupName(src.GroupName),
            MemberRoleId(src.MemberRoleId),
            ProfileVersion(src.ProfileVersion),
            Roles(src.Roles)
            {}

        FCreateGroupResponse(const TSharedPtr<FJsonObject>& obj) : FCreateGroupResponse()
        {
            readFromValue(obj);
        }

        ~FCreateGroupResponse();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FCreateGroupRoleRequest : public FPlayFabBaseModel
    {
        // The identifier of the group
        FEntityKey Group;

        /**
         * The ID of the role. This must be unique within the group and cannot be changed. Role IDs must be between 1 and 64
         * characters long.
         */
        FString RoleId;

        /**
         * The name of the role. This must be unique within the group and can be changed later. Role names must be between 1 and
         * 100 characters long
         */
        FString RoleName;

        FCreateGroupRoleRequest() :
            FPlayFabBaseModel(),
            Group(),
            RoleId(),
            RoleName()
            {}

        FCreateGroupRoleRequest(const FCreateGroupRoleRequest& src) :
            FPlayFabBaseModel(),
            Group(src.Group),
            RoleId(src.RoleId),
            RoleName(src.RoleName)
            {}

        FCreateGroupRoleRequest(const TSharedPtr<FJsonObject>& obj) : FCreateGroupRoleRequest()
        {
            readFromValue(obj);
        }

        ~FCreateGroupRoleRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FCreateGroupRoleResponse : public FPlayFabBaseModel
    {
        // The current version of the group profile, can be used for concurrency control during updates.
        int32 ProfileVersion;

        // [optional] ID for the role
        FString RoleId;

        // [optional] The name of the role
        FString RoleName;

        FCreateGroupRoleResponse() :
            FPlayFabBaseModel(),
            ProfileVersion(0),
            RoleId(),
            RoleName()
            {}

        FCreateGroupRoleResponse(const FCreateGroupRoleResponse& src) :
            FPlayFabBaseModel(),
            ProfileVersion(src.ProfileVersion),
            RoleId(src.RoleId),
            RoleName(src.RoleName)
            {}

        FCreateGroupRoleResponse(const TSharedPtr<FJsonObject>& obj) : FCreateGroupRoleResponse()
        {
            readFromValue(obj);
        }

        ~FCreateGroupRoleResponse();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FDeleteFilesRequest : public FPlayFabBaseModel
    {
        // The entity to perform this action on.
        FEntityKey Entity;

        // Names of the files to be deleted.
        TArray<FString> FileNames;
        /**
         * [optional] The expected version of the profile, if set and doesn't match the current version of the profile the operation will not
         * be performed.
         */
        Boxed<int32> ProfileVersion;

        FDeleteFilesRequest() :
            FPlayFabBaseModel(),
            Entity(),
            FileNames(),
            ProfileVersion()
            {}

        FDeleteFilesRequest(const FDeleteFilesRequest& src) :
            FPlayFabBaseModel(),
            Entity(src.Entity),
            FileNames(src.FileNames),
            ProfileVersion(src.ProfileVersion)
            {}

        FDeleteFilesRequest(const TSharedPtr<FJsonObject>& obj) : FDeleteFilesRequest()
        {
            readFromValue(obj);
        }

        ~FDeleteFilesRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FDeleteFilesResponse : public FPlayFabBaseModel
    {
        // [optional] The entity id and type.
        TSharedPtr<FEntityKey> Entity;

        // The current version of the profile, can be used for concurrency control during updates.
        int32 ProfileVersion;

        FDeleteFilesResponse() :
            FPlayFabBaseModel(),
            Entity(nullptr),
            ProfileVersion(0)
            {}

        FDeleteFilesResponse(const FDeleteFilesResponse& src) :
            FPlayFabBaseModel(),
            Entity(src.Entity.IsValid() ? MakeShareable(new FEntityKey(*src.Entity)) : nullptr),
            ProfileVersion(src.ProfileVersion)
            {}

        FDeleteFilesResponse(const TSharedPtr<FJsonObject>& obj) : FDeleteFilesResponse()
        {
            readFromValue(obj);
        }

        ~FDeleteFilesResponse();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FDeleteGroupRequest : public FPlayFabBaseModel
    {
        // ID of the group or role to remove
        FEntityKey Group;

        FDeleteGroupRequest() :
            FPlayFabBaseModel(),
            Group()
            {}

        FDeleteGroupRequest(const FDeleteGroupRequest& src) :
            FPlayFabBaseModel(),
            Group(src.Group)
            {}

        FDeleteGroupRequest(const TSharedPtr<FJsonObject>& obj) : FDeleteGroupRequest()
        {
            readFromValue(obj);
        }

        ~FDeleteGroupRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FDeleteRoleRequest : public FPlayFabBaseModel
    {
        // The identifier of the group
        FEntityKey Group;

        // [optional] The ID of the role to delete. Role IDs must be between 1 and 64 characters long.
        FString RoleId;

        FDeleteRoleRequest() :
            FPlayFabBaseModel(),
            Group(),
            RoleId()
            {}

        FDeleteRoleRequest(const FDeleteRoleRequest& src) :
            FPlayFabBaseModel(),
            Group(src.Group),
            RoleId(src.RoleId)
            {}

        FDeleteRoleRequest(const TSharedPtr<FJsonObject>& obj) : FDeleteRoleRequest()
        {
            readFromValue(obj);
        }

        ~FDeleteRoleRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    enum EffectType
    {
        EffectTypeAllow,
        EffectTypeDeny
    };

    PLAYFAB_API void writeEffectTypeEnumJSON(EffectType enumVal, JsonWriter& writer);
    PLAYFAB_API EffectType readEffectTypeFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFAB_API EffectType readEffectTypeFromValue(const FString& value);

    struct PLAYFAB_API FEmptyResult : public FPlayFabBaseModel
    {
        FEmptyResult() :
            FPlayFabBaseModel()
            {}

        FEmptyResult(const FEmptyResult& src) :
            FPlayFabBaseModel()
            {}

        FEmptyResult(const TSharedPtr<FJsonObject>& obj) : FEmptyResult()
        {
            readFromValue(obj);
        }

        ~FEmptyResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FEntityDataObject : public FPlayFabBaseModel
    {
        // [optional] Un-escaped JSON object, if DataAsObject is true.
        FJsonKeeper DataObject;

        // [optional] Escaped string JSON body of the object, if DataAsObject is default or false.
        FString EscapedDataObject;

        // [optional] Name of this object.
        FString ObjectName;

        FEntityDataObject() :
            FPlayFabBaseModel(),
            DataObject(),
            EscapedDataObject(),
            ObjectName()
            {}

        FEntityDataObject(const FEntityDataObject& src) :
            FPlayFabBaseModel(),
            DataObject(src.DataObject),
            EscapedDataObject(src.EscapedDataObject),
            ObjectName(src.ObjectName)
            {}

        FEntityDataObject(const TSharedPtr<FJsonObject>& obj) : FEntityDataObject()
        {
            readFromValue(obj);
        }

        ~FEntityDataObject();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FEntityMemberRole : public FPlayFabBaseModel
    {
        // [optional] The list of members in the role
        TArray<FEntityWithLineage> Members;
        // [optional] The ID of the role.
        FString RoleId;

        // [optional] The name of the role
        FString RoleName;

        FEntityMemberRole() :
            FPlayFabBaseModel(),
            Members(),
            RoleId(),
            RoleName()
            {}

        FEntityMemberRole(const FEntityMemberRole& src) :
            FPlayFabBaseModel(),
            Members(src.Members),
            RoleId(src.RoleId),
            RoleName(src.RoleName)
            {}

        FEntityMemberRole(const TSharedPtr<FJsonObject>& obj) : FEntityMemberRole()
        {
            readFromValue(obj);
        }

        ~FEntityMemberRole();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FEntityPermissionStatement : public FPlayFabBaseModel
    {
        // The action this statement effects. May be 'Read', 'Write' or '*' for both read and write.
        FString Action;

        // [optional] A comment about the statement. Intended solely for bookkeeping and debugging.
        FString Comment;

        // [optional] Additional conditions to be applied for entity resources.
        FJsonKeeper Condition;

        // The effect this statement will have. It may be either Allow or Deny
        EffectType Effect;

        // The principal this statement will effect.
        FJsonKeeper Principal;

        // The resource this statements effects. Similar to 'pfrn:data--title![Title ID]/Profile/*'
        FString Resource;

        FEntityPermissionStatement() :
            FPlayFabBaseModel(),
            Action(),
            Comment(),
            Condition(),
            Effect(),
            Principal(),
            Resource()
            {}

        FEntityPermissionStatement(const FEntityPermissionStatement& src) :
            FPlayFabBaseModel(),
            Action(src.Action),
            Comment(src.Comment),
            Condition(src.Condition),
            Effect(src.Effect),
            Principal(src.Principal),
            Resource(src.Resource)
            {}

        FEntityPermissionStatement(const TSharedPtr<FJsonObject>& obj) : FEntityPermissionStatement()
        {
            readFromValue(obj);
        }

        ~FEntityPermissionStatement();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FEntityProfileFileMetadata : public FPlayFabBaseModel
    {
        // [optional] Checksum value for the file
        FString Checksum;

        // [optional] Name of the file
        FString FileName;

        // Last UTC time the file was modified
        FDateTime LastModified;

        // Storage service's reported byte count
        int32 Size;

        FEntityProfileFileMetadata() :
            FPlayFabBaseModel(),
            Checksum(),
            FileName(),
            LastModified(0),
            Size(0)
            {}

        FEntityProfileFileMetadata(const FEntityProfileFileMetadata& src) :
            FPlayFabBaseModel(),
            Checksum(src.Checksum),
            FileName(src.FileName),
            LastModified(src.LastModified),
            Size(src.Size)
            {}

        FEntityProfileFileMetadata(const TSharedPtr<FJsonObject>& obj) : FEntityProfileFileMetadata()
        {
            readFromValue(obj);
        }

        ~FEntityProfileFileMetadata();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FEntityProfileBody : public FPlayFabBaseModel
    {
        // [optional] The entity id and type.
        TSharedPtr<FEntityKey> Entity;

        /**
         * [optional] The chain of responsibility for this entity. This is a representation of 'ownership'. It is constructed using the
         * following formats (replace '[ID]' with the unique identifier for the given entity): Namespace: 'namespace![Namespace
         * ID]' Title: 'title![Namespace ID]/[Title ID]' Master Player Account: 'master_player_account![Namespace
         * ID]/[MasterPlayerAccount ID]' Title Player Account: 'title_player_account![Namespace ID]/[Title ID]/[MasterPlayerAccount
         * ID]/[TitlePlayerAccount ID]' Character: 'character![Namespace ID]/[Title ID]/[MasterPlayerAccount
         * ID]/[TitlePlayerAccount ID]/[Character ID]'
         */
        FString EntityChain;

        // [optional] The files on this profile.
        TMap<FString, FEntityProfileFileMetadata> Files;
        // [optional] The objects on this profile.
        TMap<FString, FEntityDataObject> Objects;
        /**
         * [optional] The permissions that govern access to this entity profile and its properties. Only includes permissions set on this
         * profile, not global statements from titles and namespaces.
         */
        TArray<FEntityPermissionStatement> Permissions;
        /**
         * The version number of the profile in persistent storage at the time of the read. Used for optional optimistic
         * concurrency during update.
         */
        int32 VersionNumber;

        FEntityProfileBody() :
            FPlayFabBaseModel(),
            Entity(nullptr),
            EntityChain(),
            Files(),
            Objects(),
            Permissions(),
            VersionNumber(0)
            {}

        FEntityProfileBody(const FEntityProfileBody& src) :
            FPlayFabBaseModel(),
            Entity(src.Entity.IsValid() ? MakeShareable(new FEntityKey(*src.Entity)) : nullptr),
            EntityChain(src.EntityChain),
            Files(src.Files),
            Objects(src.Objects),
            Permissions(src.Permissions),
            VersionNumber(src.VersionNumber)
            {}

        FEntityProfileBody(const TSharedPtr<FJsonObject>& obj) : FEntityProfileBody()
        {
            readFromValue(obj);
        }

        ~FEntityProfileBody();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FFinalizeFileUploadsRequest : public FPlayFabBaseModel
    {
        // The entity to perform this action on.
        FEntityKey Entity;

        // Names of the files to be finalized. Restricted to a-Z, 0-9, '(', ')', '_', '-' and '.'
        TArray<FString> FileNames;
        FFinalizeFileUploadsRequest() :
            FPlayFabBaseModel(),
            Entity(),
            FileNames()
            {}

        FFinalizeFileUploadsRequest(const FFinalizeFileUploadsRequest& src) :
            FPlayFabBaseModel(),
            Entity(src.Entity),
            FileNames(src.FileNames)
            {}

        FFinalizeFileUploadsRequest(const TSharedPtr<FJsonObject>& obj) : FFinalizeFileUploadsRequest()
        {
            readFromValue(obj);
        }

        ~FFinalizeFileUploadsRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetFileMetadata : public FPlayFabBaseModel
    {
        // [optional] Checksum value for the file
        FString Checksum;

        // [optional] Download URL where the file can be retrieved
        FString DownloadUrl;

        // [optional] Name of the file
        FString FileName;

        // Last UTC time the file was modified
        FDateTime LastModified;

        // Storage service's reported byte count
        int32 Size;

        FGetFileMetadata() :
            FPlayFabBaseModel(),
            Checksum(),
            DownloadUrl(),
            FileName(),
            LastModified(0),
            Size(0)
            {}

        FGetFileMetadata(const FGetFileMetadata& src) :
            FPlayFabBaseModel(),
            Checksum(src.Checksum),
            DownloadUrl(src.DownloadUrl),
            FileName(src.FileName),
            LastModified(src.LastModified),
            Size(src.Size)
            {}

        FGetFileMetadata(const TSharedPtr<FJsonObject>& obj) : FGetFileMetadata()
        {
            readFromValue(obj);
        }

        ~FGetFileMetadata();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FFinalizeFileUploadsResponse : public FPlayFabBaseModel
    {
        // [optional] The entity id and type.
        TSharedPtr<FEntityKey> Entity;

        // [optional] Collection of metadata for the entity's files
        TMap<FString, FGetFileMetadata> Metadata;
        // The current version of the profile, can be used for concurrency control during updates.
        int32 ProfileVersion;

        FFinalizeFileUploadsResponse() :
            FPlayFabBaseModel(),
            Entity(nullptr),
            Metadata(),
            ProfileVersion(0)
            {}

        FFinalizeFileUploadsResponse(const FFinalizeFileUploadsResponse& src) :
            FPlayFabBaseModel(),
            Entity(src.Entity.IsValid() ? MakeShareable(new FEntityKey(*src.Entity)) : nullptr),
            Metadata(src.Metadata),
            ProfileVersion(src.ProfileVersion)
            {}

        FFinalizeFileUploadsResponse(const TSharedPtr<FJsonObject>& obj) : FFinalizeFileUploadsResponse()
        {
            readFromValue(obj);
        }

        ~FFinalizeFileUploadsResponse();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetEntityProfileRequest : public FPlayFabBaseModel
    {
        /**
         * [optional] Determines whether the objects will be returned as an escaped JSON string or as a un-escaped JSON object. Default is
         * JSON string.
         */
        Boxed<bool> DataAsObject;

        // The entity to perform this action on.
        FEntityKey Entity;

        FGetEntityProfileRequest() :
            FPlayFabBaseModel(),
            DataAsObject(),
            Entity()
            {}

        FGetEntityProfileRequest(const FGetEntityProfileRequest& src) :
            FPlayFabBaseModel(),
            DataAsObject(src.DataAsObject),
            Entity(src.Entity)
            {}

        FGetEntityProfileRequest(const TSharedPtr<FJsonObject>& obj) : FGetEntityProfileRequest()
        {
            readFromValue(obj);
        }

        ~FGetEntityProfileRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetEntityProfileResponse : public FPlayFabBaseModel
    {
        // [optional] Entity profile
        TSharedPtr<FEntityProfileBody> Profile;

        FGetEntityProfileResponse() :
            FPlayFabBaseModel(),
            Profile(nullptr)
            {}

        FGetEntityProfileResponse(const FGetEntityProfileResponse& src) :
            FPlayFabBaseModel(),
            Profile(src.Profile.IsValid() ? MakeShareable(new FEntityProfileBody(*src.Profile)) : nullptr)
            {}

        FGetEntityProfileResponse(const TSharedPtr<FJsonObject>& obj) : FGetEntityProfileResponse()
        {
            readFromValue(obj);
        }

        ~FGetEntityProfileResponse();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetEntityProfilesRequest : public FPlayFabBaseModel
    {
        /**
         * [optional] Determines whether the objects will be returned as an escaped JSON string or as a un-escaped JSON object. Default is
         * JSON string.
         */
        Boxed<bool> DataAsObject;

        // Entity keys of the profiles to load. Must be between 1 and 25
        TArray<FEntityKey> Entities;
        FGetEntityProfilesRequest() :
            FPlayFabBaseModel(),
            DataAsObject(),
            Entities()
            {}

        FGetEntityProfilesRequest(const FGetEntityProfilesRequest& src) :
            FPlayFabBaseModel(),
            DataAsObject(src.DataAsObject),
            Entities(src.Entities)
            {}

        FGetEntityProfilesRequest(const TSharedPtr<FJsonObject>& obj) : FGetEntityProfilesRequest()
        {
            readFromValue(obj);
        }

        ~FGetEntityProfilesRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetEntityProfilesResponse : public FPlayFabBaseModel
    {
        // [optional] Entity profiles
        TArray<FEntityProfileBody> Profiles;
        FGetEntityProfilesResponse() :
            FPlayFabBaseModel(),
            Profiles()
            {}

        FGetEntityProfilesResponse(const FGetEntityProfilesResponse& src) :
            FPlayFabBaseModel(),
            Profiles(src.Profiles)
            {}

        FGetEntityProfilesResponse(const TSharedPtr<FJsonObject>& obj) : FGetEntityProfilesResponse()
        {
            readFromValue(obj);
        }

        ~FGetEntityProfilesResponse();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetEntityTokenRequest : public FPlayFabBaseModel
    {
        // [optional] The entity to perform this action on.
        TSharedPtr<FEntityKey> Entity;

        FGetEntityTokenRequest() :
            FPlayFabBaseModel(),
            Entity(nullptr)
            {}

        FGetEntityTokenRequest(const FGetEntityTokenRequest& src) :
            FPlayFabBaseModel(),
            Entity(src.Entity.IsValid() ? MakeShareable(new FEntityKey(*src.Entity)) : nullptr)
            {}

        FGetEntityTokenRequest(const TSharedPtr<FJsonObject>& obj) : FGetEntityTokenRequest()
        {
            readFromValue(obj);
        }

        ~FGetEntityTokenRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetEntityTokenResponse : public FPlayFabBaseModel
    {
        // [optional] The entity id and type.
        TSharedPtr<FEntityKey> Entity;

        // [optional] The token used to set X-EntityToken for all entity based API calls.
        FString EntityToken;

        // [optional] The time the token will expire, if it is an expiring token, in UTC.
        Boxed<FDateTime> TokenExpiration;

        FGetEntityTokenResponse() :
            FPlayFabBaseModel(),
            Entity(nullptr),
            EntityToken(),
            TokenExpiration()
            {}

        FGetEntityTokenResponse(const FGetEntityTokenResponse& src) :
            FPlayFabBaseModel(),
            Entity(src.Entity.IsValid() ? MakeShareable(new FEntityKey(*src.Entity)) : nullptr),
            EntityToken(src.EntityToken),
            TokenExpiration(src.TokenExpiration)
            {}

        FGetEntityTokenResponse(const TSharedPtr<FJsonObject>& obj) : FGetEntityTokenResponse()
        {
            readFromValue(obj);
        }

        ~FGetEntityTokenResponse();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetFilesRequest : public FPlayFabBaseModel
    {
        // The entity to perform this action on.
        FEntityKey Entity;

        FGetFilesRequest() :
            FPlayFabBaseModel(),
            Entity()
            {}

        FGetFilesRequest(const FGetFilesRequest& src) :
            FPlayFabBaseModel(),
            Entity(src.Entity)
            {}

        FGetFilesRequest(const TSharedPtr<FJsonObject>& obj) : FGetFilesRequest()
        {
            readFromValue(obj);
        }

        ~FGetFilesRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetFilesResponse : public FPlayFabBaseModel
    {
        // [optional] The entity id and type.
        TSharedPtr<FEntityKey> Entity;

        // [optional] Collection of metadata for the entity's files
        TMap<FString, FGetFileMetadata> Metadata;
        // The current version of the profile, can be used for concurrency control during updates.
        int32 ProfileVersion;

        FGetFilesResponse() :
            FPlayFabBaseModel(),
            Entity(nullptr),
            Metadata(),
            ProfileVersion(0)
            {}

        FGetFilesResponse(const FGetFilesResponse& src) :
            FPlayFabBaseModel(),
            Entity(src.Entity.IsValid() ? MakeShareable(new FEntityKey(*src.Entity)) : nullptr),
            Metadata(src.Metadata),
            ProfileVersion(src.ProfileVersion)
            {}

        FGetFilesResponse(const TSharedPtr<FJsonObject>& obj) : FGetFilesResponse()
        {
            readFromValue(obj);
        }

        ~FGetFilesResponse();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetGlobalPolicyRequest : public FPlayFabBaseModel
    {
        FGetGlobalPolicyRequest() :
            FPlayFabBaseModel()
            {}

        FGetGlobalPolicyRequest(const FGetGlobalPolicyRequest& src) :
            FPlayFabBaseModel()
            {}

        FGetGlobalPolicyRequest(const TSharedPtr<FJsonObject>& obj) : FGetGlobalPolicyRequest()
        {
            readFromValue(obj);
        }

        ~FGetGlobalPolicyRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetGlobalPolicyResponse : public FPlayFabBaseModel
    {
        // [optional] The permissions that govern access to all entities under this title or namespace.
        TArray<FEntityPermissionStatement> Permissions;
        FGetGlobalPolicyResponse() :
            FPlayFabBaseModel(),
            Permissions()
            {}

        FGetGlobalPolicyResponse(const FGetGlobalPolicyResponse& src) :
            FPlayFabBaseModel(),
            Permissions(src.Permissions)
            {}

        FGetGlobalPolicyResponse(const TSharedPtr<FJsonObject>& obj) : FGetGlobalPolicyResponse()
        {
            readFromValue(obj);
        }

        ~FGetGlobalPolicyResponse();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetGroupRequest : public FPlayFabBaseModel
    {
        // [optional] The identifier of the group
        TSharedPtr<FEntityKey> Group;

        // [optional] The full name of the group
        FString GroupName;

        FGetGroupRequest() :
            FPlayFabBaseModel(),
            Group(nullptr),
            GroupName()
            {}

        FGetGroupRequest(const FGetGroupRequest& src) :
            FPlayFabBaseModel(),
            Group(src.Group.IsValid() ? MakeShareable(new FEntityKey(*src.Group)) : nullptr),
            GroupName(src.GroupName)
            {}

        FGetGroupRequest(const TSharedPtr<FJsonObject>& obj) : FGetGroupRequest()
        {
            readFromValue(obj);
        }

        ~FGetGroupRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetGroupResponse : public FPlayFabBaseModel
    {
        // [optional] The ID of the administrator role for the group.
        FString AdminRoleId;

        // The server date and time the group was created.
        FDateTime Created;

        // The identifier of the group
        FEntityKey Group;

        // [optional] The name of the group.
        FString GroupName;

        // [optional] The ID of the default member role for the group.
        FString MemberRoleId;

        // The current version of the profile, can be used for concurrency control during updates.
        int32 ProfileVersion;

        // [optional] The list of roles and names that belong to the group.
        TMap<FString, FString> Roles;
        FGetGroupResponse() :
            FPlayFabBaseModel(),
            AdminRoleId(),
            Created(0),
            Group(),
            GroupName(),
            MemberRoleId(),
            ProfileVersion(0),
            Roles()
            {}

        FGetGroupResponse(const FGetGroupResponse& src) :
            FPlayFabBaseModel(),
            AdminRoleId(src.AdminRoleId),
            Created(src.Created),
            Group(src.Group),
            GroupName(src.GroupName),
            MemberRoleId(src.MemberRoleId),
            ProfileVersion(src.ProfileVersion),
            Roles(src.Roles)
            {}

        FGetGroupResponse(const TSharedPtr<FJsonObject>& obj) : FGetGroupResponse()
        {
            readFromValue(obj);
        }

        ~FGetGroupResponse();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetObjectsRequest : public FPlayFabBaseModel
    {
        // The entity to perform this action on.
        FEntityKey Entity;

        /**
         * [optional] Determines whether the object will be returned as an escaped JSON string or as a un-escaped JSON object. Default is JSON
         * object.
         */
        Boxed<bool> EscapeObject;

        FGetObjectsRequest() :
            FPlayFabBaseModel(),
            Entity(),
            EscapeObject()
            {}

        FGetObjectsRequest(const FGetObjectsRequest& src) :
            FPlayFabBaseModel(),
            Entity(src.Entity),
            EscapeObject(src.EscapeObject)
            {}

        FGetObjectsRequest(const TSharedPtr<FJsonObject>& obj) : FGetObjectsRequest()
        {
            readFromValue(obj);
        }

        ~FGetObjectsRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FObjectResult : public FPlayFabBaseModel
    {
        // [optional] Un-escaped JSON object, if EscapeObject false or default.
        FJsonKeeper DataObject;

        // [optional] Escaped string JSON body of the object, if EscapeObject is true.
        FString EscapedDataObject;

        // [optional] Name of the object. Restricted to a-Z, 0-9, '(', ')', '_', '-' and '.'
        FString ObjectName;

        FObjectResult() :
            FPlayFabBaseModel(),
            DataObject(),
            EscapedDataObject(),
            ObjectName()
            {}

        FObjectResult(const FObjectResult& src) :
            FPlayFabBaseModel(),
            DataObject(src.DataObject),
            EscapedDataObject(src.EscapedDataObject),
            ObjectName(src.ObjectName)
            {}

        FObjectResult(const TSharedPtr<FJsonObject>& obj) : FObjectResult()
        {
            readFromValue(obj);
        }

        ~FObjectResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetObjectsResponse : public FPlayFabBaseModel
    {
        // [optional] The entity id and type.
        TSharedPtr<FEntityKey> Entity;

        // [optional] Requested objects that the calling entity has access to
        TMap<FString, FObjectResult> Objects;
        // The current version of the profile, can be used for concurrency control during updates.
        int32 ProfileVersion;

        FGetObjectsResponse() :
            FPlayFabBaseModel(),
            Entity(nullptr),
            Objects(),
            ProfileVersion(0)
            {}

        FGetObjectsResponse(const FGetObjectsResponse& src) :
            FPlayFabBaseModel(),
            Entity(src.Entity.IsValid() ? MakeShareable(new FEntityKey(*src.Entity)) : nullptr),
            Objects(src.Objects),
            ProfileVersion(src.ProfileVersion)
            {}

        FGetObjectsResponse(const TSharedPtr<FJsonObject>& obj) : FGetObjectsResponse()
        {
            readFromValue(obj);
        }

        ~FGetObjectsResponse();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGroupApplication : public FPlayFabBaseModel
    {
        // [optional] Type of entity that requested membership
        TSharedPtr<FEntityWithLineage> Entity;

        // When the application to join will expire and be deleted
        FDateTime Expires;

        // [optional] ID of the group that the entity requesting membership to
        TSharedPtr<FEntityKey> Group;

        FGroupApplication() :
            FPlayFabBaseModel(),
            Entity(nullptr),
            Expires(0),
            Group(nullptr)
            {}

        FGroupApplication(const FGroupApplication& src) :
            FPlayFabBaseModel(),
            Entity(src.Entity.IsValid() ? MakeShareable(new FEntityWithLineage(*src.Entity)) : nullptr),
            Expires(src.Expires),
            Group(src.Group.IsValid() ? MakeShareable(new FEntityKey(*src.Group)) : nullptr)
            {}

        FGroupApplication(const TSharedPtr<FJsonObject>& obj) : FGroupApplication()
        {
            readFromValue(obj);
        }

        ~FGroupApplication();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGroupBlock : public FPlayFabBaseModel
    {
        // [optional] The entity that is blocked
        TSharedPtr<FEntityWithLineage> Entity;

        // ID of the group that the entity is blocked from
        FEntityKey Group;

        FGroupBlock() :
            FPlayFabBaseModel(),
            Entity(nullptr),
            Group()
            {}

        FGroupBlock(const FGroupBlock& src) :
            FPlayFabBaseModel(),
            Entity(src.Entity.IsValid() ? MakeShareable(new FEntityWithLineage(*src.Entity)) : nullptr),
            Group(src.Group)
            {}

        FGroupBlock(const TSharedPtr<FJsonObject>& obj) : FGroupBlock()
        {
            readFromValue(obj);
        }

        ~FGroupBlock();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGroupInvitation : public FPlayFabBaseModel
    {
        // When the invitation will expire and be deleted
        FDateTime Expires;

        // [optional] The group that the entity invited to
        TSharedPtr<FEntityKey> Group;

        // [optional] The entity that created the invitation
        TSharedPtr<FEntityWithLineage> InvitedByEntity;

        // [optional] The entity that is invited
        TSharedPtr<FEntityWithLineage> InvitedEntity;

        // [optional] ID of the role in the group to assign the user to.
        FString RoleId;

        FGroupInvitation() :
            FPlayFabBaseModel(),
            Expires(0),
            Group(nullptr),
            InvitedByEntity(nullptr),
            InvitedEntity(nullptr),
            RoleId()
            {}

        FGroupInvitation(const FGroupInvitation& src) :
            FPlayFabBaseModel(),
            Expires(src.Expires),
            Group(src.Group.IsValid() ? MakeShareable(new FEntityKey(*src.Group)) : nullptr),
            InvitedByEntity(src.InvitedByEntity.IsValid() ? MakeShareable(new FEntityWithLineage(*src.InvitedByEntity)) : nullptr),
            InvitedEntity(src.InvitedEntity.IsValid() ? MakeShareable(new FEntityWithLineage(*src.InvitedEntity)) : nullptr),
            RoleId(src.RoleId)
            {}

        FGroupInvitation(const TSharedPtr<FJsonObject>& obj) : FGroupInvitation()
        {
            readFromValue(obj);
        }

        ~FGroupInvitation();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGroupRole : public FPlayFabBaseModel
    {
        // [optional] ID for the role
        FString RoleId;

        // [optional] The name of the role
        FString RoleName;

        FGroupRole() :
            FPlayFabBaseModel(),
            RoleId(),
            RoleName()
            {}

        FGroupRole(const FGroupRole& src) :
            FPlayFabBaseModel(),
            RoleId(src.RoleId),
            RoleName(src.RoleName)
            {}

        FGroupRole(const TSharedPtr<FJsonObject>& obj) : FGroupRole()
        {
            readFromValue(obj);
        }

        ~FGroupRole();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGroupWithRoles : public FPlayFabBaseModel
    {
        // [optional] ID for the group
        TSharedPtr<FEntityKey> Group;

        // [optional] The name of the group
        FString GroupName;

        // The current version of the profile, can be used for concurrency control during updates.
        int32 ProfileVersion;

        // [optional] The list of roles within the group
        TArray<FGroupRole> Roles;
        FGroupWithRoles() :
            FPlayFabBaseModel(),
            Group(nullptr),
            GroupName(),
            ProfileVersion(0),
            Roles()
            {}

        FGroupWithRoles(const FGroupWithRoles& src) :
            FPlayFabBaseModel(),
            Group(src.Group.IsValid() ? MakeShareable(new FEntityKey(*src.Group)) : nullptr),
            GroupName(src.GroupName),
            ProfileVersion(src.ProfileVersion),
            Roles(src.Roles)
            {}

        FGroupWithRoles(const TSharedPtr<FJsonObject>& obj) : FGroupWithRoles()
        {
            readFromValue(obj);
        }

        ~FGroupWithRoles();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FInitiateFileUploadMetadata : public FPlayFabBaseModel
    {
        // [optional] Name of the file.
        FString FileName;

        // [optional] Location the data should be sent to via an HTTP PUT operation.
        FString UploadUrl;

        FInitiateFileUploadMetadata() :
            FPlayFabBaseModel(),
            FileName(),
            UploadUrl()
            {}

        FInitiateFileUploadMetadata(const FInitiateFileUploadMetadata& src) :
            FPlayFabBaseModel(),
            FileName(src.FileName),
            UploadUrl(src.UploadUrl)
            {}

        FInitiateFileUploadMetadata(const TSharedPtr<FJsonObject>& obj) : FInitiateFileUploadMetadata()
        {
            readFromValue(obj);
        }

        ~FInitiateFileUploadMetadata();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FInitiateFileUploadsRequest : public FPlayFabBaseModel
    {
        // The entity to perform this action on.
        FEntityKey Entity;

        // Names of the files to be set. Restricted to a-Z, 0-9, '(', ')', '_', '-' and '.'
        TArray<FString> FileNames;
        /**
         * [optional] The expected version of the profile, if set and doesn't match the current version of the profile the operation will not
         * be performed.
         */
        Boxed<int32> ProfileVersion;

        FInitiateFileUploadsRequest() :
            FPlayFabBaseModel(),
            Entity(),
            FileNames(),
            ProfileVersion()
            {}

        FInitiateFileUploadsRequest(const FInitiateFileUploadsRequest& src) :
            FPlayFabBaseModel(),
            Entity(src.Entity),
            FileNames(src.FileNames),
            ProfileVersion(src.ProfileVersion)
            {}

        FInitiateFileUploadsRequest(const TSharedPtr<FJsonObject>& obj) : FInitiateFileUploadsRequest()
        {
            readFromValue(obj);
        }

        ~FInitiateFileUploadsRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FInitiateFileUploadsResponse : public FPlayFabBaseModel
    {
        // [optional] The entity id and type.
        TSharedPtr<FEntityKey> Entity;

        // The current version of the profile, can be used for concurrency control during updates.
        int32 ProfileVersion;

        // [optional] Collection of file names and upload urls
        TArray<FInitiateFileUploadMetadata> UploadDetails;
        FInitiateFileUploadsResponse() :
            FPlayFabBaseModel(),
            Entity(nullptr),
            ProfileVersion(0),
            UploadDetails()
            {}

        FInitiateFileUploadsResponse(const FInitiateFileUploadsResponse& src) :
            FPlayFabBaseModel(),
            Entity(src.Entity.IsValid() ? MakeShareable(new FEntityKey(*src.Entity)) : nullptr),
            ProfileVersion(src.ProfileVersion),
            UploadDetails(src.UploadDetails)
            {}

        FInitiateFileUploadsResponse(const TSharedPtr<FJsonObject>& obj) : FInitiateFileUploadsResponse()
        {
            readFromValue(obj);
        }

        ~FInitiateFileUploadsResponse();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FInviteToGroupRequest : public FPlayFabBaseModel
    {
        // [optional] Optional, default true. Automatically accept an application if one exists instead of creating an invitation
        Boxed<bool> AutoAcceptOutstandingApplication;

        // The entity to perform this action on.
        FEntityKey Entity;

        // The identifier of the group
        FEntityKey Group;

        /**
         * [optional] Optional. ID of an existing a role in the group to assign the user to. The group's default member role is used if this
         * is not specified. Role IDs must be between 1 and 64 characters long.
         */
        FString RoleId;

        FInviteToGroupRequest() :
            FPlayFabBaseModel(),
            AutoAcceptOutstandingApplication(),
            Entity(),
            Group(),
            RoleId()
            {}

        FInviteToGroupRequest(const FInviteToGroupRequest& src) :
            FPlayFabBaseModel(),
            AutoAcceptOutstandingApplication(src.AutoAcceptOutstandingApplication),
            Entity(src.Entity),
            Group(src.Group),
            RoleId(src.RoleId)
            {}

        FInviteToGroupRequest(const TSharedPtr<FJsonObject>& obj) : FInviteToGroupRequest()
        {
            readFromValue(obj);
        }

        ~FInviteToGroupRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FInviteToGroupResponse : public FPlayFabBaseModel
    {
        // When the invitation will expire and be deleted
        FDateTime Expires;

        // [optional] The group that the entity invited to
        TSharedPtr<FEntityKey> Group;

        // [optional] The entity that created the invitation
        TSharedPtr<FEntityWithLineage> InvitedByEntity;

        // [optional] The entity that is invited
        TSharedPtr<FEntityWithLineage> InvitedEntity;

        // [optional] ID of the role in the group to assign the user to.
        FString RoleId;

        FInviteToGroupResponse() :
            FPlayFabBaseModel(),
            Expires(0),
            Group(nullptr),
            InvitedByEntity(nullptr),
            InvitedEntity(nullptr),
            RoleId()
            {}

        FInviteToGroupResponse(const FInviteToGroupResponse& src) :
            FPlayFabBaseModel(),
            Expires(src.Expires),
            Group(src.Group.IsValid() ? MakeShareable(new FEntityKey(*src.Group)) : nullptr),
            InvitedByEntity(src.InvitedByEntity.IsValid() ? MakeShareable(new FEntityWithLineage(*src.InvitedByEntity)) : nullptr),
            InvitedEntity(src.InvitedEntity.IsValid() ? MakeShareable(new FEntityWithLineage(*src.InvitedEntity)) : nullptr),
            RoleId(src.RoleId)
            {}

        FInviteToGroupResponse(const TSharedPtr<FJsonObject>& obj) : FInviteToGroupResponse()
        {
            readFromValue(obj);
        }

        ~FInviteToGroupResponse();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FIsMemberRequest : public FPlayFabBaseModel
    {
        // The entity to perform this action on.
        FEntityKey Entity;

        // The identifier of the group
        FEntityKey Group;

        /**
         * [optional] Optional: ID of the role to check membership of. Defaults to any role (that is, check to see if the entity is a member
         * of the group in any capacity) if not specified.
         */
        FString RoleId;

        FIsMemberRequest() :
            FPlayFabBaseModel(),
            Entity(),
            Group(),
            RoleId()
            {}

        FIsMemberRequest(const FIsMemberRequest& src) :
            FPlayFabBaseModel(),
            Entity(src.Entity),
            Group(src.Group),
            RoleId(src.RoleId)
            {}

        FIsMemberRequest(const TSharedPtr<FJsonObject>& obj) : FIsMemberRequest()
        {
            readFromValue(obj);
        }

        ~FIsMemberRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FIsMemberResponse : public FPlayFabBaseModel
    {
        // A value indicating whether or not the entity is a member.
        bool IsMember;

        FIsMemberResponse() :
            FPlayFabBaseModel(),
            IsMember(false)
            {}

        FIsMemberResponse(const FIsMemberResponse& src) :
            FPlayFabBaseModel(),
            IsMember(src.IsMember)
            {}

        FIsMemberResponse(const TSharedPtr<FJsonObject>& obj) : FIsMemberResponse()
        {
            readFromValue(obj);
        }

        ~FIsMemberResponse();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FListGroupApplicationsRequest : public FPlayFabBaseModel
    {
        // The identifier of the group
        FEntityKey Group;

        FListGroupApplicationsRequest() :
            FPlayFabBaseModel(),
            Group()
            {}

        FListGroupApplicationsRequest(const FListGroupApplicationsRequest& src) :
            FPlayFabBaseModel(),
            Group(src.Group)
            {}

        FListGroupApplicationsRequest(const TSharedPtr<FJsonObject>& obj) : FListGroupApplicationsRequest()
        {
            readFromValue(obj);
        }

        ~FListGroupApplicationsRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FListGroupApplicationsResponse : public FPlayFabBaseModel
    {
        // [optional] The requested list of applications to the group.
        TArray<FGroupApplication> Applications;
        FListGroupApplicationsResponse() :
            FPlayFabBaseModel(),
            Applications()
            {}

        FListGroupApplicationsResponse(const FListGroupApplicationsResponse& src) :
            FPlayFabBaseModel(),
            Applications(src.Applications)
            {}

        FListGroupApplicationsResponse(const TSharedPtr<FJsonObject>& obj) : FListGroupApplicationsResponse()
        {
            readFromValue(obj);
        }

        ~FListGroupApplicationsResponse();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FListGroupBlocksRequest : public FPlayFabBaseModel
    {
        // The identifier of the group
        FEntityKey Group;

        FListGroupBlocksRequest() :
            FPlayFabBaseModel(),
            Group()
            {}

        FListGroupBlocksRequest(const FListGroupBlocksRequest& src) :
            FPlayFabBaseModel(),
            Group(src.Group)
            {}

        FListGroupBlocksRequest(const TSharedPtr<FJsonObject>& obj) : FListGroupBlocksRequest()
        {
            readFromValue(obj);
        }

        ~FListGroupBlocksRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FListGroupBlocksResponse : public FPlayFabBaseModel
    {
        // [optional] The requested list blocked entities.
        TArray<FGroupBlock> BlockedEntities;
        FListGroupBlocksResponse() :
            FPlayFabBaseModel(),
            BlockedEntities()
            {}

        FListGroupBlocksResponse(const FListGroupBlocksResponse& src) :
            FPlayFabBaseModel(),
            BlockedEntities(src.BlockedEntities)
            {}

        FListGroupBlocksResponse(const TSharedPtr<FJsonObject>& obj) : FListGroupBlocksResponse()
        {
            readFromValue(obj);
        }

        ~FListGroupBlocksResponse();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FListGroupInvitationsRequest : public FPlayFabBaseModel
    {
        // The identifier of the group
        FEntityKey Group;

        FListGroupInvitationsRequest() :
            FPlayFabBaseModel(),
            Group()
            {}

        FListGroupInvitationsRequest(const FListGroupInvitationsRequest& src) :
            FPlayFabBaseModel(),
            Group(src.Group)
            {}

        FListGroupInvitationsRequest(const TSharedPtr<FJsonObject>& obj) : FListGroupInvitationsRequest()
        {
            readFromValue(obj);
        }

        ~FListGroupInvitationsRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FListGroupInvitationsResponse : public FPlayFabBaseModel
    {
        // [optional] The requested list of group invitations.
        TArray<FGroupInvitation> Invitations;
        FListGroupInvitationsResponse() :
            FPlayFabBaseModel(),
            Invitations()
            {}

        FListGroupInvitationsResponse(const FListGroupInvitationsResponse& src) :
            FPlayFabBaseModel(),
            Invitations(src.Invitations)
            {}

        FListGroupInvitationsResponse(const TSharedPtr<FJsonObject>& obj) : FListGroupInvitationsResponse()
        {
            readFromValue(obj);
        }

        ~FListGroupInvitationsResponse();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FListGroupMembersRequest : public FPlayFabBaseModel
    {
        // ID of the group to list the members and roles for
        FEntityKey Group;

        FListGroupMembersRequest() :
            FPlayFabBaseModel(),
            Group()
            {}

        FListGroupMembersRequest(const FListGroupMembersRequest& src) :
            FPlayFabBaseModel(),
            Group(src.Group)
            {}

        FListGroupMembersRequest(const TSharedPtr<FJsonObject>& obj) : FListGroupMembersRequest()
        {
            readFromValue(obj);
        }

        ~FListGroupMembersRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FListGroupMembersResponse : public FPlayFabBaseModel
    {
        // [optional] The requested list of roles and member entity IDs.
        TArray<FEntityMemberRole> Members;
        FListGroupMembersResponse() :
            FPlayFabBaseModel(),
            Members()
            {}

        FListGroupMembersResponse(const FListGroupMembersResponse& src) :
            FPlayFabBaseModel(),
            Members(src.Members)
            {}

        FListGroupMembersResponse(const TSharedPtr<FJsonObject>& obj) : FListGroupMembersResponse()
        {
            readFromValue(obj);
        }

        ~FListGroupMembersResponse();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FListMembershipOpportunitiesRequest : public FPlayFabBaseModel
    {
        // [optional] The entity to perform this action on.
        TSharedPtr<FEntityKey> Entity;

        FListMembershipOpportunitiesRequest() :
            FPlayFabBaseModel(),
            Entity(nullptr)
            {}

        FListMembershipOpportunitiesRequest(const FListMembershipOpportunitiesRequest& src) :
            FPlayFabBaseModel(),
            Entity(src.Entity.IsValid() ? MakeShareable(new FEntityKey(*src.Entity)) : nullptr)
            {}

        FListMembershipOpportunitiesRequest(const TSharedPtr<FJsonObject>& obj) : FListMembershipOpportunitiesRequest()
        {
            readFromValue(obj);
        }

        ~FListMembershipOpportunitiesRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FListMembershipOpportunitiesResponse : public FPlayFabBaseModel
    {
        // [optional] The requested list of group applications.
        TArray<FGroupApplication> Applications;
        // [optional] The requested list of group invitations.
        TArray<FGroupInvitation> Invitations;
        FListMembershipOpportunitiesResponse() :
            FPlayFabBaseModel(),
            Applications(),
            Invitations()
            {}

        FListMembershipOpportunitiesResponse(const FListMembershipOpportunitiesResponse& src) :
            FPlayFabBaseModel(),
            Applications(src.Applications),
            Invitations(src.Invitations)
            {}

        FListMembershipOpportunitiesResponse(const TSharedPtr<FJsonObject>& obj) : FListMembershipOpportunitiesResponse()
        {
            readFromValue(obj);
        }

        ~FListMembershipOpportunitiesResponse();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FListMembershipRequest : public FPlayFabBaseModel
    {
        // [optional] The entity to perform this action on.
        TSharedPtr<FEntityKey> Entity;

        FListMembershipRequest() :
            FPlayFabBaseModel(),
            Entity(nullptr)
            {}

        FListMembershipRequest(const FListMembershipRequest& src) :
            FPlayFabBaseModel(),
            Entity(src.Entity.IsValid() ? MakeShareable(new FEntityKey(*src.Entity)) : nullptr)
            {}

        FListMembershipRequest(const TSharedPtr<FJsonObject>& obj) : FListMembershipRequest()
        {
            readFromValue(obj);
        }

        ~FListMembershipRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FListMembershipResponse : public FPlayFabBaseModel
    {
        // [optional] The list of groups
        TArray<FGroupWithRoles> Groups;
        FListMembershipResponse() :
            FPlayFabBaseModel(),
            Groups()
            {}

        FListMembershipResponse(const FListMembershipResponse& src) :
            FPlayFabBaseModel(),
            Groups(src.Groups)
            {}

        FListMembershipResponse(const TSharedPtr<FJsonObject>& obj) : FListMembershipResponse()
        {
            readFromValue(obj);
        }

        ~FListMembershipResponse();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    enum OperationTypes
    {
        OperationTypesCreated,
        OperationTypesUpdated,
        OperationTypesDeleted,
        OperationTypesNone
    };

    PLAYFAB_API void writeOperationTypesEnumJSON(OperationTypes enumVal, JsonWriter& writer);
    PLAYFAB_API OperationTypes readOperationTypesFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFAB_API OperationTypes readOperationTypesFromValue(const FString& value);

    struct PLAYFAB_API FRemoveGroupApplicationRequest : public FPlayFabBaseModel
    {
        // The entity to perform this action on.
        FEntityKey Entity;

        // The identifier of the group
        FEntityKey Group;

        FRemoveGroupApplicationRequest() :
            FPlayFabBaseModel(),
            Entity(),
            Group()
            {}

        FRemoveGroupApplicationRequest(const FRemoveGroupApplicationRequest& src) :
            FPlayFabBaseModel(),
            Entity(src.Entity),
            Group(src.Group)
            {}

        FRemoveGroupApplicationRequest(const TSharedPtr<FJsonObject>& obj) : FRemoveGroupApplicationRequest()
        {
            readFromValue(obj);
        }

        ~FRemoveGroupApplicationRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FRemoveGroupInvitationRequest : public FPlayFabBaseModel
    {
        // The entity to perform this action on.
        FEntityKey Entity;

        // The identifier of the group
        FEntityKey Group;

        FRemoveGroupInvitationRequest() :
            FPlayFabBaseModel(),
            Entity(),
            Group()
            {}

        FRemoveGroupInvitationRequest(const FRemoveGroupInvitationRequest& src) :
            FPlayFabBaseModel(),
            Entity(src.Entity),
            Group(src.Group)
            {}

        FRemoveGroupInvitationRequest(const TSharedPtr<FJsonObject>& obj) : FRemoveGroupInvitationRequest()
        {
            readFromValue(obj);
        }

        ~FRemoveGroupInvitationRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FRemoveMembersRequest : public FPlayFabBaseModel
    {
        // The identifier of the group
        FEntityKey Group;

        // List of entities to remove
        TArray<FEntityKey> Members;
        // [optional] The ID of the role to remove the entities from.
        FString RoleId;

        FRemoveMembersRequest() :
            FPlayFabBaseModel(),
            Group(),
            Members(),
            RoleId()
            {}

        FRemoveMembersRequest(const FRemoveMembersRequest& src) :
            FPlayFabBaseModel(),
            Group(src.Group),
            Members(src.Members),
            RoleId(src.RoleId)
            {}

        FRemoveMembersRequest(const TSharedPtr<FJsonObject>& obj) : FRemoveMembersRequest()
        {
            readFromValue(obj);
        }

        ~FRemoveMembersRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FSetEntityProfilePolicyRequest : public FPlayFabBaseModel
    {
        // The entity to perform this action on.
        FEntityKey Entity;

        // [optional] The statements to include in the access policy.
        TArray<FEntityPermissionStatement> Statements;
        FSetEntityProfilePolicyRequest() :
            FPlayFabBaseModel(),
            Entity(),
            Statements()
            {}

        FSetEntityProfilePolicyRequest(const FSetEntityProfilePolicyRequest& src) :
            FPlayFabBaseModel(),
            Entity(src.Entity),
            Statements(src.Statements)
            {}

        FSetEntityProfilePolicyRequest(const TSharedPtr<FJsonObject>& obj) : FSetEntityProfilePolicyRequest()
        {
            readFromValue(obj);
        }

        ~FSetEntityProfilePolicyRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FSetEntityProfilePolicyResponse : public FPlayFabBaseModel
    {
        /**
         * [optional] The permissions that govern access to this entity profile and its properties. Only includes permissions set on this
         * profile, not global statements from titles and namespaces.
         */
        TArray<FEntityPermissionStatement> Permissions;
        FSetEntityProfilePolicyResponse() :
            FPlayFabBaseModel(),
            Permissions()
            {}

        FSetEntityProfilePolicyResponse(const FSetEntityProfilePolicyResponse& src) :
            FPlayFabBaseModel(),
            Permissions(src.Permissions)
            {}

        FSetEntityProfilePolicyResponse(const TSharedPtr<FJsonObject>& obj) : FSetEntityProfilePolicyResponse()
        {
            readFromValue(obj);
        }

        ~FSetEntityProfilePolicyResponse();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FSetGlobalPolicyRequest : public FPlayFabBaseModel
    {
        // [optional] The permissions that govern access to all entities under this title or namespace.
        TArray<FEntityPermissionStatement> Permissions;
        FSetGlobalPolicyRequest() :
            FPlayFabBaseModel(),
            Permissions()
            {}

        FSetGlobalPolicyRequest(const FSetGlobalPolicyRequest& src) :
            FPlayFabBaseModel(),
            Permissions(src.Permissions)
            {}

        FSetGlobalPolicyRequest(const TSharedPtr<FJsonObject>& obj) : FSetGlobalPolicyRequest()
        {
            readFromValue(obj);
        }

        ~FSetGlobalPolicyRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FSetGlobalPolicyResponse : public FPlayFabBaseModel
    {
        FSetGlobalPolicyResponse() :
            FPlayFabBaseModel()
            {}

        FSetGlobalPolicyResponse(const FSetGlobalPolicyResponse& src) :
            FPlayFabBaseModel()
            {}

        FSetGlobalPolicyResponse(const TSharedPtr<FJsonObject>& obj) : FSetGlobalPolicyResponse()
        {
            readFromValue(obj);
        }

        ~FSetGlobalPolicyResponse();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FSetObject : public FPlayFabBaseModel
    {
        /**
         * [optional] Body of the object to be saved. If empty and DeleteObject is true object will be deleted if it exists, or no operation
         * will occur if it does not exist. Only one of Object or EscapedDataObject fields may be used.
         */
        FJsonKeeper DataObject;

        // [optional] Flag to indicate that this object should be deleted. Both DataObject and EscapedDataObject must not be set as well.
        Boxed<bool> DeleteObject;

        /**
         * [optional] Body of the object to be saved as an escaped JSON string. If empty and DeleteObject is true object will be deleted if it
         * exists, or no operation will occur if it does not exist. Only one of DataObject or EscapedDataObject fields may be used.
         */
        FString EscapedDataObject;

        // Name of object. Restricted to a-Z, 0-9, '(', ')', '_', '-' and '.'.
        FString ObjectName;

        FSetObject() :
            FPlayFabBaseModel(),
            DataObject(),
            DeleteObject(),
            EscapedDataObject(),
            ObjectName()
            {}

        FSetObject(const FSetObject& src) :
            FPlayFabBaseModel(),
            DataObject(src.DataObject),
            DeleteObject(src.DeleteObject),
            EscapedDataObject(src.EscapedDataObject),
            ObjectName(src.ObjectName)
            {}

        FSetObject(const TSharedPtr<FJsonObject>& obj) : FSetObject()
        {
            readFromValue(obj);
        }

        ~FSetObject();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FSetObjectInfo : public FPlayFabBaseModel
    {
        // [optional] Name of the object
        FString ObjectName;

        // [optional] Optional reason to explain why the operation was the result that it was.
        FString OperationReason;

        // [optional] Indicates which operation was completed, either Created, Updated, Deleted or None.
        Boxed<OperationTypes> SetResult;

        FSetObjectInfo() :
            FPlayFabBaseModel(),
            ObjectName(),
            OperationReason(),
            SetResult()
            {}

        FSetObjectInfo(const FSetObjectInfo& src) :
            FPlayFabBaseModel(),
            ObjectName(src.ObjectName),
            OperationReason(src.OperationReason),
            SetResult(src.SetResult)
            {}

        FSetObjectInfo(const TSharedPtr<FJsonObject>& obj) : FSetObjectInfo()
        {
            readFromValue(obj);
        }

        ~FSetObjectInfo();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FSetObjectsRequest : public FPlayFabBaseModel
    {
        // The entity to perform this action on.
        FEntityKey Entity;

        /**
         * [optional] Optional field used for concurrency control. By specifying the previously returned value of ProfileVersion from
         * GetProfile API, you can ensure that the object set will only be performed if the profile has not been updated by any
         * other clients since the version you last loaded.
         */
        Boxed<int32> ExpectedProfileVersion;

        // Collection of objects to set on the profile.
        TArray<FSetObject> Objects;
        FSetObjectsRequest() :
            FPlayFabBaseModel(),
            Entity(),
            ExpectedProfileVersion(),
            Objects()
            {}

        FSetObjectsRequest(const FSetObjectsRequest& src) :
            FPlayFabBaseModel(),
            Entity(src.Entity),
            ExpectedProfileVersion(src.ExpectedProfileVersion),
            Objects(src.Objects)
            {}

        FSetObjectsRequest(const TSharedPtr<FJsonObject>& obj) : FSetObjectsRequest()
        {
            readFromValue(obj);
        }

        ~FSetObjectsRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FSetObjectsResponse : public FPlayFabBaseModel
    {
        // New version of the entity profile.
        int32 ProfileVersion;

        // [optional] New version of the entity profile.
        TArray<FSetObjectInfo> SetResults;
        FSetObjectsResponse() :
            FPlayFabBaseModel(),
            ProfileVersion(0),
            SetResults()
            {}

        FSetObjectsResponse(const FSetObjectsResponse& src) :
            FPlayFabBaseModel(),
            ProfileVersion(src.ProfileVersion),
            SetResults(src.SetResults)
            {}

        FSetObjectsResponse(const TSharedPtr<FJsonObject>& obj) : FSetObjectsResponse()
        {
            readFromValue(obj);
        }

        ~FSetObjectsResponse();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUnblockEntityRequest : public FPlayFabBaseModel
    {
        // The entity to perform this action on.
        FEntityKey Entity;

        // The identifier of the group
        FEntityKey Group;

        FUnblockEntityRequest() :
            FPlayFabBaseModel(),
            Entity(),
            Group()
            {}

        FUnblockEntityRequest(const FUnblockEntityRequest& src) :
            FPlayFabBaseModel(),
            Entity(src.Entity),
            Group(src.Group)
            {}

        FUnblockEntityRequest(const TSharedPtr<FJsonObject>& obj) : FUnblockEntityRequest()
        {
            readFromValue(obj);
        }

        ~FUnblockEntityRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUpdateGroupRequest : public FPlayFabBaseModel
    {
        // [optional] Optional: the ID of an existing role to set as the new administrator role for the group
        FString AdminRoleId;

        /**
         * [optional] Optional field used for concurrency control. By specifying the previously returned value of ProfileVersion from the
         * GetGroup API, you can ensure that the group data update will only be performed if the group has not been updated by any
         * other clients since the version you last loaded.
         */
        Boxed<int32> ExpectedProfileVersion;

        // The identifier of the group
        FEntityKey Group;

        // [optional] Optional: the new name of the group
        FString GroupName;

        // [optional] Optional: the ID of an existing role to set as the new member role for the group
        FString MemberRoleId;

        FUpdateGroupRequest() :
            FPlayFabBaseModel(),
            AdminRoleId(),
            ExpectedProfileVersion(),
            Group(),
            GroupName(),
            MemberRoleId()
            {}

        FUpdateGroupRequest(const FUpdateGroupRequest& src) :
            FPlayFabBaseModel(),
            AdminRoleId(src.AdminRoleId),
            ExpectedProfileVersion(src.ExpectedProfileVersion),
            Group(src.Group),
            GroupName(src.GroupName),
            MemberRoleId(src.MemberRoleId)
            {}

        FUpdateGroupRequest(const TSharedPtr<FJsonObject>& obj) : FUpdateGroupRequest()
        {
            readFromValue(obj);
        }

        ~FUpdateGroupRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUpdateGroupResponse : public FPlayFabBaseModel
    {
        // [optional] Optional reason to explain why the operation was the result that it was.
        FString OperationReason;

        // New version of the group data.
        int32 ProfileVersion;

        // [optional] Indicates which operation was completed, either Created, Updated, Deleted or None.
        Boxed<OperationTypes> SetResult;

        FUpdateGroupResponse() :
            FPlayFabBaseModel(),
            OperationReason(),
            ProfileVersion(0),
            SetResult()
            {}

        FUpdateGroupResponse(const FUpdateGroupResponse& src) :
            FPlayFabBaseModel(),
            OperationReason(src.OperationReason),
            ProfileVersion(src.ProfileVersion),
            SetResult(src.SetResult)
            {}

        FUpdateGroupResponse(const TSharedPtr<FJsonObject>& obj) : FUpdateGroupResponse()
        {
            readFromValue(obj);
        }

        ~FUpdateGroupResponse();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUpdateGroupRoleRequest : public FPlayFabBaseModel
    {
        /**
         * [optional] Optional field used for concurrency control. By specifying the previously returned value of ProfileVersion from the
         * GetGroup API, you can ensure that the group data update will only be performed if the group has not been updated by any
         * other clients since the version you last loaded.
         */
        Boxed<int32> ExpectedProfileVersion;

        // The identifier of the group
        FEntityKey Group;

        // [optional] ID of the role to update. Role IDs must be between 1 and 64 characters long.
        FString RoleId;

        // The new name of the role
        FString RoleName;

        FUpdateGroupRoleRequest() :
            FPlayFabBaseModel(),
            ExpectedProfileVersion(),
            Group(),
            RoleId(),
            RoleName()
            {}

        FUpdateGroupRoleRequest(const FUpdateGroupRoleRequest& src) :
            FPlayFabBaseModel(),
            ExpectedProfileVersion(src.ExpectedProfileVersion),
            Group(src.Group),
            RoleId(src.RoleId),
            RoleName(src.RoleName)
            {}

        FUpdateGroupRoleRequest(const TSharedPtr<FJsonObject>& obj) : FUpdateGroupRoleRequest()
        {
            readFromValue(obj);
        }

        ~FUpdateGroupRoleRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUpdateGroupRoleResponse : public FPlayFabBaseModel
    {
        // [optional] Optional reason to explain why the operation was the result that it was.
        FString OperationReason;

        // New version of the role data.
        int32 ProfileVersion;

        // [optional] Indicates which operation was completed, either Created, Updated, Deleted or None.
        Boxed<OperationTypes> SetResult;

        FUpdateGroupRoleResponse() :
            FPlayFabBaseModel(),
            OperationReason(),
            ProfileVersion(0),
            SetResult()
            {}

        FUpdateGroupRoleResponse(const FUpdateGroupRoleResponse& src) :
            FPlayFabBaseModel(),
            OperationReason(src.OperationReason),
            ProfileVersion(src.ProfileVersion),
            SetResult(src.SetResult)
            {}

        FUpdateGroupRoleResponse(const TSharedPtr<FJsonObject>& obj) : FUpdateGroupRoleResponse()
        {
            readFromValue(obj);
        }

        ~FUpdateGroupRoleResponse();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

}
}
