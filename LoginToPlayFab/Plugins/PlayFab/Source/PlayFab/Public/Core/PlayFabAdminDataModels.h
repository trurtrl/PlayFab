// This is automatically generated by PlayFab SDKGenerator. DO NOT modify this manually!
#pragma once

#include "CoreMinimal.h"
#include "Core/PlayFabBaseModel.h"

namespace PlayFab
{
namespace AdminModels
{

    struct PLAYFAB_API FAbortTaskInstanceRequest : public FPlayFabBaseModel
    {
        // ID of a task instance that is being aborted.
        FString TaskInstanceId;

        FAbortTaskInstanceRequest() :
            FPlayFabBaseModel(),
            TaskInstanceId()
            {}

        FAbortTaskInstanceRequest(const FAbortTaskInstanceRequest& src) :
            FPlayFabBaseModel(),
            TaskInstanceId(src.TaskInstanceId)
            {}

        FAbortTaskInstanceRequest(const TSharedPtr<FJsonObject>& obj) : FAbortTaskInstanceRequest()
        {
            readFromValue(obj);
        }

        ~FAbortTaskInstanceRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FActionsOnPlayersInSegmentTaskParameter : public FPlayFabBaseModel
    {
        // ID of the action to perform on each player in segment.
        FString ActionId;

        // ID of the segment to perform actions on.
        FString SegmentId;

        FActionsOnPlayersInSegmentTaskParameter() :
            FPlayFabBaseModel(),
            ActionId(),
            SegmentId()
            {}

        FActionsOnPlayersInSegmentTaskParameter(const FActionsOnPlayersInSegmentTaskParameter& src) :
            FPlayFabBaseModel(),
            ActionId(src.ActionId),
            SegmentId(src.SegmentId)
            {}

        FActionsOnPlayersInSegmentTaskParameter(const TSharedPtr<FJsonObject>& obj) : FActionsOnPlayersInSegmentTaskParameter()
        {
            readFromValue(obj);
        }

        ~FActionsOnPlayersInSegmentTaskParameter();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    enum TaskInstanceStatus
    {
        TaskInstanceStatusSucceeded,
        TaskInstanceStatusStarting,
        TaskInstanceStatusInProgress,
        TaskInstanceStatusFailed,
        TaskInstanceStatusAborted,
        TaskInstanceStatusPending
    };

    PLAYFAB_API void writeTaskInstanceStatusEnumJSON(TaskInstanceStatus enumVal, JsonWriter& writer);
    PLAYFAB_API TaskInstanceStatus readTaskInstanceStatusFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFAB_API TaskInstanceStatus readTaskInstanceStatusFromValue(const FString& value);

    struct PLAYFAB_API FNameIdentifier : public FPlayFabBaseModel
    {
        // [optional] undefined
        FString Id;

        // [optional] undefined
        FString Name;

        FNameIdentifier() :
            FPlayFabBaseModel(),
            Id(),
            Name()
            {}

        FNameIdentifier(const FNameIdentifier& src) :
            FPlayFabBaseModel(),
            Id(src.Id),
            Name(src.Name)
            {}

        FNameIdentifier(const TSharedPtr<FJsonObject>& obj) : FNameIdentifier()
        {
            readFromValue(obj);
        }

        ~FNameIdentifier();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FActionsOnPlayersInSegmentTaskSummary : public FPlayFabBaseModel
    {
        // [optional] UTC timestamp when the task completed.
        Boxed<FDateTime> CompletedAt;

        // [optional] Error message for last processing attempt, if an error occured.
        FString ErrorMessage;

        // [optional] Flag indicating if the error was fatal, if false job will be retried.
        Boxed<bool> ErrorWasFatal;

        // [optional] Estimated time remaining in seconds.
        Boxed<double> EstimatedSecondsRemaining;

        // [optional] Progress represented as percentage.
        Boxed<double> PercentComplete;

        // [optional] If manually scheduled, ID of user who scheduled the task.
        FString ScheduledByUserId;

        // UTC timestamp when the task started.
        FDateTime StartedAt;

        // [optional] Current status of the task instance.
        Boxed<TaskInstanceStatus> Status;

        // [optional] Identifier of the task this instance belongs to.
        TSharedPtr<FNameIdentifier> TaskIdentifier;

        // [optional] ID of the task instance.
        FString TaskInstanceId;

        // [optional] Total players in segment when task was started.
        Boxed<int32> TotalPlayersInSegment;

        // [optional] Total number of players that have had the actions applied to.
        Boxed<int32> TotalPlayersProcessed;

        FActionsOnPlayersInSegmentTaskSummary() :
            FPlayFabBaseModel(),
            CompletedAt(),
            ErrorMessage(),
            ErrorWasFatal(),
            EstimatedSecondsRemaining(),
            PercentComplete(),
            ScheduledByUserId(),
            StartedAt(0),
            Status(),
            TaskIdentifier(nullptr),
            TaskInstanceId(),
            TotalPlayersInSegment(),
            TotalPlayersProcessed()
            {}

        FActionsOnPlayersInSegmentTaskSummary(const FActionsOnPlayersInSegmentTaskSummary& src) :
            FPlayFabBaseModel(),
            CompletedAt(src.CompletedAt),
            ErrorMessage(src.ErrorMessage),
            ErrorWasFatal(src.ErrorWasFatal),
            EstimatedSecondsRemaining(src.EstimatedSecondsRemaining),
            PercentComplete(src.PercentComplete),
            ScheduledByUserId(src.ScheduledByUserId),
            StartedAt(src.StartedAt),
            Status(src.Status),
            TaskIdentifier(src.TaskIdentifier.IsValid() ? MakeShareable(new FNameIdentifier(*src.TaskIdentifier)) : nullptr),
            TaskInstanceId(src.TaskInstanceId),
            TotalPlayersInSegment(src.TotalPlayersInSegment),
            TotalPlayersProcessed(src.TotalPlayersProcessed)
            {}

        FActionsOnPlayersInSegmentTaskSummary(const TSharedPtr<FJsonObject>& obj) : FActionsOnPlayersInSegmentTaskSummary()
        {
            readFromValue(obj);
        }

        ~FActionsOnPlayersInSegmentTaskSummary();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FAdCampaignAttribution : public FPlayFabBaseModel
    {
        // UTC time stamp of attribution
        FDateTime AttributedAt;

        // [optional] Attribution campaign identifier
        FString CampaignId;

        // [optional] Attribution network name
        FString Platform;

        FAdCampaignAttribution() :
            FPlayFabBaseModel(),
            AttributedAt(0),
            CampaignId(),
            Platform()
            {}

        FAdCampaignAttribution(const FAdCampaignAttribution& src) :
            FPlayFabBaseModel(),
            AttributedAt(src.AttributedAt),
            CampaignId(src.CampaignId),
            Platform(src.Platform)
            {}

        FAdCampaignAttribution(const TSharedPtr<FJsonObject>& obj) : FAdCampaignAttribution()
        {
            readFromValue(obj);
        }

        ~FAdCampaignAttribution();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FAdCampaignAttributionModel : public FPlayFabBaseModel
    {
        // UTC time stamp of attribution
        FDateTime AttributedAt;

        // [optional] Attribution campaign identifier
        FString CampaignId;

        // [optional] Attribution network name
        FString Platform;

        FAdCampaignAttributionModel() :
            FPlayFabBaseModel(),
            AttributedAt(0),
            CampaignId(),
            Platform()
            {}

        FAdCampaignAttributionModel(const FAdCampaignAttributionModel& src) :
            FPlayFabBaseModel(),
            AttributedAt(src.AttributedAt),
            CampaignId(src.CampaignId),
            Platform(src.Platform)
            {}

        FAdCampaignAttributionModel(const TSharedPtr<FJsonObject>& obj) : FAdCampaignAttributionModel()
        {
            readFromValue(obj);
        }

        ~FAdCampaignAttributionModel();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FAddNewsRequest : public FPlayFabBaseModel
    {
        // Body text of the news
        FString Body;

        // [optional] Time this news was published. If not set, defaults to now.
        Boxed<FDateTime> Timestamp;

        // Title (headline) of the news item
        FString Title;

        FAddNewsRequest() :
            FPlayFabBaseModel(),
            Body(),
            Timestamp(),
            Title()
            {}

        FAddNewsRequest(const FAddNewsRequest& src) :
            FPlayFabBaseModel(),
            Body(src.Body),
            Timestamp(src.Timestamp),
            Title(src.Title)
            {}

        FAddNewsRequest(const TSharedPtr<FJsonObject>& obj) : FAddNewsRequest()
        {
            readFromValue(obj);
        }

        ~FAddNewsRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FAddNewsResult : public FPlayFabBaseModel
    {
        // [optional] Unique id of the new news item
        FString NewsId;

        FAddNewsResult() :
            FPlayFabBaseModel(),
            NewsId()
            {}

        FAddNewsResult(const FAddNewsResult& src) :
            FPlayFabBaseModel(),
            NewsId(src.NewsId)
            {}

        FAddNewsResult(const TSharedPtr<FJsonObject>& obj) : FAddNewsResult()
        {
            readFromValue(obj);
        }

        ~FAddNewsResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FAddPlayerTagRequest : public FPlayFabBaseModel
    {
        // Unique PlayFab assigned ID of the user on whom the operation will be performed.
        FString PlayFabId;

        // Unique tag for player profile.
        FString TagName;

        FAddPlayerTagRequest() :
            FPlayFabBaseModel(),
            PlayFabId(),
            TagName()
            {}

        FAddPlayerTagRequest(const FAddPlayerTagRequest& src) :
            FPlayFabBaseModel(),
            PlayFabId(src.PlayFabId),
            TagName(src.TagName)
            {}

        FAddPlayerTagRequest(const TSharedPtr<FJsonObject>& obj) : FAddPlayerTagRequest()
        {
            readFromValue(obj);
        }

        ~FAddPlayerTagRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FAddPlayerTagResult : public FPlayFabBaseModel
    {
        FAddPlayerTagResult() :
            FPlayFabBaseModel()
            {}

        FAddPlayerTagResult(const FAddPlayerTagResult& src) :
            FPlayFabBaseModel()
            {}

        FAddPlayerTagResult(const TSharedPtr<FJsonObject>& obj) : FAddPlayerTagResult()
        {
            readFromValue(obj);
        }

        ~FAddPlayerTagResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    enum Region
    {
        RegionUSCentral,
        RegionUSEast,
        RegionEUWest,
        RegionSingapore,
        RegionJapan,
        RegionBrazil,
        RegionAustralia
    };

    PLAYFAB_API void writeRegionEnumJSON(Region enumVal, JsonWriter& writer);
    PLAYFAB_API Region readRegionFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFAB_API Region readRegionFromValue(const FString& value);

    struct PLAYFAB_API FAddServerBuildRequest : public FPlayFabBaseModel
    {
        // [optional] server host regions in which this build should be running and available
        TArray<Region> ActiveRegions;
        // unique identifier for the build executable
        FString BuildId;

        // [optional] appended to the end of the command line when starting game servers
        FString CommandLineTemplate;

        // [optional] developer comment(s) for this build
        FString Comment;

        // [optional] path to the game server executable. Defaults to gameserver.exe
        FString ExecutablePath;

        // maximum number of game server instances that can run on a single host machine
        int32 MaxGamesPerHost;

        /**
         * minimum capacity of additional game server instances that can be started before the autoscaling service starts new host
         * machines (given the number of current running host machines and game server instances)
         */
        int32 MinFreeGameSlots;

        FAddServerBuildRequest() :
            FPlayFabBaseModel(),
            ActiveRegions(),
            BuildId(),
            CommandLineTemplate(),
            Comment(),
            ExecutablePath(),
            MaxGamesPerHost(0),
            MinFreeGameSlots(0)
            {}

        FAddServerBuildRequest(const FAddServerBuildRequest& src) :
            FPlayFabBaseModel(),
            ActiveRegions(src.ActiveRegions),
            BuildId(src.BuildId),
            CommandLineTemplate(src.CommandLineTemplate),
            Comment(src.Comment),
            ExecutablePath(src.ExecutablePath),
            MaxGamesPerHost(src.MaxGamesPerHost),
            MinFreeGameSlots(src.MinFreeGameSlots)
            {}

        FAddServerBuildRequest(const TSharedPtr<FJsonObject>& obj) : FAddServerBuildRequest()
        {
            readFromValue(obj);
        }

        ~FAddServerBuildRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    enum GameBuildStatus
    {
        GameBuildStatusAvailable,
        GameBuildStatusValidating,
        GameBuildStatusInvalidBuildPackage,
        GameBuildStatusProcessing,
        GameBuildStatusFailedToProcess
    };

    PLAYFAB_API void writeGameBuildStatusEnumJSON(GameBuildStatus enumVal, JsonWriter& writer);
    PLAYFAB_API GameBuildStatus readGameBuildStatusFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFAB_API GameBuildStatus readGameBuildStatusFromValue(const FString& value);

    struct PLAYFAB_API FAddServerBuildResult : public FPlayFabBaseModel
    {
        // [optional] array of regions where this build can used, when it is active
        TArray<Region> ActiveRegions;
        // [optional] unique identifier for this build executable
        FString BuildId;

        // [optional] appended to the end of the command line when starting game servers
        FString CommandLineTemplate;

        // [optional] developer comment(s) for this build
        FString Comment;

        // [optional] path to the game server executable. Defaults to gameserver.exe
        FString ExecutablePath;

        // maximum number of game server instances that can run on a single host machine
        int32 MaxGamesPerHost;

        /**
         * minimum capacity of additional game server instances that can be started before the autoscaling service starts new host
         * machines (given the number of current running host machines and game server instances)
         */
        int32 MinFreeGameSlots;

        // [optional] the current status of the build validation and processing steps
        Boxed<GameBuildStatus> Status;

        // time this build was last modified (or uploaded, if this build has never been modified)
        FDateTime Timestamp;

        /**
         * [optional] Unique identifier for the title, found in the Settings > Game Properties section of the PlayFab developer site when a
         * title has been selected.
         */
        FString TitleId;

        FAddServerBuildResult() :
            FPlayFabBaseModel(),
            ActiveRegions(),
            BuildId(),
            CommandLineTemplate(),
            Comment(),
            ExecutablePath(),
            MaxGamesPerHost(0),
            MinFreeGameSlots(0),
            Status(),
            Timestamp(0),
            TitleId()
            {}

        FAddServerBuildResult(const FAddServerBuildResult& src) :
            FPlayFabBaseModel(),
            ActiveRegions(src.ActiveRegions),
            BuildId(src.BuildId),
            CommandLineTemplate(src.CommandLineTemplate),
            Comment(src.Comment),
            ExecutablePath(src.ExecutablePath),
            MaxGamesPerHost(src.MaxGamesPerHost),
            MinFreeGameSlots(src.MinFreeGameSlots),
            Status(src.Status),
            Timestamp(src.Timestamp),
            TitleId(src.TitleId)
            {}

        FAddServerBuildResult(const TSharedPtr<FJsonObject>& obj) : FAddServerBuildResult()
        {
            readFromValue(obj);
        }

        ~FAddServerBuildResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FAddUserVirtualCurrencyRequest : public FPlayFabBaseModel
    {
        /**
         * Amount to be added to the user balance of the specified virtual currency. Maximum VC balance is Int32 (2,147,483,647).
         * Any increase over this value will be discarded.
         */
        int32 Amount;

        // PlayFab unique identifier of the user whose virtual currency balance is to be increased.
        FString PlayFabId;

        // Name of the virtual currency which is to be incremented.
        FString VirtualCurrency;

        FAddUserVirtualCurrencyRequest() :
            FPlayFabBaseModel(),
            Amount(0),
            PlayFabId(),
            VirtualCurrency()
            {}

        FAddUserVirtualCurrencyRequest(const FAddUserVirtualCurrencyRequest& src) :
            FPlayFabBaseModel(),
            Amount(src.Amount),
            PlayFabId(src.PlayFabId),
            VirtualCurrency(src.VirtualCurrency)
            {}

        FAddUserVirtualCurrencyRequest(const TSharedPtr<FJsonObject>& obj) : FAddUserVirtualCurrencyRequest()
        {
            readFromValue(obj);
        }

        ~FAddUserVirtualCurrencyRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FVirtualCurrencyData : public FPlayFabBaseModel
    {
        // unique two-character identifier for this currency type (e.g.: "CC")
        FString CurrencyCode;

        // [optional] friendly name to show in the developer portal, reports, etc.
        FString DisplayName;

        // [optional] amount to automatically grant users upon first login to the title
        Boxed<int32> InitialDeposit;

        // [optional] maximum amount to which the currency will recharge (cannot exceed MaxAmount, but can be less)
        Boxed<int32> RechargeMax;

        // [optional] rate at which the currency automatically be added to over time, in units per day (24 hours)
        Boxed<int32> RechargeRate;

        FVirtualCurrencyData() :
            FPlayFabBaseModel(),
            CurrencyCode(),
            DisplayName(),
            InitialDeposit(),
            RechargeMax(),
            RechargeRate()
            {}

        FVirtualCurrencyData(const FVirtualCurrencyData& src) :
            FPlayFabBaseModel(),
            CurrencyCode(src.CurrencyCode),
            DisplayName(src.DisplayName),
            InitialDeposit(src.InitialDeposit),
            RechargeMax(src.RechargeMax),
            RechargeRate(src.RechargeRate)
            {}

        FVirtualCurrencyData(const TSharedPtr<FJsonObject>& obj) : FVirtualCurrencyData()
        {
            readFromValue(obj);
        }

        ~FVirtualCurrencyData();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FAddVirtualCurrencyTypesRequest : public FPlayFabBaseModel
    {
        /**
         * List of virtual currencies and their initial deposits (the amount a user is granted when signing in for the first time)
         * to the title
         */
        TArray<FVirtualCurrencyData> VirtualCurrencies;
        FAddVirtualCurrencyTypesRequest() :
            FPlayFabBaseModel(),
            VirtualCurrencies()
            {}

        FAddVirtualCurrencyTypesRequest(const FAddVirtualCurrencyTypesRequest& src) :
            FPlayFabBaseModel(),
            VirtualCurrencies(src.VirtualCurrencies)
            {}

        FAddVirtualCurrencyTypesRequest(const TSharedPtr<FJsonObject>& obj) : FAddVirtualCurrencyTypesRequest()
        {
            readFromValue(obj);
        }

        ~FAddVirtualCurrencyTypesRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    enum Conditionals
    {
        ConditionalsAny,
        ConditionalsTrue,
        ConditionalsFalse
    };

    PLAYFAB_API void writeConditionalsEnumJSON(Conditionals enumVal, JsonWriter& writer);
    PLAYFAB_API Conditionals readConditionalsFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFAB_API Conditionals readConditionalsFromValue(const FString& value);

    struct PLAYFAB_API FApiCondition : public FPlayFabBaseModel
    {
        // [optional] Require that API calls contain an RSA encrypted payload or signed headers.
        Boxed<Conditionals> HasSignatureOrEncryption;

        FApiCondition() :
            FPlayFabBaseModel(),
            HasSignatureOrEncryption()
            {}

        FApiCondition(const FApiCondition& src) :
            FPlayFabBaseModel(),
            HasSignatureOrEncryption(src.HasSignatureOrEncryption)
            {}

        FApiCondition(const TSharedPtr<FJsonObject>& obj) : FApiCondition()
        {
            readFromValue(obj);
        }

        ~FApiCondition();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    enum AuthTokenType
    {
        AuthTokenTypeEmail
    };

    PLAYFAB_API void writeAuthTokenTypeEnumJSON(AuthTokenType enumVal, JsonWriter& writer);
    PLAYFAB_API AuthTokenType readAuthTokenTypeFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFAB_API AuthTokenType readAuthTokenTypeFromValue(const FString& value);

    struct PLAYFAB_API FBanInfo : public FPlayFabBaseModel
    {
        // The active state of this ban. Expired bans may still have this value set to true but they will have no effect.
        bool Active;

        // [optional] The unique Ban Id associated with this ban.
        FString BanId;

        // [optional] The time when this ban was applied.
        Boxed<FDateTime> Created;

        // [optional] The time when this ban expires. Permanent bans do not have expiration date.
        Boxed<FDateTime> Expires;

        // [optional] The IP address on which the ban was applied. May affect multiple players.
        FString IPAddress;

        // [optional] The MAC address on which the ban was applied. May affect multiple players.
        FString MACAddress;

        // [optional] Unique PlayFab assigned ID of the user on whom the operation will be performed.
        FString PlayFabId;

        // [optional] The reason why this ban was applied.
        FString Reason;

        FBanInfo() :
            FPlayFabBaseModel(),
            Active(false),
            BanId(),
            Created(),
            Expires(),
            IPAddress(),
            MACAddress(),
            PlayFabId(),
            Reason()
            {}

        FBanInfo(const FBanInfo& src) :
            FPlayFabBaseModel(),
            Active(src.Active),
            BanId(src.BanId),
            Created(src.Created),
            Expires(src.Expires),
            IPAddress(src.IPAddress),
            MACAddress(src.MACAddress),
            PlayFabId(src.PlayFabId),
            Reason(src.Reason)
            {}

        FBanInfo(const TSharedPtr<FJsonObject>& obj) : FBanInfo()
        {
            readFromValue(obj);
        }

        ~FBanInfo();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FBanRequest : public FPlayFabBaseModel
    {
        // [optional] The duration in hours for the ban. Leave this blank for a permanent ban.
        Boxed<uint32> DurationInHours;

        // [optional] IP address to be banned. May affect multiple players.
        FString IPAddress;

        // [optional] MAC address to be banned. May affect multiple players.
        FString MACAddress;

        // Unique PlayFab assigned ID of the user on whom the operation will be performed.
        FString PlayFabId;

        // [optional] The reason for this ban. Maximum 140 characters.
        FString Reason;

        FBanRequest() :
            FPlayFabBaseModel(),
            DurationInHours(),
            IPAddress(),
            MACAddress(),
            PlayFabId(),
            Reason()
            {}

        FBanRequest(const FBanRequest& src) :
            FPlayFabBaseModel(),
            DurationInHours(src.DurationInHours),
            IPAddress(src.IPAddress),
            MACAddress(src.MACAddress),
            PlayFabId(src.PlayFabId),
            Reason(src.Reason)
            {}

        FBanRequest(const TSharedPtr<FJsonObject>& obj) : FBanRequest()
        {
            readFromValue(obj);
        }

        ~FBanRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FBanUsersRequest : public FPlayFabBaseModel
    {
        // List of ban requests to be applied. Maximum 100.
        TArray<FBanRequest> Bans;
        FBanUsersRequest() :
            FPlayFabBaseModel(),
            Bans()
            {}

        FBanUsersRequest(const FBanUsersRequest& src) :
            FPlayFabBaseModel(),
            Bans(src.Bans)
            {}

        FBanUsersRequest(const TSharedPtr<FJsonObject>& obj) : FBanUsersRequest()
        {
            readFromValue(obj);
        }

        ~FBanUsersRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FBanUsersResult : public FPlayFabBaseModel
    {
        // [optional] Information on the bans that were applied
        TArray<FBanInfo> BanData;
        FBanUsersResult() :
            FPlayFabBaseModel(),
            BanData()
            {}

        FBanUsersResult(const FBanUsersResult& src) :
            FPlayFabBaseModel(),
            BanData(src.BanData)
            {}

        FBanUsersResult(const TSharedPtr<FJsonObject>& obj) : FBanUsersResult()
        {
            readFromValue(obj);
        }

        ~FBanUsersResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FBlankResult : public FPlayFabBaseModel
    {
        FBlankResult() :
            FPlayFabBaseModel()
            {}

        FBlankResult(const FBlankResult& src) :
            FPlayFabBaseModel()
            {}

        FBlankResult(const TSharedPtr<FJsonObject>& obj) : FBlankResult()
        {
            readFromValue(obj);
        }

        ~FBlankResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FCatalogItemBundleInfo : public FPlayFabBaseModel
    {
        // [optional] unique ItemId values for all items which will be added to the player inventory when the bundle is added
        TArray<FString> BundledItems;
        /**
         * [optional] unique TableId values for all RandomResultTable objects which are part of the bundle (random tables will be resolved and
         * add the relevant items to the player inventory when the bundle is added)
         */
        TArray<FString> BundledResultTables;
        // [optional] virtual currency types and balances which will be added to the player inventory when the bundle is added
        TMap<FString, uint32> BundledVirtualCurrencies;
        FCatalogItemBundleInfo() :
            FPlayFabBaseModel(),
            BundledItems(),
            BundledResultTables(),
            BundledVirtualCurrencies()
            {}

        FCatalogItemBundleInfo(const FCatalogItemBundleInfo& src) :
            FPlayFabBaseModel(),
            BundledItems(src.BundledItems),
            BundledResultTables(src.BundledResultTables),
            BundledVirtualCurrencies(src.BundledVirtualCurrencies)
            {}

        FCatalogItemBundleInfo(const TSharedPtr<FJsonObject>& obj) : FCatalogItemBundleInfo()
        {
            readFromValue(obj);
        }

        ~FCatalogItemBundleInfo();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FCatalogItemConsumableInfo : public FPlayFabBaseModel
    {
        // [optional] number of times this object can be used, after which it will be removed from the player inventory
        Boxed<uint32> UsageCount;

        /**
         * [optional] duration in seconds for how long the item will remain in the player inventory - once elapsed, the item will be removed
         * (recommended minimum value is 5 seconds, as lower values can cause the item to expire before operations depending on
         * this item's details have completed)
         */
        Boxed<uint32> UsagePeriod;

        /**
         * [optional] all inventory item instances in the player inventory sharing a non-null UsagePeriodGroup have their UsagePeriod values
         * added together, and share the result - when that period has elapsed, all the items in the group will be removed
         */
        FString UsagePeriodGroup;

        FCatalogItemConsumableInfo() :
            FPlayFabBaseModel(),
            UsageCount(),
            UsagePeriod(),
            UsagePeriodGroup()
            {}

        FCatalogItemConsumableInfo(const FCatalogItemConsumableInfo& src) :
            FPlayFabBaseModel(),
            UsageCount(src.UsageCount),
            UsagePeriod(src.UsagePeriod),
            UsagePeriodGroup(src.UsagePeriodGroup)
            {}

        FCatalogItemConsumableInfo(const TSharedPtr<FJsonObject>& obj) : FCatalogItemConsumableInfo()
        {
            readFromValue(obj);
        }

        ~FCatalogItemConsumableInfo();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FCatalogItemContainerInfo : public FPlayFabBaseModel
    {
        // [optional] unique ItemId values for all items which will be added to the player inventory, once the container has been unlocked
        TArray<FString> ItemContents;
        /**
         * [optional] ItemId for the catalog item used to unlock the container, if any (if not specified, a call to UnlockContainerItem will
         * open the container, adding the contents to the player inventory and currency balances)
         */
        FString KeyItemId;

        /**
         * [optional] unique TableId values for all RandomResultTable objects which are part of the container (once unlocked, random tables
         * will be resolved and add the relevant items to the player inventory)
         */
        TArray<FString> ResultTableContents;
        // [optional] virtual currency types and balances which will be added to the player inventory when the container is unlocked
        TMap<FString, uint32> VirtualCurrencyContents;
        FCatalogItemContainerInfo() :
            FPlayFabBaseModel(),
            ItemContents(),
            KeyItemId(),
            ResultTableContents(),
            VirtualCurrencyContents()
            {}

        FCatalogItemContainerInfo(const FCatalogItemContainerInfo& src) :
            FPlayFabBaseModel(),
            ItemContents(src.ItemContents),
            KeyItemId(src.KeyItemId),
            ResultTableContents(src.ResultTableContents),
            VirtualCurrencyContents(src.VirtualCurrencyContents)
            {}

        FCatalogItemContainerInfo(const TSharedPtr<FJsonObject>& obj) : FCatalogItemContainerInfo()
        {
            readFromValue(obj);
        }

        ~FCatalogItemContainerInfo();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FCatalogItem : public FPlayFabBaseModel
    {
        /**
         * [optional] defines the bundle properties for the item - bundles are items which contain other items, including random drop tables
         * and virtual currencies
         */
        TSharedPtr<FCatalogItemBundleInfo> Bundle;

        // if true, then an item instance of this type can be used to grant a character to a user.
        bool CanBecomeCharacter;

        // [optional] catalog version for this item
        FString CatalogVersion;

        // [optional] defines the consumable properties (number of uses, timeout) for the item
        TSharedPtr<FCatalogItemConsumableInfo> Consumable;

        /**
         * [optional] defines the container properties for the item - what items it contains, including random drop tables and virtual
         * currencies, and what item (if any) is required to open it via the UnlockContainerItem API
         */
        TSharedPtr<FCatalogItemContainerInfo> Container;

        // [optional] game specific custom data
        FString CustomData;

        // [optional] text description of item, to show in-game
        FString Description;

        // [optional] text name for the item, to show in-game
        FString DisplayName;

        /**
         * If the item has IsLImitedEdition set to true, and this is the first time this ItemId has been defined as a limited
         * edition item, this value determines the total number of instances to allocate for the title. Once this limit has been
         * reached, no more instances of this ItemId can be created, and attempts to purchase or grant it will return a Result of
         * false for that ItemId. If the item has already been defined to have a limited edition count, or if this value is less
         * than zero, it will be ignored.
         */
        int32 InitialLimitedEditionCount;

        // BETA: If true, then only a fixed number can ever be granted.
        bool IsLimitedEdition;

        /**
         * if true, then only one item instance of this type will exist and its remaininguses will be incremented instead.
         * RemainingUses will cap out at Int32.Max (2,147,483,647). All subsequent increases will be discarded
         */
        bool IsStackable;

        // if true, then an item instance of this type can be traded between players using the trading APIs
        bool IsTradable;

        // [optional] class to which the item belongs
        FString ItemClass;

        // unique identifier for this item
        FString ItemId;

        /**
         * [optional] URL to the item image. For Facebook purchase to display the image on the item purchase page, this must be set to an HTTP
         * URL.
         */
        FString ItemImageUrl;

        // [optional] override prices for this item for specific currencies
        TMap<FString, uint32> RealCurrencyPrices;
        // [optional] list of item tags
        TArray<FString> Tags;
        // [optional] price of this item in virtual currencies and "RM" (the base Real Money purchase price, in USD pennies)
        TMap<FString, uint32> VirtualCurrencyPrices;
        FCatalogItem() :
            FPlayFabBaseModel(),
            Bundle(nullptr),
            CanBecomeCharacter(false),
            CatalogVersion(),
            Consumable(nullptr),
            Container(nullptr),
            CustomData(),
            Description(),
            DisplayName(),
            InitialLimitedEditionCount(0),
            IsLimitedEdition(false),
            IsStackable(false),
            IsTradable(false),
            ItemClass(),
            ItemId(),
            ItemImageUrl(),
            RealCurrencyPrices(),
            Tags(),
            VirtualCurrencyPrices()
            {}

        FCatalogItem(const FCatalogItem& src) :
            FPlayFabBaseModel(),
            Bundle(src.Bundle.IsValid() ? MakeShareable(new FCatalogItemBundleInfo(*src.Bundle)) : nullptr),
            CanBecomeCharacter(src.CanBecomeCharacter),
            CatalogVersion(src.CatalogVersion),
            Consumable(src.Consumable.IsValid() ? MakeShareable(new FCatalogItemConsumableInfo(*src.Consumable)) : nullptr),
            Container(src.Container.IsValid() ? MakeShareable(new FCatalogItemContainerInfo(*src.Container)) : nullptr),
            CustomData(src.CustomData),
            Description(src.Description),
            DisplayName(src.DisplayName),
            InitialLimitedEditionCount(src.InitialLimitedEditionCount),
            IsLimitedEdition(src.IsLimitedEdition),
            IsStackable(src.IsStackable),
            IsTradable(src.IsTradable),
            ItemClass(src.ItemClass),
            ItemId(src.ItemId),
            ItemImageUrl(src.ItemImageUrl),
            RealCurrencyPrices(src.RealCurrencyPrices),
            Tags(src.Tags),
            VirtualCurrencyPrices(src.VirtualCurrencyPrices)
            {}

        FCatalogItem(const TSharedPtr<FJsonObject>& obj) : FCatalogItem()
        {
            readFromValue(obj);
        }

        ~FCatalogItem();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FCheckLimitedEditionItemAvailabilityRequest : public FPlayFabBaseModel
    {
        // [optional] Which catalog is being updated. If null, uses the default catalog.
        FString CatalogVersion;

        // The item to check for.
        FString ItemId;

        FCheckLimitedEditionItemAvailabilityRequest() :
            FPlayFabBaseModel(),
            CatalogVersion(),
            ItemId()
            {}

        FCheckLimitedEditionItemAvailabilityRequest(const FCheckLimitedEditionItemAvailabilityRequest& src) :
            FPlayFabBaseModel(),
            CatalogVersion(src.CatalogVersion),
            ItemId(src.ItemId)
            {}

        FCheckLimitedEditionItemAvailabilityRequest(const TSharedPtr<FJsonObject>& obj) : FCheckLimitedEditionItemAvailabilityRequest()
        {
            readFromValue(obj);
        }

        ~FCheckLimitedEditionItemAvailabilityRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FCheckLimitedEditionItemAvailabilityResult : public FPlayFabBaseModel
    {
        // The amount of the specified resource remaining.
        int32 Amount;

        FCheckLimitedEditionItemAvailabilityResult() :
            FPlayFabBaseModel(),
            Amount(0)
            {}

        FCheckLimitedEditionItemAvailabilityResult(const FCheckLimitedEditionItemAvailabilityResult& src) :
            FPlayFabBaseModel(),
            Amount(src.Amount)
            {}

        FCheckLimitedEditionItemAvailabilityResult(const TSharedPtr<FJsonObject>& obj) : FCheckLimitedEditionItemAvailabilityResult()
        {
            readFromValue(obj);
        }

        ~FCheckLimitedEditionItemAvailabilityResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FCloudScriptFile : public FPlayFabBaseModel
    {
        // Contents of the Cloud Script javascript. Must be string-escaped javascript.
        FString FileContents;

        /**
         * Name of the javascript file. These names are not used internally by the server, they are only for developer
         * organizational purposes.
         */
        FString Filename;

        FCloudScriptFile() :
            FPlayFabBaseModel(),
            FileContents(),
            Filename()
            {}

        FCloudScriptFile(const FCloudScriptFile& src) :
            FPlayFabBaseModel(),
            FileContents(src.FileContents),
            Filename(src.Filename)
            {}

        FCloudScriptFile(const TSharedPtr<FJsonObject>& obj) : FCloudScriptFile()
        {
            readFromValue(obj);
        }

        ~FCloudScriptFile();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FCloudScriptTaskParameter : public FPlayFabBaseModel
    {
        // [optional] Argument to pass to the CloudScript function.
        FJsonKeeper Argument;

        // [optional] Name of the CloudScript function to execute.
        FString FunctionName;

        FCloudScriptTaskParameter() :
            FPlayFabBaseModel(),
            Argument(),
            FunctionName()
            {}

        FCloudScriptTaskParameter(const FCloudScriptTaskParameter& src) :
            FPlayFabBaseModel(),
            Argument(src.Argument),
            FunctionName(src.FunctionName)
            {}

        FCloudScriptTaskParameter(const TSharedPtr<FJsonObject>& obj) : FCloudScriptTaskParameter()
        {
            readFromValue(obj);
        }

        ~FCloudScriptTaskParameter();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FScriptExecutionError : public FPlayFabBaseModel
    {
        /**
         * [optional] Error code, such as CloudScriptNotFound, JavascriptException, CloudScriptFunctionArgumentSizeExceeded,
         * CloudScriptAPIRequestCountExceeded, CloudScriptAPIRequestError, or CloudScriptHTTPRequestError
         */
        FString Error;

        // [optional] Details about the error
        FString Message;

        // [optional] Point during the execution of the script at which the error occurred, if any
        FString StackTrace;

        FScriptExecutionError() :
            FPlayFabBaseModel(),
            Error(),
            Message(),
            StackTrace()
            {}

        FScriptExecutionError(const FScriptExecutionError& src) :
            FPlayFabBaseModel(),
            Error(src.Error),
            Message(src.Message),
            StackTrace(src.StackTrace)
            {}

        FScriptExecutionError(const TSharedPtr<FJsonObject>& obj) : FScriptExecutionError()
        {
            readFromValue(obj);
        }

        ~FScriptExecutionError();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FLogStatement : public FPlayFabBaseModel
    {
        // [optional] Optional object accompanying the message as contextual information
        FJsonKeeper Data;

        // [optional] 'Debug', 'Info', or 'Error'
        FString Level;

        // [optional] undefined
        FString Message;

        FLogStatement() :
            FPlayFabBaseModel(),
            Data(),
            Level(),
            Message()
            {}

        FLogStatement(const FLogStatement& src) :
            FPlayFabBaseModel(),
            Data(src.Data),
            Level(src.Level),
            Message(src.Message)
            {}

        FLogStatement(const TSharedPtr<FJsonObject>& obj) : FLogStatement()
        {
            readFromValue(obj);
        }

        ~FLogStatement();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FExecuteCloudScriptResult : public FPlayFabBaseModel
    {
        // Number of PlayFab API requests issued by the CloudScript function
        int32 APIRequestsIssued;

        // [optional] Information about the error, if any, that occurred during execution
        TSharedPtr<FScriptExecutionError> Error;

        double ExecutionTimeSeconds;

        // [optional] The name of the function that executed
        FString FunctionName;

        // [optional] The object returned from the CloudScript function, if any
        FJsonKeeper FunctionResult;

        /**
         * [optional] Flag indicating if the FunctionResult was too large and was subsequently dropped from this event. This only occurs if
         * the total event size is larger than 350KB.
         */
        Boxed<bool> FunctionResultTooLarge;

        // Number of external HTTP requests issued by the CloudScript function
        int32 HttpRequestsIssued;

        /**
         * [optional] Entries logged during the function execution. These include both entries logged in the function code using log.info()
         * and log.error() and error entries for API and HTTP request failures.
         */
        TArray<FLogStatement> Logs;
        /**
         * [optional] Flag indicating if the logs were too large and were subsequently dropped from this event. This only occurs if the total
         * event size is larger than 350KB after the FunctionResult was removed.
         */
        Boxed<bool> LogsTooLarge;

        uint32 MemoryConsumedBytes;

        /**
         * Processor time consumed while executing the function. This does not include time spent waiting on API calls or HTTP
         * requests.
         */
        double ProcessorTimeSeconds;

        // The revision of the CloudScript that executed
        int32 Revision;

        FExecuteCloudScriptResult() :
            FPlayFabBaseModel(),
            APIRequestsIssued(0),
            Error(nullptr),
            ExecutionTimeSeconds(0),
            FunctionName(),
            FunctionResult(),
            FunctionResultTooLarge(),
            HttpRequestsIssued(0),
            Logs(),
            LogsTooLarge(),
            MemoryConsumedBytes(0),
            ProcessorTimeSeconds(0),
            Revision(0)
            {}

        FExecuteCloudScriptResult(const FExecuteCloudScriptResult& src) :
            FPlayFabBaseModel(),
            APIRequestsIssued(src.APIRequestsIssued),
            Error(src.Error.IsValid() ? MakeShareable(new FScriptExecutionError(*src.Error)) : nullptr),
            ExecutionTimeSeconds(src.ExecutionTimeSeconds),
            FunctionName(src.FunctionName),
            FunctionResult(src.FunctionResult),
            FunctionResultTooLarge(src.FunctionResultTooLarge),
            HttpRequestsIssued(src.HttpRequestsIssued),
            Logs(src.Logs),
            LogsTooLarge(src.LogsTooLarge),
            MemoryConsumedBytes(src.MemoryConsumedBytes),
            ProcessorTimeSeconds(src.ProcessorTimeSeconds),
            Revision(src.Revision)
            {}

        FExecuteCloudScriptResult(const TSharedPtr<FJsonObject>& obj) : FExecuteCloudScriptResult()
        {
            readFromValue(obj);
        }

        ~FExecuteCloudScriptResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FCloudScriptTaskSummary : public FPlayFabBaseModel
    {
        // [optional] UTC timestamp when the task completed.
        Boxed<FDateTime> CompletedAt;

        // [optional] Estimated time remaining in seconds.
        Boxed<double> EstimatedSecondsRemaining;

        // [optional] Progress represented as percentage.
        Boxed<double> PercentComplete;

        // [optional] Result of CloudScript execution
        TSharedPtr<FExecuteCloudScriptResult> Result;

        // [optional] If manually scheduled, ID of user who scheduled the task.
        FString ScheduledByUserId;

        // UTC timestamp when the task started.
        FDateTime StartedAt;

        // [optional] Current status of the task instance.
        Boxed<TaskInstanceStatus> Status;

        // [optional] Identifier of the task this instance belongs to.
        TSharedPtr<FNameIdentifier> TaskIdentifier;

        // [optional] ID of the task instance.
        FString TaskInstanceId;

        FCloudScriptTaskSummary() :
            FPlayFabBaseModel(),
            CompletedAt(),
            EstimatedSecondsRemaining(),
            PercentComplete(),
            Result(nullptr),
            ScheduledByUserId(),
            StartedAt(0),
            Status(),
            TaskIdentifier(nullptr),
            TaskInstanceId()
            {}

        FCloudScriptTaskSummary(const FCloudScriptTaskSummary& src) :
            FPlayFabBaseModel(),
            CompletedAt(src.CompletedAt),
            EstimatedSecondsRemaining(src.EstimatedSecondsRemaining),
            PercentComplete(src.PercentComplete),
            Result(src.Result.IsValid() ? MakeShareable(new FExecuteCloudScriptResult(*src.Result)) : nullptr),
            ScheduledByUserId(src.ScheduledByUserId),
            StartedAt(src.StartedAt),
            Status(src.Status),
            TaskIdentifier(src.TaskIdentifier.IsValid() ? MakeShareable(new FNameIdentifier(*src.TaskIdentifier)) : nullptr),
            TaskInstanceId(src.TaskInstanceId)
            {}

        FCloudScriptTaskSummary(const TSharedPtr<FJsonObject>& obj) : FCloudScriptTaskSummary()
        {
            readFromValue(obj);
        }

        ~FCloudScriptTaskSummary();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FCloudScriptVersionStatus : public FPlayFabBaseModel
    {
        // Most recent revision for this Cloud Script version
        int32 LatestRevision;

        // Published code revision for this Cloud Script version
        int32 PublishedRevision;

        // Version number
        int32 Version;

        FCloudScriptVersionStatus() :
            FPlayFabBaseModel(),
            LatestRevision(0),
            PublishedRevision(0),
            Version(0)
            {}

        FCloudScriptVersionStatus(const FCloudScriptVersionStatus& src) :
            FPlayFabBaseModel(),
            LatestRevision(src.LatestRevision),
            PublishedRevision(src.PublishedRevision),
            Version(src.Version)
            {}

        FCloudScriptVersionStatus(const TSharedPtr<FJsonObject>& obj) : FCloudScriptVersionStatus()
        {
            readFromValue(obj);
        }

        ~FCloudScriptVersionStatus();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    enum EmailVerificationStatus
    {
        EmailVerificationStatusUnverified,
        EmailVerificationStatusPending,
        EmailVerificationStatusConfirmed
    };

    PLAYFAB_API void writeEmailVerificationStatusEnumJSON(EmailVerificationStatus enumVal, JsonWriter& writer);
    PLAYFAB_API EmailVerificationStatus readEmailVerificationStatusFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFAB_API EmailVerificationStatus readEmailVerificationStatusFromValue(const FString& value);

    struct PLAYFAB_API FContactEmailInfo : public FPlayFabBaseModel
    {
        // [optional] The email address
        FString EmailAddress;

        // [optional] The name of the email info data
        FString Name;

        // [optional] The verification status of the email
        Boxed<EmailVerificationStatus> VerificationStatus;

        FContactEmailInfo() :
            FPlayFabBaseModel(),
            EmailAddress(),
            Name(),
            VerificationStatus()
            {}

        FContactEmailInfo(const FContactEmailInfo& src) :
            FPlayFabBaseModel(),
            EmailAddress(src.EmailAddress),
            Name(src.Name),
            VerificationStatus(src.VerificationStatus)
            {}

        FContactEmailInfo(const TSharedPtr<FJsonObject>& obj) : FContactEmailInfo()
        {
            readFromValue(obj);
        }

        ~FContactEmailInfo();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FContactEmailInfoModel : public FPlayFabBaseModel
    {
        // [optional] The email address
        FString EmailAddress;

        // [optional] The name of the email info data
        FString Name;

        // [optional] The verification status of the email
        Boxed<EmailVerificationStatus> VerificationStatus;

        FContactEmailInfoModel() :
            FPlayFabBaseModel(),
            EmailAddress(),
            Name(),
            VerificationStatus()
            {}

        FContactEmailInfoModel(const FContactEmailInfoModel& src) :
            FPlayFabBaseModel(),
            EmailAddress(src.EmailAddress),
            Name(src.Name),
            VerificationStatus(src.VerificationStatus)
            {}

        FContactEmailInfoModel(const TSharedPtr<FJsonObject>& obj) : FContactEmailInfoModel()
        {
            readFromValue(obj);
        }

        ~FContactEmailInfoModel();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FContentInfo : public FPlayFabBaseModel
    {
        // [optional] Key of the content
        FString Key;

        // Last modified time
        FDateTime LastModified;

        // Size of the content in bytes
        uint32 Size;

        FContentInfo() :
            FPlayFabBaseModel(),
            Key(),
            LastModified(0),
            Size(0)
            {}

        FContentInfo(const FContentInfo& src) :
            FPlayFabBaseModel(),
            Key(src.Key),
            LastModified(src.LastModified),
            Size(src.Size)
            {}

        FContentInfo(const TSharedPtr<FJsonObject>& obj) : FContentInfo()
        {
            readFromValue(obj);
        }

        ~FContentInfo();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    enum ContinentCode
    {
        ContinentCodeAF,
        ContinentCodeAN,
        ContinentCodeAS,
        ContinentCodeEU,
        ContinentCodeNA,
        ContinentCodeOC,
        ContinentCodeSA
    };

    PLAYFAB_API void writeContinentCodeEnumJSON(ContinentCode enumVal, JsonWriter& writer);
    PLAYFAB_API ContinentCode readContinentCodeFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFAB_API ContinentCode readContinentCodeFromValue(const FString& value);

    enum CountryCode
    {
        CountryCodeAF,
        CountryCodeAX,
        CountryCodeAL,
        CountryCodeDZ,
        CountryCodeAS,
        CountryCodeAD,
        CountryCodeAO,
        CountryCodeAI,
        CountryCodeAQ,
        CountryCodeAG,
        CountryCodeAR,
        CountryCodeAM,
        CountryCodeAW,
        CountryCodeAU,
        CountryCodeAT,
        CountryCodeAZ,
        CountryCodeBS,
        CountryCodeBH,
        CountryCodeBD,
        CountryCodeBB,
        CountryCodeBY,
        CountryCodeBE,
        CountryCodeBZ,
        CountryCodeBJ,
        CountryCodeBM,
        CountryCodeBT,
        CountryCodeBO,
        CountryCodeBQ,
        CountryCodeBA,
        CountryCodeBW,
        CountryCodeBV,
        CountryCodeBR,
        CountryCodeIO,
        CountryCodeBN,
        CountryCodeBG,
        CountryCodeBF,
        CountryCodeBI,
        CountryCodeKH,
        CountryCodeCM,
        CountryCodeCA,
        CountryCodeCV,
        CountryCodeKY,
        CountryCodeCF,
        CountryCodeTD,
        CountryCodeCL,
        CountryCodeCN,
        CountryCodeCX,
        CountryCodeCC,
        CountryCodeCO,
        CountryCodeKM,
        CountryCodeCG,
        CountryCodeCD,
        CountryCodeCK,
        CountryCodeCR,
        CountryCodeCI,
        CountryCodeHR,
        CountryCodeCU,
        CountryCodeCW,
        CountryCodeCY,
        CountryCodeCZ,
        CountryCodeDK,
        CountryCodeDJ,
        CountryCodeDM,
        CountryCodeDO,
        CountryCodeEC,
        CountryCodeEG,
        CountryCodeSV,
        CountryCodeGQ,
        CountryCodeER,
        CountryCodeEE,
        CountryCodeET,
        CountryCodeFK,
        CountryCodeFO,
        CountryCodeFJ,
        CountryCodeFI,
        CountryCodeFR,
        CountryCodeGF,
        CountryCodePF,
        CountryCodeTF,
        CountryCodeGA,
        CountryCodeGM,
        CountryCodeGE,
        CountryCodeDE,
        CountryCodeGH,
        CountryCodeGI,
        CountryCodeGR,
        CountryCodeGL,
        CountryCodeGD,
        CountryCodeGP,
        CountryCodeGU,
        CountryCodeGT,
        CountryCodeGG,
        CountryCodeGN,
        CountryCodeGW,
        CountryCodeGY,
        CountryCodeHT,
        CountryCodeHM,
        CountryCodeVA,
        CountryCodeHN,
        CountryCodeHK,
        CountryCodeHU,
        CountryCodeIS,
        CountryCodeIN,
        CountryCodeID,
        CountryCodeIR,
        CountryCodeIQ,
        CountryCodeIE,
        CountryCodeIM,
        CountryCodeIL,
        CountryCodeIT,
        CountryCodeJM,
        CountryCodeJP,
        CountryCodeJE,
        CountryCodeJO,
        CountryCodeKZ,
        CountryCodeKE,
        CountryCodeKI,
        CountryCodeKP,
        CountryCodeKR,
        CountryCodeKW,
        CountryCodeKG,
        CountryCodeLA,
        CountryCodeLV,
        CountryCodeLB,
        CountryCodeLS,
        CountryCodeLR,
        CountryCodeLY,
        CountryCodeLI,
        CountryCodeLT,
        CountryCodeLU,
        CountryCodeMO,
        CountryCodeMK,
        CountryCodeMG,
        CountryCodeMW,
        CountryCodeMY,
        CountryCodeMV,
        CountryCodeML,
        CountryCodeMT,
        CountryCodeMH,
        CountryCodeMQ,
        CountryCodeMR,
        CountryCodeMU,
        CountryCodeYT,
        CountryCodeMX,
        CountryCodeFM,
        CountryCodeMD,
        CountryCodeMC,
        CountryCodeMN,
        CountryCodeME,
        CountryCodeMS,
        CountryCodeMA,
        CountryCodeMZ,
        CountryCodeMM,
        CountryCodeNA,
        CountryCodeNR,
        CountryCodeNP,
        CountryCodeNL,
        CountryCodeNC,
        CountryCodeNZ,
        CountryCodeNI,
        CountryCodeNE,
        CountryCodeNG,
        CountryCodeNU,
        CountryCodeNF,
        CountryCodeMP,
        CountryCodeNO,
        CountryCodeOM,
        CountryCodePK,
        CountryCodePW,
        CountryCodePS,
        CountryCodePA,
        CountryCodePG,
        CountryCodePY,
        CountryCodePE,
        CountryCodePH,
        CountryCodePN,
        CountryCodePL,
        CountryCodePT,
        CountryCodePR,
        CountryCodeQA,
        CountryCodeRE,
        CountryCodeRO,
        CountryCodeRU,
        CountryCodeRW,
        CountryCodeBL,
        CountryCodeSH,
        CountryCodeKN,
        CountryCodeLC,
        CountryCodeMF,
        CountryCodePM,
        CountryCodeVC,
        CountryCodeWS,
        CountryCodeSM,
        CountryCodeST,
        CountryCodeSA,
        CountryCodeSN,
        CountryCodeRS,
        CountryCodeSC,
        CountryCodeSL,
        CountryCodeSG,
        CountryCodeSX,
        CountryCodeSK,
        CountryCodeSI,
        CountryCodeSB,
        CountryCodeSO,
        CountryCodeZA,
        CountryCodeGS,
        CountryCodeSS,
        CountryCodeES,
        CountryCodeLK,
        CountryCodeSD,
        CountryCodeSR,
        CountryCodeSJ,
        CountryCodeSZ,
        CountryCodeSE,
        CountryCodeCH,
        CountryCodeSY,
        CountryCodeTW,
        CountryCodeTJ,
        CountryCodeTZ,
        CountryCodeTH,
        CountryCodeTL,
        CountryCodeTG,
        CountryCodeTK,
        CountryCodeTO,
        CountryCodeTT,
        CountryCodeTN,
        CountryCodeTR,
        CountryCodeTM,
        CountryCodeTC,
        CountryCodeTV,
        CountryCodeUG,
        CountryCodeUA,
        CountryCodeAE,
        CountryCodeGB,
        CountryCodeUS,
        CountryCodeUM,
        CountryCodeUY,
        CountryCodeUZ,
        CountryCodeVU,
        CountryCodeVE,
        CountryCodeVN,
        CountryCodeVG,
        CountryCodeVI,
        CountryCodeWF,
        CountryCodeEH,
        CountryCodeYE,
        CountryCodeZM,
        CountryCodeZW
    };

    PLAYFAB_API void writeCountryCodeEnumJSON(CountryCode enumVal, JsonWriter& writer);
    PLAYFAB_API CountryCode readCountryCodeFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFAB_API CountryCode readCountryCodeFromValue(const FString& value);

    struct PLAYFAB_API FCreateActionsOnPlayerSegmentTaskRequest : public FPlayFabBaseModel
    {
        // [optional] Description the task
        FString Description;

        // Whether the schedule is active. Inactive schedule will not trigger task execution.
        bool IsActive;

        // Name of the task. This is a unique identifier for tasks in the title.
        FString Name;

        // Task details related to segment and action
        FActionsOnPlayersInSegmentTaskParameter Parameter;

        // [optional] Cron expression for the run schedule of the task. The expression should be in UTC.
        FString Schedule;

        FCreateActionsOnPlayerSegmentTaskRequest() :
            FPlayFabBaseModel(),
            Description(),
            IsActive(false),
            Name(),
            Parameter(),
            Schedule()
            {}

        FCreateActionsOnPlayerSegmentTaskRequest(const FCreateActionsOnPlayerSegmentTaskRequest& src) :
            FPlayFabBaseModel(),
            Description(src.Description),
            IsActive(src.IsActive),
            Name(src.Name),
            Parameter(src.Parameter),
            Schedule(src.Schedule)
            {}

        FCreateActionsOnPlayerSegmentTaskRequest(const TSharedPtr<FJsonObject>& obj) : FCreateActionsOnPlayerSegmentTaskRequest()
        {
            readFromValue(obj);
        }

        ~FCreateActionsOnPlayerSegmentTaskRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FCreateCloudScriptTaskRequest : public FPlayFabBaseModel
    {
        // [optional] Description the task
        FString Description;

        // Whether the schedule is active. Inactive schedule will not trigger task execution.
        bool IsActive;

        // Name of the task. This is a unique identifier for tasks in the title.
        FString Name;

        // Task details related to CloudScript
        FCloudScriptTaskParameter Parameter;

        // [optional] Cron expression for the run schedule of the task. The expression should be in UTC.
        FString Schedule;

        FCreateCloudScriptTaskRequest() :
            FPlayFabBaseModel(),
            Description(),
            IsActive(false),
            Name(),
            Parameter(),
            Schedule()
            {}

        FCreateCloudScriptTaskRequest(const FCreateCloudScriptTaskRequest& src) :
            FPlayFabBaseModel(),
            Description(src.Description),
            IsActive(src.IsActive),
            Name(src.Name),
            Parameter(src.Parameter),
            Schedule(src.Schedule)
            {}

        FCreateCloudScriptTaskRequest(const TSharedPtr<FJsonObject>& obj) : FCreateCloudScriptTaskRequest()
        {
            readFromValue(obj);
        }

        ~FCreateCloudScriptTaskRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FCreatePlayerSharedSecretRequest : public FPlayFabBaseModel
    {
        // [optional] Friendly name for this key
        FString FriendlyName;

        FCreatePlayerSharedSecretRequest() :
            FPlayFabBaseModel(),
            FriendlyName()
            {}

        FCreatePlayerSharedSecretRequest(const FCreatePlayerSharedSecretRequest& src) :
            FPlayFabBaseModel(),
            FriendlyName(src.FriendlyName)
            {}

        FCreatePlayerSharedSecretRequest(const TSharedPtr<FJsonObject>& obj) : FCreatePlayerSharedSecretRequest()
        {
            readFromValue(obj);
        }

        ~FCreatePlayerSharedSecretRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FCreatePlayerSharedSecretResult : public FPlayFabBaseModel
    {
        // [optional] The player shared secret to use when calling Client/GetTitlePublicKey
        FString SecretKey;

        FCreatePlayerSharedSecretResult() :
            FPlayFabBaseModel(),
            SecretKey()
            {}

        FCreatePlayerSharedSecretResult(const FCreatePlayerSharedSecretResult& src) :
            FPlayFabBaseModel(),
            SecretKey(src.SecretKey)
            {}

        FCreatePlayerSharedSecretResult(const TSharedPtr<FJsonObject>& obj) : FCreatePlayerSharedSecretResult()
        {
            readFromValue(obj);
        }

        ~FCreatePlayerSharedSecretResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    enum StatisticAggregationMethod
    {
        StatisticAggregationMethodLast,
        StatisticAggregationMethodMin,
        StatisticAggregationMethodMax,
        StatisticAggregationMethodSum
    };

    PLAYFAB_API void writeStatisticAggregationMethodEnumJSON(StatisticAggregationMethod enumVal, JsonWriter& writer);
    PLAYFAB_API StatisticAggregationMethod readStatisticAggregationMethodFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFAB_API StatisticAggregationMethod readStatisticAggregationMethodFromValue(const FString& value);

    enum StatisticResetIntervalOption
    {
        StatisticResetIntervalOptionNever,
        StatisticResetIntervalOptionHour,
        StatisticResetIntervalOptionDay,
        StatisticResetIntervalOptionWeek,
        StatisticResetIntervalOptionMonth
    };

    PLAYFAB_API void writeStatisticResetIntervalOptionEnumJSON(StatisticResetIntervalOption enumVal, JsonWriter& writer);
    PLAYFAB_API StatisticResetIntervalOption readStatisticResetIntervalOptionFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFAB_API StatisticResetIntervalOption readStatisticResetIntervalOptionFromValue(const FString& value);

    struct PLAYFAB_API FCreatePlayerStatisticDefinitionRequest : public FPlayFabBaseModel
    {
        // [optional] the aggregation method to use in updating the statistic (defaults to last)
        Boxed<StatisticAggregationMethod> AggregationMethod;

        // unique name of the statistic
        FString StatisticName;

        // [optional] interval at which the values of the statistic for all players are reset (resets begin at the next interval boundary)
        Boxed<StatisticResetIntervalOption> VersionChangeInterval;

        FCreatePlayerStatisticDefinitionRequest() :
            FPlayFabBaseModel(),
            AggregationMethod(),
            StatisticName(),
            VersionChangeInterval()
            {}

        FCreatePlayerStatisticDefinitionRequest(const FCreatePlayerStatisticDefinitionRequest& src) :
            FPlayFabBaseModel(),
            AggregationMethod(src.AggregationMethod),
            StatisticName(src.StatisticName),
            VersionChangeInterval(src.VersionChangeInterval)
            {}

        FCreatePlayerStatisticDefinitionRequest(const TSharedPtr<FJsonObject>& obj) : FCreatePlayerStatisticDefinitionRequest()
        {
            readFromValue(obj);
        }

        ~FCreatePlayerStatisticDefinitionRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FPlayerStatisticDefinition : public FPlayFabBaseModel
    {
        // [optional] the aggregation method to use in updating the statistic (defaults to last)
        Boxed<StatisticAggregationMethod> AggregationMethod;

        // current active version of the statistic, incremented each time the statistic resets
        uint32 CurrentVersion;

        // [optional] unique name of the statistic
        FString StatisticName;

        // [optional] interval at which the values of the statistic for all players are reset automatically
        Boxed<StatisticResetIntervalOption> VersionChangeInterval;

        FPlayerStatisticDefinition() :
            FPlayFabBaseModel(),
            AggregationMethod(),
            CurrentVersion(0),
            StatisticName(),
            VersionChangeInterval()
            {}

        FPlayerStatisticDefinition(const FPlayerStatisticDefinition& src) :
            FPlayFabBaseModel(),
            AggregationMethod(src.AggregationMethod),
            CurrentVersion(src.CurrentVersion),
            StatisticName(src.StatisticName),
            VersionChangeInterval(src.VersionChangeInterval)
            {}

        FPlayerStatisticDefinition(const TSharedPtr<FJsonObject>& obj) : FPlayerStatisticDefinition()
        {
            readFromValue(obj);
        }

        ~FPlayerStatisticDefinition();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FCreatePlayerStatisticDefinitionResult : public FPlayFabBaseModel
    {
        // [optional] created statistic definition
        TSharedPtr<FPlayerStatisticDefinition> Statistic;

        FCreatePlayerStatisticDefinitionResult() :
            FPlayFabBaseModel(),
            Statistic(nullptr)
            {}

        FCreatePlayerStatisticDefinitionResult(const FCreatePlayerStatisticDefinitionResult& src) :
            FPlayFabBaseModel(),
            Statistic(src.Statistic.IsValid() ? MakeShareable(new FPlayerStatisticDefinition(*src.Statistic)) : nullptr)
            {}

        FCreatePlayerStatisticDefinitionResult(const TSharedPtr<FJsonObject>& obj) : FCreatePlayerStatisticDefinitionResult()
        {
            readFromValue(obj);
        }

        ~FCreatePlayerStatisticDefinitionResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FCreateTaskResult : public FPlayFabBaseModel
    {
        // [optional] ID of the task
        FString TaskId;

        FCreateTaskResult() :
            FPlayFabBaseModel(),
            TaskId()
            {}

        FCreateTaskResult(const FCreateTaskResult& src) :
            FPlayFabBaseModel(),
            TaskId(src.TaskId)
            {}

        FCreateTaskResult(const TSharedPtr<FJsonObject>& obj) : FCreateTaskResult()
        {
            readFromValue(obj);
        }

        ~FCreateTaskResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    enum Currency
    {
        CurrencyAED,
        CurrencyAFN,
        CurrencyALL,
        CurrencyAMD,
        CurrencyANG,
        CurrencyAOA,
        CurrencyARS,
        CurrencyAUD,
        CurrencyAWG,
        CurrencyAZN,
        CurrencyBAM,
        CurrencyBBD,
        CurrencyBDT,
        CurrencyBGN,
        CurrencyBHD,
        CurrencyBIF,
        CurrencyBMD,
        CurrencyBND,
        CurrencyBOB,
        CurrencyBRL,
        CurrencyBSD,
        CurrencyBTN,
        CurrencyBWP,
        CurrencyBYR,
        CurrencyBZD,
        CurrencyCAD,
        CurrencyCDF,
        CurrencyCHF,
        CurrencyCLP,
        CurrencyCNY,
        CurrencyCOP,
        CurrencyCRC,
        CurrencyCUC,
        CurrencyCUP,
        CurrencyCVE,
        CurrencyCZK,
        CurrencyDJF,
        CurrencyDKK,
        CurrencyDOP,
        CurrencyDZD,
        CurrencyEGP,
        CurrencyERN,
        CurrencyETB,
        CurrencyEUR,
        CurrencyFJD,
        CurrencyFKP,
        CurrencyGBP,
        CurrencyGEL,
        CurrencyGGP,
        CurrencyGHS,
        CurrencyGIP,
        CurrencyGMD,
        CurrencyGNF,
        CurrencyGTQ,
        CurrencyGYD,
        CurrencyHKD,
        CurrencyHNL,
        CurrencyHRK,
        CurrencyHTG,
        CurrencyHUF,
        CurrencyIDR,
        CurrencyILS,
        CurrencyIMP,
        CurrencyINR,
        CurrencyIQD,
        CurrencyIRR,
        CurrencyISK,
        CurrencyJEP,
        CurrencyJMD,
        CurrencyJOD,
        CurrencyJPY,
        CurrencyKES,
        CurrencyKGS,
        CurrencyKHR,
        CurrencyKMF,
        CurrencyKPW,
        CurrencyKRW,
        CurrencyKWD,
        CurrencyKYD,
        CurrencyKZT,
        CurrencyLAK,
        CurrencyLBP,
        CurrencyLKR,
        CurrencyLRD,
        CurrencyLSL,
        CurrencyLYD,
        CurrencyMAD,
        CurrencyMDL,
        CurrencyMGA,
        CurrencyMKD,
        CurrencyMMK,
        CurrencyMNT,
        CurrencyMOP,
        CurrencyMRO,
        CurrencyMUR,
        CurrencyMVR,
        CurrencyMWK,
        CurrencyMXN,
        CurrencyMYR,
        CurrencyMZN,
        CurrencyNAD,
        CurrencyNGN,
        CurrencyNIO,
        CurrencyNOK,
        CurrencyNPR,
        CurrencyNZD,
        CurrencyOMR,
        CurrencyPAB,
        CurrencyPEN,
        CurrencyPGK,
        CurrencyPHP,
        CurrencyPKR,
        CurrencyPLN,
        CurrencyPYG,
        CurrencyQAR,
        CurrencyRON,
        CurrencyRSD,
        CurrencyRUB,
        CurrencyRWF,
        CurrencySAR,
        CurrencySBD,
        CurrencySCR,
        CurrencySDG,
        CurrencySEK,
        CurrencySGD,
        CurrencySHP,
        CurrencySLL,
        CurrencySOS,
        CurrencySPL,
        CurrencySRD,
        CurrencySTD,
        CurrencySVC,
        CurrencySYP,
        CurrencySZL,
        CurrencyTHB,
        CurrencyTJS,
        CurrencyTMT,
        CurrencyTND,
        CurrencyTOP,
        CurrencyTRY,
        CurrencyTTD,
        CurrencyTVD,
        CurrencyTWD,
        CurrencyTZS,
        CurrencyUAH,
        CurrencyUGX,
        CurrencyUSD,
        CurrencyUYU,
        CurrencyUZS,
        CurrencyVEF,
        CurrencyVND,
        CurrencyVUV,
        CurrencyWST,
        CurrencyXAF,
        CurrencyXCD,
        CurrencyXDR,
        CurrencyXOF,
        CurrencyXPF,
        CurrencyYER,
        CurrencyZAR,
        CurrencyZMW,
        CurrencyZWD
    };

    PLAYFAB_API void writeCurrencyEnumJSON(Currency enumVal, JsonWriter& writer);
    PLAYFAB_API Currency readCurrencyFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFAB_API Currency readCurrencyFromValue(const FString& value);

    struct PLAYFAB_API FDeleteContentRequest : public FPlayFabBaseModel
    {
        // Key of the content item to be deleted
        FString Key;

        FDeleteContentRequest() :
            FPlayFabBaseModel(),
            Key()
            {}

        FDeleteContentRequest(const FDeleteContentRequest& src) :
            FPlayFabBaseModel(),
            Key(src.Key)
            {}

        FDeleteContentRequest(const TSharedPtr<FJsonObject>& obj) : FDeleteContentRequest()
        {
            readFromValue(obj);
        }

        ~FDeleteContentRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FDeletePlayerRequest : public FPlayFabBaseModel
    {
        // Unique PlayFab assigned ID of the user on whom the operation will be performed.
        FString PlayFabId;

        FDeletePlayerRequest() :
            FPlayFabBaseModel(),
            PlayFabId()
            {}

        FDeletePlayerRequest(const FDeletePlayerRequest& src) :
            FPlayFabBaseModel(),
            PlayFabId(src.PlayFabId)
            {}

        FDeletePlayerRequest(const TSharedPtr<FJsonObject>& obj) : FDeletePlayerRequest()
        {
            readFromValue(obj);
        }

        ~FDeletePlayerRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FDeletePlayerResult : public FPlayFabBaseModel
    {
        FDeletePlayerResult() :
            FPlayFabBaseModel()
            {}

        FDeletePlayerResult(const FDeletePlayerResult& src) :
            FPlayFabBaseModel()
            {}

        FDeletePlayerResult(const TSharedPtr<FJsonObject>& obj) : FDeletePlayerResult()
        {
            readFromValue(obj);
        }

        ~FDeletePlayerResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FDeletePlayerSharedSecretRequest : public FPlayFabBaseModel
    {
        // [optional] The shared secret key to delete
        FString SecretKey;

        FDeletePlayerSharedSecretRequest() :
            FPlayFabBaseModel(),
            SecretKey()
            {}

        FDeletePlayerSharedSecretRequest(const FDeletePlayerSharedSecretRequest& src) :
            FPlayFabBaseModel(),
            SecretKey(src.SecretKey)
            {}

        FDeletePlayerSharedSecretRequest(const TSharedPtr<FJsonObject>& obj) : FDeletePlayerSharedSecretRequest()
        {
            readFromValue(obj);
        }

        ~FDeletePlayerSharedSecretRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FDeletePlayerSharedSecretResult : public FPlayFabBaseModel
    {
        FDeletePlayerSharedSecretResult() :
            FPlayFabBaseModel()
            {}

        FDeletePlayerSharedSecretResult(const FDeletePlayerSharedSecretResult& src) :
            FPlayFabBaseModel()
            {}

        FDeletePlayerSharedSecretResult(const TSharedPtr<FJsonObject>& obj) : FDeletePlayerSharedSecretResult()
        {
            readFromValue(obj);
        }

        ~FDeletePlayerSharedSecretResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FDeleteStoreRequest : public FPlayFabBaseModel
    {
        // [optional] catalog version of the store to delete. If null, uses the default catalog.
        FString CatalogVersion;

        // unqiue identifier for the store which is to be deleted
        FString StoreId;

        FDeleteStoreRequest() :
            FPlayFabBaseModel(),
            CatalogVersion(),
            StoreId()
            {}

        FDeleteStoreRequest(const FDeleteStoreRequest& src) :
            FPlayFabBaseModel(),
            CatalogVersion(src.CatalogVersion),
            StoreId(src.StoreId)
            {}

        FDeleteStoreRequest(const TSharedPtr<FJsonObject>& obj) : FDeleteStoreRequest()
        {
            readFromValue(obj);
        }

        ~FDeleteStoreRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FDeleteStoreResult : public FPlayFabBaseModel
    {
        FDeleteStoreResult() :
            FPlayFabBaseModel()
            {}

        FDeleteStoreResult(const FDeleteStoreResult& src) :
            FPlayFabBaseModel()
            {}

        FDeleteStoreResult(const TSharedPtr<FJsonObject>& obj) : FDeleteStoreResult()
        {
            readFromValue(obj);
        }

        ~FDeleteStoreResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FDeleteTaskRequest : public FPlayFabBaseModel
    {
        // [optional] Specify either the task ID or the name of task to be deleted.
        TSharedPtr<FNameIdentifier> Identifier;

        FDeleteTaskRequest() :
            FPlayFabBaseModel(),
            Identifier(nullptr)
            {}

        FDeleteTaskRequest(const FDeleteTaskRequest& src) :
            FPlayFabBaseModel(),
            Identifier(src.Identifier.IsValid() ? MakeShareable(new FNameIdentifier(*src.Identifier)) : nullptr)
            {}

        FDeleteTaskRequest(const TSharedPtr<FJsonObject>& obj) : FDeleteTaskRequest()
        {
            readFromValue(obj);
        }

        ~FDeleteTaskRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FDeleteTitleRequest : public FPlayFabBaseModel
    {
        FDeleteTitleRequest() :
            FPlayFabBaseModel()
            {}

        FDeleteTitleRequest(const FDeleteTitleRequest& src) :
            FPlayFabBaseModel()
            {}

        FDeleteTitleRequest(const TSharedPtr<FJsonObject>& obj) : FDeleteTitleRequest()
        {
            readFromValue(obj);
        }

        ~FDeleteTitleRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FDeleteTitleResult : public FPlayFabBaseModel
    {
        FDeleteTitleResult() :
            FPlayFabBaseModel()
            {}

        FDeleteTitleResult(const FDeleteTitleResult& src) :
            FPlayFabBaseModel()
            {}

        FDeleteTitleResult(const TSharedPtr<FJsonObject>& obj) : FDeleteTitleResult()
        {
            readFromValue(obj);
        }

        ~FDeleteTitleResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FDeleteUsersRequest : public FPlayFabBaseModel
    {
        // An array of unique PlayFab assigned ID of the user on whom the operation will be performed.
        TArray<FString> PlayFabIds;
        /**
         * Unique identifier for the title, found in the Settings > Game Properties section of the PlayFab developer site when a
         * title has been selected.
         */
        FString TitleId;

        FDeleteUsersRequest() :
            FPlayFabBaseModel(),
            PlayFabIds(),
            TitleId()
            {}

        FDeleteUsersRequest(const FDeleteUsersRequest& src) :
            FPlayFabBaseModel(),
            PlayFabIds(src.PlayFabIds),
            TitleId(src.TitleId)
            {}

        FDeleteUsersRequest(const TSharedPtr<FJsonObject>& obj) : FDeleteUsersRequest()
        {
            readFromValue(obj);
        }

        ~FDeleteUsersRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FDeleteUsersResult : public FPlayFabBaseModel
    {
        FDeleteUsersResult() :
            FPlayFabBaseModel()
            {}

        FDeleteUsersResult(const FDeleteUsersResult& src) :
            FPlayFabBaseModel()
            {}

        FDeleteUsersResult(const TSharedPtr<FJsonObject>& obj) : FDeleteUsersResult()
        {
            readFromValue(obj);
        }

        ~FDeleteUsersResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    enum EffectType
    {
        EffectTypeAllow,
        EffectTypeDeny
    };

    PLAYFAB_API void writeEffectTypeEnumJSON(EffectType enumVal, JsonWriter& writer);
    PLAYFAB_API EffectType readEffectTypeFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFAB_API EffectType readEffectTypeFromValue(const FString& value);

    struct PLAYFAB_API FEmptyResult : public FPlayFabBaseModel
    {
        FEmptyResult() :
            FPlayFabBaseModel()
            {}

        FEmptyResult(const FEmptyResult& src) :
            FPlayFabBaseModel()
            {}

        FEmptyResult(const TSharedPtr<FJsonObject>& obj) : FEmptyResult()
        {
            readFromValue(obj);
        }

        ~FEmptyResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    enum EntityTypes
    {
        EntityTypestitle,
        EntityTypesmaster_player_account,
        EntityTypestitle_player_account,
        EntityTypescharacter,
        EntityTypesgroup
    };

    PLAYFAB_API void writeEntityTypesEnumJSON(EntityTypes enumVal, JsonWriter& writer);
    PLAYFAB_API EntityTypes readEntityTypesFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFAB_API EntityTypes readEntityTypesFromValue(const FString& value);

    struct PLAYFAB_API FEntityKey : public FPlayFabBaseModel
    {
        // Entity profile ID.
        FString Id;

        // [optional] Entity type. Optional to be used but one of EntityType or EntityTypeString must be set.
        Boxed<EntityTypes> Type;

        // [optional] Entity type. Optional to be used but one of EntityType or EntityTypeString must be set.
        FString TypeString;

        FEntityKey() :
            FPlayFabBaseModel(),
            Id(),
            Type(),
            TypeString()
            {}

        FEntityKey(const FEntityKey& src) :
            FPlayFabBaseModel(),
            Id(src.Id),
            Type(src.Type),
            TypeString(src.TypeString)
            {}

        FEntityKey(const TSharedPtr<FJsonObject>& obj) : FEntityKey()
        {
            readFromValue(obj);
        }

        ~FEntityKey();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGameModeInfo : public FPlayFabBaseModel
    {
        // specific game mode type
        FString Gamemode;

        // maximum user count a specific Game Server Instance can support
        uint32 MaxPlayerCount;

        // minimum user count required for this Game Server Instance to continue (usually 1)
        uint32 MinPlayerCount;

        // [optional] whether to start as an open session, meaning that players can matchmake into it (defaults to true)
        Boxed<bool> StartOpen;

        FGameModeInfo() :
            FPlayFabBaseModel(),
            Gamemode(),
            MaxPlayerCount(0),
            MinPlayerCount(0),
            StartOpen()
            {}

        FGameModeInfo(const FGameModeInfo& src) :
            FPlayFabBaseModel(),
            Gamemode(src.Gamemode),
            MaxPlayerCount(src.MaxPlayerCount),
            MinPlayerCount(src.MinPlayerCount),
            StartOpen(src.StartOpen)
            {}

        FGameModeInfo(const TSharedPtr<FJsonObject>& obj) : FGameModeInfo()
        {
            readFromValue(obj);
        }

        ~FGameModeInfo();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetActionsOnPlayersInSegmentTaskInstanceResult : public FPlayFabBaseModel
    {
        // [optional] Parameter of this task instance
        TSharedPtr<FActionsOnPlayersInSegmentTaskParameter> Parameter;

        // [optional] Status summary of the actions-on-players-in-segment task instance
        TSharedPtr<FActionsOnPlayersInSegmentTaskSummary> Summary;

        FGetActionsOnPlayersInSegmentTaskInstanceResult() :
            FPlayFabBaseModel(),
            Parameter(nullptr),
            Summary(nullptr)
            {}

        FGetActionsOnPlayersInSegmentTaskInstanceResult(const FGetActionsOnPlayersInSegmentTaskInstanceResult& src) :
            FPlayFabBaseModel(),
            Parameter(src.Parameter.IsValid() ? MakeShareable(new FActionsOnPlayersInSegmentTaskParameter(*src.Parameter)) : nullptr),
            Summary(src.Summary.IsValid() ? MakeShareable(new FActionsOnPlayersInSegmentTaskSummary(*src.Summary)) : nullptr)
            {}

        FGetActionsOnPlayersInSegmentTaskInstanceResult(const TSharedPtr<FJsonObject>& obj) : FGetActionsOnPlayersInSegmentTaskInstanceResult()
        {
            readFromValue(obj);
        }

        ~FGetActionsOnPlayersInSegmentTaskInstanceResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetAllSegmentsRequest : public FPlayFabBaseModel
    {
        FGetAllSegmentsRequest() :
            FPlayFabBaseModel()
            {}

        FGetAllSegmentsRequest(const FGetAllSegmentsRequest& src) :
            FPlayFabBaseModel()
            {}

        FGetAllSegmentsRequest(const TSharedPtr<FJsonObject>& obj) : FGetAllSegmentsRequest()
        {
            readFromValue(obj);
        }

        ~FGetAllSegmentsRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetSegmentResult : public FPlayFabBaseModel
    {
        // [optional] Identifier of the segments AB Test, if it is attached to one.
        FString ABTestParent;

        // Unique identifier for this segment.
        FString Id;

        // [optional] Segment name.
        FString Name;

        FGetSegmentResult() :
            FPlayFabBaseModel(),
            ABTestParent(),
            Id(),
            Name()
            {}

        FGetSegmentResult(const FGetSegmentResult& src) :
            FPlayFabBaseModel(),
            ABTestParent(src.ABTestParent),
            Id(src.Id),
            Name(src.Name)
            {}

        FGetSegmentResult(const TSharedPtr<FJsonObject>& obj) : FGetSegmentResult()
        {
            readFromValue(obj);
        }

        ~FGetSegmentResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetAllSegmentsResult : public FPlayFabBaseModel
    {
        // [optional] Array of segments for this title.
        TArray<FGetSegmentResult> Segments;
        FGetAllSegmentsResult() :
            FPlayFabBaseModel(),
            Segments()
            {}

        FGetAllSegmentsResult(const FGetAllSegmentsResult& src) :
            FPlayFabBaseModel(),
            Segments(src.Segments)
            {}

        FGetAllSegmentsResult(const TSharedPtr<FJsonObject>& obj) : FGetAllSegmentsResult()
        {
            readFromValue(obj);
        }

        ~FGetAllSegmentsResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetCatalogItemsRequest : public FPlayFabBaseModel
    {
        // [optional] Which catalog is being requested. If null, uses the default catalog.
        FString CatalogVersion;

        FGetCatalogItemsRequest() :
            FPlayFabBaseModel(),
            CatalogVersion()
            {}

        FGetCatalogItemsRequest(const FGetCatalogItemsRequest& src) :
            FPlayFabBaseModel(),
            CatalogVersion(src.CatalogVersion)
            {}

        FGetCatalogItemsRequest(const TSharedPtr<FJsonObject>& obj) : FGetCatalogItemsRequest()
        {
            readFromValue(obj);
        }

        ~FGetCatalogItemsRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetCatalogItemsResult : public FPlayFabBaseModel
    {
        // [optional] Array of items which can be purchased.
        TArray<FCatalogItem> Catalog;
        FGetCatalogItemsResult() :
            FPlayFabBaseModel(),
            Catalog()
            {}

        FGetCatalogItemsResult(const FGetCatalogItemsResult& src) :
            FPlayFabBaseModel(),
            Catalog(src.Catalog)
            {}

        FGetCatalogItemsResult(const TSharedPtr<FJsonObject>& obj) : FGetCatalogItemsResult()
        {
            readFromValue(obj);
        }

        ~FGetCatalogItemsResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetCloudScriptRevisionRequest : public FPlayFabBaseModel
    {
        // [optional] Revision number. If left null, defaults to the latest revision
        Boxed<int32> Revision;

        // [optional] Version number. If left null, defaults to the latest version
        Boxed<int32> Version;

        FGetCloudScriptRevisionRequest() :
            FPlayFabBaseModel(),
            Revision(),
            Version()
            {}

        FGetCloudScriptRevisionRequest(const FGetCloudScriptRevisionRequest& src) :
            FPlayFabBaseModel(),
            Revision(src.Revision),
            Version(src.Version)
            {}

        FGetCloudScriptRevisionRequest(const TSharedPtr<FJsonObject>& obj) : FGetCloudScriptRevisionRequest()
        {
            readFromValue(obj);
        }

        ~FGetCloudScriptRevisionRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetCloudScriptRevisionResult : public FPlayFabBaseModel
    {
        // Time this revision was created
        FDateTime CreatedAt;

        // [optional] List of Cloud Script files in this revision.
        TArray<FCloudScriptFile> Files;
        // True if this is the currently published revision
        bool IsPublished;

        // Revision number.
        int32 Revision;

        // Version number.
        int32 Version;

        FGetCloudScriptRevisionResult() :
            FPlayFabBaseModel(),
            CreatedAt(0),
            Files(),
            IsPublished(false),
            Revision(0),
            Version(0)
            {}

        FGetCloudScriptRevisionResult(const FGetCloudScriptRevisionResult& src) :
            FPlayFabBaseModel(),
            CreatedAt(src.CreatedAt),
            Files(src.Files),
            IsPublished(src.IsPublished),
            Revision(src.Revision),
            Version(src.Version)
            {}

        FGetCloudScriptRevisionResult(const TSharedPtr<FJsonObject>& obj) : FGetCloudScriptRevisionResult()
        {
            readFromValue(obj);
        }

        ~FGetCloudScriptRevisionResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetCloudScriptTaskInstanceResult : public FPlayFabBaseModel
    {
        // [optional] Parameter of this task instance
        TSharedPtr<FCloudScriptTaskParameter> Parameter;

        // [optional] Status summary of the CloudScript task instance
        TSharedPtr<FCloudScriptTaskSummary> Summary;

        FGetCloudScriptTaskInstanceResult() :
            FPlayFabBaseModel(),
            Parameter(nullptr),
            Summary(nullptr)
            {}

        FGetCloudScriptTaskInstanceResult(const FGetCloudScriptTaskInstanceResult& src) :
            FPlayFabBaseModel(),
            Parameter(src.Parameter.IsValid() ? MakeShareable(new FCloudScriptTaskParameter(*src.Parameter)) : nullptr),
            Summary(src.Summary.IsValid() ? MakeShareable(new FCloudScriptTaskSummary(*src.Summary)) : nullptr)
            {}

        FGetCloudScriptTaskInstanceResult(const TSharedPtr<FJsonObject>& obj) : FGetCloudScriptTaskInstanceResult()
        {
            readFromValue(obj);
        }

        ~FGetCloudScriptTaskInstanceResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetCloudScriptVersionsRequest : public FPlayFabBaseModel
    {
        FGetCloudScriptVersionsRequest() :
            FPlayFabBaseModel()
            {}

        FGetCloudScriptVersionsRequest(const FGetCloudScriptVersionsRequest& src) :
            FPlayFabBaseModel()
            {}

        FGetCloudScriptVersionsRequest(const TSharedPtr<FJsonObject>& obj) : FGetCloudScriptVersionsRequest()
        {
            readFromValue(obj);
        }

        ~FGetCloudScriptVersionsRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetCloudScriptVersionsResult : public FPlayFabBaseModel
    {
        // [optional] List of versions
        TArray<FCloudScriptVersionStatus> Versions;
        FGetCloudScriptVersionsResult() :
            FPlayFabBaseModel(),
            Versions()
            {}

        FGetCloudScriptVersionsResult(const FGetCloudScriptVersionsResult& src) :
            FPlayFabBaseModel(),
            Versions(src.Versions)
            {}

        FGetCloudScriptVersionsResult(const TSharedPtr<FJsonObject>& obj) : FGetCloudScriptVersionsResult()
        {
            readFromValue(obj);
        }

        ~FGetCloudScriptVersionsResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetContentListRequest : public FPlayFabBaseModel
    {
        /**
         * [optional] Limits the response to keys that begin with the specified prefix. You can use prefixes to list contents under a folder,
         * or for a specified version, etc.
         */
        FString Prefix;

        FGetContentListRequest() :
            FPlayFabBaseModel(),
            Prefix()
            {}

        FGetContentListRequest(const FGetContentListRequest& src) :
            FPlayFabBaseModel(),
            Prefix(src.Prefix)
            {}

        FGetContentListRequest(const TSharedPtr<FJsonObject>& obj) : FGetContentListRequest()
        {
            readFromValue(obj);
        }

        ~FGetContentListRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetContentListResult : public FPlayFabBaseModel
    {
        // [optional] List of content items.
        TArray<FContentInfo> Contents;
        // Number of content items returned. We currently have a maximum of 1000 items limit.
        int32 ItemCount;

        // The total size of listed contents in bytes.
        uint32 TotalSize;

        FGetContentListResult() :
            FPlayFabBaseModel(),
            Contents(),
            ItemCount(0),
            TotalSize(0)
            {}

        FGetContentListResult(const FGetContentListResult& src) :
            FPlayFabBaseModel(),
            Contents(src.Contents),
            ItemCount(src.ItemCount),
            TotalSize(src.TotalSize)
            {}

        FGetContentListResult(const TSharedPtr<FJsonObject>& obj) : FGetContentListResult()
        {
            readFromValue(obj);
        }

        ~FGetContentListResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetContentUploadUrlRequest : public FPlayFabBaseModel
    {
        /**
         * [optional] A standard MIME type describing the format of the contents. The same MIME type has to be set in the header when
         * uploading the content. If not specified, the MIME type is 'binary/octet-stream' by default.
         */
        FString ContentType;

        // Key of the content item to upload, usually formatted as a path, e.g. images/a.png
        FString Key;

        FGetContentUploadUrlRequest() :
            FPlayFabBaseModel(),
            ContentType(),
            Key()
            {}

        FGetContentUploadUrlRequest(const FGetContentUploadUrlRequest& src) :
            FPlayFabBaseModel(),
            ContentType(src.ContentType),
            Key(src.Key)
            {}

        FGetContentUploadUrlRequest(const TSharedPtr<FJsonObject>& obj) : FGetContentUploadUrlRequest()
        {
            readFromValue(obj);
        }

        ~FGetContentUploadUrlRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetContentUploadUrlResult : public FPlayFabBaseModel
    {
        // [optional] URL for uploading content via HTTP PUT method. The URL will expire in approximately one hour.
        FString URL;

        FGetContentUploadUrlResult() :
            FPlayFabBaseModel(),
            URL()
            {}

        FGetContentUploadUrlResult(const FGetContentUploadUrlResult& src) :
            FPlayFabBaseModel(),
            URL(src.URL)
            {}

        FGetContentUploadUrlResult(const TSharedPtr<FJsonObject>& obj) : FGetContentUploadUrlResult()
        {
            readFromValue(obj);
        }

        ~FGetContentUploadUrlResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetDataReportRequest : public FPlayFabBaseModel
    {
        // Reporting year (UTC)
        int32 Day;

        // Reporting month (UTC)
        int32 Month;

        // Report name
        FString ReportName;

        // Reporting year (UTC)
        int32 Year;

        FGetDataReportRequest() :
            FPlayFabBaseModel(),
            Day(0),
            Month(0),
            ReportName(),
            Year(0)
            {}

        FGetDataReportRequest(const FGetDataReportRequest& src) :
            FPlayFabBaseModel(),
            Day(src.Day),
            Month(src.Month),
            ReportName(src.ReportName),
            Year(src.Year)
            {}

        FGetDataReportRequest(const TSharedPtr<FJsonObject>& obj) : FGetDataReportRequest()
        {
            readFromValue(obj);
        }

        ~FGetDataReportRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetDataReportResult : public FPlayFabBaseModel
    {
        // [optional] The URL where the requested report can be downloaded.
        FString DownloadUrl;

        FGetDataReportResult() :
            FPlayFabBaseModel(),
            DownloadUrl()
            {}

        FGetDataReportResult(const FGetDataReportResult& src) :
            FPlayFabBaseModel(),
            DownloadUrl(src.DownloadUrl)
            {}

        FGetDataReportResult(const TSharedPtr<FJsonObject>& obj) : FGetDataReportResult()
        {
            readFromValue(obj);
        }

        ~FGetDataReportResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetMatchmakerGameInfoRequest : public FPlayFabBaseModel
    {
        // unique identifier of the lobby for which info is being requested
        FString LobbyId;

        FGetMatchmakerGameInfoRequest() :
            FPlayFabBaseModel(),
            LobbyId()
            {}

        FGetMatchmakerGameInfoRequest(const FGetMatchmakerGameInfoRequest& src) :
            FPlayFabBaseModel(),
            LobbyId(src.LobbyId)
            {}

        FGetMatchmakerGameInfoRequest(const TSharedPtr<FJsonObject>& obj) : FGetMatchmakerGameInfoRequest()
        {
            readFromValue(obj);
        }

        ~FGetMatchmakerGameInfoRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetMatchmakerGameInfoResult : public FPlayFabBaseModel
    {
        // [optional] version identifier of the game server executable binary being run
        FString BuildVersion;

        // [optional] time when Game Server Instance is currently scheduled to end
        Boxed<FDateTime> EndTime;

        // [optional] unique identifier of the lobby
        FString LobbyId;

        // [optional] game mode for this Game Server Instance
        FString Mode;

        // [optional] array of unique PlayFab identifiers for users currently connected to this Game Server Instance
        TArray<FString> Players;
        // [optional] region in which the Game Server Instance is running
        Boxed<Region> pfRegion;

        // [optional] IP address for this Game Server Instance
        FString ServerAddress;

        // communication port for this Game Server Instance
        uint32 ServerPort;

        // time when the Game Server Instance was created
        FDateTime StartTime;

        // [optional] unique identifier of the Game Server Instance for this lobby
        FString TitleId;

        FGetMatchmakerGameInfoResult() :
            FPlayFabBaseModel(),
            BuildVersion(),
            EndTime(),
            LobbyId(),
            Mode(),
            Players(),
            pfRegion(),
            ServerAddress(),
            ServerPort(0),
            StartTime(0),
            TitleId()
            {}

        FGetMatchmakerGameInfoResult(const FGetMatchmakerGameInfoResult& src) :
            FPlayFabBaseModel(),
            BuildVersion(src.BuildVersion),
            EndTime(src.EndTime),
            LobbyId(src.LobbyId),
            Mode(src.Mode),
            Players(src.Players),
            pfRegion(src.pfRegion),
            ServerAddress(src.ServerAddress),
            ServerPort(src.ServerPort),
            StartTime(src.StartTime),
            TitleId(src.TitleId)
            {}

        FGetMatchmakerGameInfoResult(const TSharedPtr<FJsonObject>& obj) : FGetMatchmakerGameInfoResult()
        {
            readFromValue(obj);
        }

        ~FGetMatchmakerGameInfoResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetMatchmakerGameModesRequest : public FPlayFabBaseModel
    {
        // previously uploaded build version for which game modes are being requested
        FString BuildVersion;

        FGetMatchmakerGameModesRequest() :
            FPlayFabBaseModel(),
            BuildVersion()
            {}

        FGetMatchmakerGameModesRequest(const FGetMatchmakerGameModesRequest& src) :
            FPlayFabBaseModel(),
            BuildVersion(src.BuildVersion)
            {}

        FGetMatchmakerGameModesRequest(const TSharedPtr<FJsonObject>& obj) : FGetMatchmakerGameModesRequest()
        {
            readFromValue(obj);
        }

        ~FGetMatchmakerGameModesRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetMatchmakerGameModesResult : public FPlayFabBaseModel
    {
        // [optional] array of game modes available for the specified build
        TArray<FGameModeInfo> GameModes;
        FGetMatchmakerGameModesResult() :
            FPlayFabBaseModel(),
            GameModes()
            {}

        FGetMatchmakerGameModesResult(const FGetMatchmakerGameModesResult& src) :
            FPlayFabBaseModel(),
            GameModes(src.GameModes)
            {}

        FGetMatchmakerGameModesResult(const TSharedPtr<FJsonObject>& obj) : FGetMatchmakerGameModesResult()
        {
            readFromValue(obj);
        }

        ~FGetMatchmakerGameModesResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetPlayerIdFromAuthTokenRequest : public FPlayFabBaseModel
    {
        // The auth token of the player requesting the password reset.
        FString Token;

        // The type of auth token of the player requesting the password reset.
        AuthTokenType TokenType;

        FGetPlayerIdFromAuthTokenRequest() :
            FPlayFabBaseModel(),
            Token(),
            TokenType()
            {}

        FGetPlayerIdFromAuthTokenRequest(const FGetPlayerIdFromAuthTokenRequest& src) :
            FPlayFabBaseModel(),
            Token(src.Token),
            TokenType(src.TokenType)
            {}

        FGetPlayerIdFromAuthTokenRequest(const TSharedPtr<FJsonObject>& obj) : FGetPlayerIdFromAuthTokenRequest()
        {
            readFromValue(obj);
        }

        ~FGetPlayerIdFromAuthTokenRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetPlayerIdFromAuthTokenResult : public FPlayFabBaseModel
    {
        // [optional] The player ID from the token passed in
        FString PlayFabId;

        FGetPlayerIdFromAuthTokenResult() :
            FPlayFabBaseModel(),
            PlayFabId()
            {}

        FGetPlayerIdFromAuthTokenResult(const FGetPlayerIdFromAuthTokenResult& src) :
            FPlayFabBaseModel(),
            PlayFabId(src.PlayFabId)
            {}

        FGetPlayerIdFromAuthTokenResult(const TSharedPtr<FJsonObject>& obj) : FGetPlayerIdFromAuthTokenResult()
        {
            readFromValue(obj);
        }

        ~FGetPlayerIdFromAuthTokenResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FPlayerProfileViewConstraints : public FPlayFabBaseModel
    {
        // Whether to show player's avatar URL. Defaults to false
        bool ShowAvatarUrl;

        // Whether to show the banned until time. Defaults to false
        bool ShowBannedUntil;

        // Whether to show campaign attributions. Defaults to false
        bool ShowCampaignAttributions;

        // Whether to show contact email addresses. Defaults to false
        bool ShowContactEmailAddresses;

        // Whether to show the created date. Defaults to false
        bool ShowCreated;

        // Whether to show the display name. Defaults to false
        bool ShowDisplayName;

        // Whether to show the last login time. Defaults to false
        bool ShowLastLogin;

        // Whether to show the linked accounts. Defaults to false
        bool ShowLinkedAccounts;

        // Whether to show player's locations. Defaults to false
        bool ShowLocations;

        // Whether to show player's membership information. Defaults to false
        bool ShowMemberships;

        // Whether to show origination. Defaults to false
        bool ShowOrigination;

        // Whether to show push notification registrations. Defaults to false
        bool ShowPushNotificationRegistrations;

        // Reserved for future development
        bool ShowStatistics;

        // Whether to show tags. Defaults to false
        bool ShowTags;

        // Whether to show the total value to date in usd. Defaults to false
        bool ShowTotalValueToDateInUsd;

        // Whether to show the values to date. Defaults to false
        bool ShowValuesToDate;

        FPlayerProfileViewConstraints() :
            FPlayFabBaseModel(),
            ShowAvatarUrl(false),
            ShowBannedUntil(false),
            ShowCampaignAttributions(false),
            ShowContactEmailAddresses(false),
            ShowCreated(false),
            ShowDisplayName(false),
            ShowLastLogin(false),
            ShowLinkedAccounts(false),
            ShowLocations(false),
            ShowMemberships(false),
            ShowOrigination(false),
            ShowPushNotificationRegistrations(false),
            ShowStatistics(false),
            ShowTags(false),
            ShowTotalValueToDateInUsd(false),
            ShowValuesToDate(false)
            {}

        FPlayerProfileViewConstraints(const FPlayerProfileViewConstraints& src) :
            FPlayFabBaseModel(),
            ShowAvatarUrl(src.ShowAvatarUrl),
            ShowBannedUntil(src.ShowBannedUntil),
            ShowCampaignAttributions(src.ShowCampaignAttributions),
            ShowContactEmailAddresses(src.ShowContactEmailAddresses),
            ShowCreated(src.ShowCreated),
            ShowDisplayName(src.ShowDisplayName),
            ShowLastLogin(src.ShowLastLogin),
            ShowLinkedAccounts(src.ShowLinkedAccounts),
            ShowLocations(src.ShowLocations),
            ShowMemberships(src.ShowMemberships),
            ShowOrigination(src.ShowOrigination),
            ShowPushNotificationRegistrations(src.ShowPushNotificationRegistrations),
            ShowStatistics(src.ShowStatistics),
            ShowTags(src.ShowTags),
            ShowTotalValueToDateInUsd(src.ShowTotalValueToDateInUsd),
            ShowValuesToDate(src.ShowValuesToDate)
            {}

        FPlayerProfileViewConstraints(const TSharedPtr<FJsonObject>& obj) : FPlayerProfileViewConstraints()
        {
            readFromValue(obj);
        }

        ~FPlayerProfileViewConstraints();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetPlayerProfileRequest : public FPlayFabBaseModel
    {
        // Unique PlayFab assigned ID of the user on whom the operation will be performed.
        FString PlayFabId;

        /**
         * [optional] If non-null, this determines which properties of the resulting player profiles to return. For API calls from the client,
         * only the allowed client profile properties for the title may be requested. These allowed properties are configured in
         * the Game Manager "Client Profile Options" tab in the "Settings" section.
         */
        TSharedPtr<FPlayerProfileViewConstraints> ProfileConstraints;

        FGetPlayerProfileRequest() :
            FPlayFabBaseModel(),
            PlayFabId(),
            ProfileConstraints(nullptr)
            {}

        FGetPlayerProfileRequest(const FGetPlayerProfileRequest& src) :
            FPlayFabBaseModel(),
            PlayFabId(src.PlayFabId),
            ProfileConstraints(src.ProfileConstraints.IsValid() ? MakeShareable(new FPlayerProfileViewConstraints(*src.ProfileConstraints)) : nullptr)
            {}

        FGetPlayerProfileRequest(const TSharedPtr<FJsonObject>& obj) : FGetPlayerProfileRequest()
        {
            readFromValue(obj);
        }

        ~FGetPlayerProfileRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    enum LoginIdentityProvider
    {
        LoginIdentityProviderUnknown,
        LoginIdentityProviderPlayFab,
        LoginIdentityProviderCustom,
        LoginIdentityProviderGameCenter,
        LoginIdentityProviderGooglePlay,
        LoginIdentityProviderSteam,
        LoginIdentityProviderXBoxLive,
        LoginIdentityProviderPSN,
        LoginIdentityProviderKongregate,
        LoginIdentityProviderFacebook,
        LoginIdentityProviderIOSDevice,
        LoginIdentityProviderAndroidDevice,
        LoginIdentityProviderTwitch,
        LoginIdentityProviderWindowsHello
    };

    PLAYFAB_API void writeLoginIdentityProviderEnumJSON(LoginIdentityProvider enumVal, JsonWriter& writer);
    PLAYFAB_API LoginIdentityProvider readLoginIdentityProviderFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFAB_API LoginIdentityProvider readLoginIdentityProviderFromValue(const FString& value);

    struct PLAYFAB_API FLinkedPlatformAccountModel : public FPlayFabBaseModel
    {
        // [optional] Linked account email of the user on the platform, if available
        FString Email;

        // [optional] Authentication platform
        Boxed<LoginIdentityProvider> Platform;

        // [optional] Unique account identifier of the user on the platform
        FString PlatformUserId;

        // [optional] Linked account username of the user on the platform, if available
        FString Username;

        FLinkedPlatformAccountModel() :
            FPlayFabBaseModel(),
            Email(),
            Platform(),
            PlatformUserId(),
            Username()
            {}

        FLinkedPlatformAccountModel(const FLinkedPlatformAccountModel& src) :
            FPlayFabBaseModel(),
            Email(src.Email),
            Platform(src.Platform),
            PlatformUserId(src.PlatformUserId),
            Username(src.Username)
            {}

        FLinkedPlatformAccountModel(const TSharedPtr<FJsonObject>& obj) : FLinkedPlatformAccountModel()
        {
            readFromValue(obj);
        }

        ~FLinkedPlatformAccountModel();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FLocationModel : public FPlayFabBaseModel
    {
        // [optional] City name.
        FString City;

        // [optional] The two-character continent code for this location
        Boxed<ContinentCode> pfContinentCode;

        // [optional] The two-character ISO 3166-1 country code for the country associated with the location
        Boxed<CountryCode> pfCountryCode;

        // [optional] Latitude coordinate of the geographic location.
        Boxed<double> Latitude;

        // [optional] Longitude coordinate of the geographic location.
        Boxed<double> Longitude;

        FLocationModel() :
            FPlayFabBaseModel(),
            City(),
            pfContinentCode(),
            pfCountryCode(),
            Latitude(),
            Longitude()
            {}

        FLocationModel(const FLocationModel& src) :
            FPlayFabBaseModel(),
            City(src.City),
            pfContinentCode(src.pfContinentCode),
            pfCountryCode(src.pfCountryCode),
            Latitude(src.Latitude),
            Longitude(src.Longitude)
            {}

        FLocationModel(const TSharedPtr<FJsonObject>& obj) : FLocationModel()
        {
            readFromValue(obj);
        }

        ~FLocationModel();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    enum SubscriptionProviderStatus
    {
        SubscriptionProviderStatusNoError,
        SubscriptionProviderStatusCancelled,
        SubscriptionProviderStatusUnknownError,
        SubscriptionProviderStatusBillingError,
        SubscriptionProviderStatusProductUnavailable,
        SubscriptionProviderStatusCustomerDidNotAcceptPriceChange,
        SubscriptionProviderStatusFreeTrial,
        SubscriptionProviderStatusPaymentPending
    };

    PLAYFAB_API void writeSubscriptionProviderStatusEnumJSON(SubscriptionProviderStatus enumVal, JsonWriter& writer);
    PLAYFAB_API SubscriptionProviderStatus readSubscriptionProviderStatusFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFAB_API SubscriptionProviderStatus readSubscriptionProviderStatusFromValue(const FString& value);

    struct PLAYFAB_API FSubscriptionModel : public FPlayFabBaseModel
    {
        // When this subscription expires.
        FDateTime Expiration;

        // The time the subscription was orignially purchased
        FDateTime InitialSubscriptionTime;

        // Whether this subscription is currently active. That is, if Expiration > now.
        bool IsActive;

        // [optional] The status of this subscription, according to the subscription provider.
        Boxed<SubscriptionProviderStatus> Status;

        // [optional] The id for this subscription
        FString SubscriptionId;

        // [optional] The item id for this subscription from the primary catalog
        FString SubscriptionItemId;

        // [optional] The provider for this subscription. Apple or Google Play are supported today.
        FString SubscriptionProvider;

        FSubscriptionModel() :
            FPlayFabBaseModel(),
            Expiration(0),
            InitialSubscriptionTime(0),
            IsActive(false),
            Status(),
            SubscriptionId(),
            SubscriptionItemId(),
            SubscriptionProvider()
            {}

        FSubscriptionModel(const FSubscriptionModel& src) :
            FPlayFabBaseModel(),
            Expiration(src.Expiration),
            InitialSubscriptionTime(src.InitialSubscriptionTime),
            IsActive(src.IsActive),
            Status(src.Status),
            SubscriptionId(src.SubscriptionId),
            SubscriptionItemId(src.SubscriptionItemId),
            SubscriptionProvider(src.SubscriptionProvider)
            {}

        FSubscriptionModel(const TSharedPtr<FJsonObject>& obj) : FSubscriptionModel()
        {
            readFromValue(obj);
        }

        ~FSubscriptionModel();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FMembershipModel : public FPlayFabBaseModel
    {
        // Whether this membership is active. That is, whether the MembershipExpiration time has been reached.
        bool IsActive;

        // The time this membership expires
        FDateTime MembershipExpiration;

        // [optional] The id of the membership
        FString MembershipId;

        /**
         * [optional] Membership expirations can be explicitly overridden (via game manager or the admin api). If this membership has been
         * overridden, this will be the new expiration time.
         */
        Boxed<FDateTime> OverrideExpiration;

        // [optional] Whether the override expiration is set.
        Boxed<bool> OverrideIsSet;

        // [optional] The list of subscriptions that this player has for this membership
        TArray<FSubscriptionModel> Subscriptions;
        FMembershipModel() :
            FPlayFabBaseModel(),
            IsActive(false),
            MembershipExpiration(0),
            MembershipId(),
            OverrideExpiration(),
            OverrideIsSet(),
            Subscriptions()
            {}

        FMembershipModel(const FMembershipModel& src) :
            FPlayFabBaseModel(),
            IsActive(src.IsActive),
            MembershipExpiration(src.MembershipExpiration),
            MembershipId(src.MembershipId),
            OverrideExpiration(src.OverrideExpiration),
            OverrideIsSet(src.OverrideIsSet),
            Subscriptions(src.Subscriptions)
            {}

        FMembershipModel(const TSharedPtr<FJsonObject>& obj) : FMembershipModel()
        {
            readFromValue(obj);
        }

        ~FMembershipModel();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    enum PushNotificationPlatform
    {
        PushNotificationPlatformApplePushNotificationService,
        PushNotificationPlatformGoogleCloudMessaging
    };

    PLAYFAB_API void writePushNotificationPlatformEnumJSON(PushNotificationPlatform enumVal, JsonWriter& writer);
    PLAYFAB_API PushNotificationPlatform readPushNotificationPlatformFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFAB_API PushNotificationPlatform readPushNotificationPlatformFromValue(const FString& value);

    struct PLAYFAB_API FPushNotificationRegistrationModel : public FPlayFabBaseModel
    {
        // [optional] Notification configured endpoint
        FString NotificationEndpointARN;

        // [optional] Push notification platform
        Boxed<PushNotificationPlatform> Platform;

        FPushNotificationRegistrationModel() :
            FPlayFabBaseModel(),
            NotificationEndpointARN(),
            Platform()
            {}

        FPushNotificationRegistrationModel(const FPushNotificationRegistrationModel& src) :
            FPlayFabBaseModel(),
            NotificationEndpointARN(src.NotificationEndpointARN),
            Platform(src.Platform)
            {}

        FPushNotificationRegistrationModel(const TSharedPtr<FJsonObject>& obj) : FPushNotificationRegistrationModel()
        {
            readFromValue(obj);
        }

        ~FPushNotificationRegistrationModel();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FStatisticModel : public FPlayFabBaseModel
    {
        // [optional] Statistic name
        FString Name;

        // Statistic value
        int32 Value;

        // Statistic version (0 if not a versioned statistic)
        int32 Version;

        FStatisticModel() :
            FPlayFabBaseModel(),
            Name(),
            Value(0),
            Version(0)
            {}

        FStatisticModel(const FStatisticModel& src) :
            FPlayFabBaseModel(),
            Name(src.Name),
            Value(src.Value),
            Version(src.Version)
            {}

        FStatisticModel(const TSharedPtr<FJsonObject>& obj) : FStatisticModel()
        {
            readFromValue(obj);
        }

        ~FStatisticModel();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FTagModel : public FPlayFabBaseModel
    {
        // [optional] Full value of the tag, including namespace
        FString TagValue;

        FTagModel() :
            FPlayFabBaseModel(),
            TagValue()
            {}

        FTagModel(const FTagModel& src) :
            FPlayFabBaseModel(),
            TagValue(src.TagValue)
            {}

        FTagModel(const TSharedPtr<FJsonObject>& obj) : FTagModel()
        {
            readFromValue(obj);
        }

        ~FTagModel();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FValueToDateModel : public FPlayFabBaseModel
    {
        // [optional] ISO 4217 code of the currency used in the purchases
        FString Currency;

        /**
         * Total value of the purchases in a whole number of 1/100 monetary units. For example, 999 indicates nine dollars and
         * ninety-nine cents when Currency is 'USD')
         */
        uint32 TotalValue;

        /**
         * [optional] Total value of the purchases in a string representation of decimal monetary units. For example, '9.99' indicates nine
         * dollars and ninety-nine cents when Currency is 'USD'.
         */
        FString TotalValueAsDecimal;

        FValueToDateModel() :
            FPlayFabBaseModel(),
            Currency(),
            TotalValue(0),
            TotalValueAsDecimal()
            {}

        FValueToDateModel(const FValueToDateModel& src) :
            FPlayFabBaseModel(),
            Currency(src.Currency),
            TotalValue(src.TotalValue),
            TotalValueAsDecimal(src.TotalValueAsDecimal)
            {}

        FValueToDateModel(const TSharedPtr<FJsonObject>& obj) : FValueToDateModel()
        {
            readFromValue(obj);
        }

        ~FValueToDateModel();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FPlayerProfileModel : public FPlayFabBaseModel
    {
        // [optional] List of advertising campaigns the player has been attributed to
        TArray<FAdCampaignAttributionModel> AdCampaignAttributions;
        // [optional] URL of the player's avatar image
        FString AvatarUrl;

        // [optional] If the player is currently banned, the UTC Date when the ban expires
        Boxed<FDateTime> BannedUntil;

        // [optional] List of all contact email info associated with the player account
        TArray<FContactEmailInfoModel> ContactEmailAddresses;
        // [optional] Player record created
        Boxed<FDateTime> Created;

        // [optional] Player display name
        FString DisplayName;

        // [optional] UTC time when the player most recently logged in to the title
        Boxed<FDateTime> LastLogin;

        // [optional] List of all authentication systems linked to this player account
        TArray<FLinkedPlatformAccountModel> LinkedAccounts;
        // [optional] List of geographic locations from which the player has logged in to the title
        TArray<FLocationModel> Locations;
        // [optional] List of memberships for the player, along with whether are expired.
        TArray<FMembershipModel> Memberships;
        // [optional] Player account origination
        Boxed<LoginIdentityProvider> Origination;

        // [optional] PlayFab player account unique identifier
        FString PlayerId;

        // [optional] Publisher this player belongs to
        FString PublisherId;

        // [optional] List of configured end points registered for sending the player push notifications
        TArray<FPushNotificationRegistrationModel> PushNotificationRegistrations;
        // [optional] List of leaderboard statistic values for the player
        TArray<FStatisticModel> Statistics;
        // [optional] List of player's tags for segmentation
        TArray<FTagModel> Tags;
        // [optional] Title ID this player profile applies to
        FString TitleId;

        /**
         * [optional] Sum of the player's purchases made with real-money currencies, converted to US dollars equivalent and represented as a
         * whole number of cents (1/100 USD).       For example, 999 indicates nine dollars and ninety-nine cents.
         */
        Boxed<uint32> TotalValueToDateInUSD;

        // [optional] List of the player's lifetime purchase totals, summed by real-money currency
        TArray<FValueToDateModel> ValuesToDate;
        FPlayerProfileModel() :
            FPlayFabBaseModel(),
            AdCampaignAttributions(),
            AvatarUrl(),
            BannedUntil(),
            ContactEmailAddresses(),
            Created(),
            DisplayName(),
            LastLogin(),
            LinkedAccounts(),
            Locations(),
            Memberships(),
            Origination(),
            PlayerId(),
            PublisherId(),
            PushNotificationRegistrations(),
            Statistics(),
            Tags(),
            TitleId(),
            TotalValueToDateInUSD(),
            ValuesToDate()
            {}

        FPlayerProfileModel(const FPlayerProfileModel& src) :
            FPlayFabBaseModel(),
            AdCampaignAttributions(src.AdCampaignAttributions),
            AvatarUrl(src.AvatarUrl),
            BannedUntil(src.BannedUntil),
            ContactEmailAddresses(src.ContactEmailAddresses),
            Created(src.Created),
            DisplayName(src.DisplayName),
            LastLogin(src.LastLogin),
            LinkedAccounts(src.LinkedAccounts),
            Locations(src.Locations),
            Memberships(src.Memberships),
            Origination(src.Origination),
            PlayerId(src.PlayerId),
            PublisherId(src.PublisherId),
            PushNotificationRegistrations(src.PushNotificationRegistrations),
            Statistics(src.Statistics),
            Tags(src.Tags),
            TitleId(src.TitleId),
            TotalValueToDateInUSD(src.TotalValueToDateInUSD),
            ValuesToDate(src.ValuesToDate)
            {}

        FPlayerProfileModel(const TSharedPtr<FJsonObject>& obj) : FPlayerProfileModel()
        {
            readFromValue(obj);
        }

        ~FPlayerProfileModel();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetPlayerProfileResult : public FPlayFabBaseModel
    {
        /**
         * [optional] The profile of the player. This profile is not guaranteed to be up-to-date. For a new player, this profile will not
         * exist.
         */
        TSharedPtr<FPlayerProfileModel> PlayerProfile;

        FGetPlayerProfileResult() :
            FPlayFabBaseModel(),
            PlayerProfile(nullptr)
            {}

        FGetPlayerProfileResult(const FGetPlayerProfileResult& src) :
            FPlayFabBaseModel(),
            PlayerProfile(src.PlayerProfile.IsValid() ? MakeShareable(new FPlayerProfileModel(*src.PlayerProfile)) : nullptr)
            {}

        FGetPlayerProfileResult(const TSharedPtr<FJsonObject>& obj) : FGetPlayerProfileResult()
        {
            readFromValue(obj);
        }

        ~FGetPlayerProfileResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetPlayerSegmentsResult : public FPlayFabBaseModel
    {
        // [optional] Array of segments the requested player currently belongs to.
        TArray<FGetSegmentResult> Segments;
        FGetPlayerSegmentsResult() :
            FPlayFabBaseModel(),
            Segments()
            {}

        FGetPlayerSegmentsResult(const FGetPlayerSegmentsResult& src) :
            FPlayFabBaseModel(),
            Segments(src.Segments)
            {}

        FGetPlayerSegmentsResult(const TSharedPtr<FJsonObject>& obj) : FGetPlayerSegmentsResult()
        {
            readFromValue(obj);
        }

        ~FGetPlayerSegmentsResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetPlayerSharedSecretsRequest : public FPlayFabBaseModel
    {
        FGetPlayerSharedSecretsRequest() :
            FPlayFabBaseModel()
            {}

        FGetPlayerSharedSecretsRequest(const FGetPlayerSharedSecretsRequest& src) :
            FPlayFabBaseModel()
            {}

        FGetPlayerSharedSecretsRequest(const TSharedPtr<FJsonObject>& obj) : FGetPlayerSharedSecretsRequest()
        {
            readFromValue(obj);
        }

        ~FGetPlayerSharedSecretsRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FSharedSecret : public FPlayFabBaseModel
    {
        // Flag to indicate if this key is disabled
        bool Disabled;

        // [optional] Friendly name for this key
        FString FriendlyName;

        // [optional] The player shared secret to use when calling Client/GetTitlePublicKey
        FString SecretKey;

        FSharedSecret() :
            FPlayFabBaseModel(),
            Disabled(false),
            FriendlyName(),
            SecretKey()
            {}

        FSharedSecret(const FSharedSecret& src) :
            FPlayFabBaseModel(),
            Disabled(src.Disabled),
            FriendlyName(src.FriendlyName),
            SecretKey(src.SecretKey)
            {}

        FSharedSecret(const TSharedPtr<FJsonObject>& obj) : FSharedSecret()
        {
            readFromValue(obj);
        }

        ~FSharedSecret();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetPlayerSharedSecretsResult : public FPlayFabBaseModel
    {
        // [optional] The player shared secret to use when calling Client/GetTitlePublicKey
        TArray<FSharedSecret> SharedSecrets;
        FGetPlayerSharedSecretsResult() :
            FPlayFabBaseModel(),
            SharedSecrets()
            {}

        FGetPlayerSharedSecretsResult(const FGetPlayerSharedSecretsResult& src) :
            FPlayFabBaseModel(),
            SharedSecrets(src.SharedSecrets)
            {}

        FGetPlayerSharedSecretsResult(const TSharedPtr<FJsonObject>& obj) : FGetPlayerSharedSecretsResult()
        {
            readFromValue(obj);
        }

        ~FGetPlayerSharedSecretsResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetPlayersInSegmentRequest : public FPlayFabBaseModel
    {
        // [optional] Continuation token if retrieving subsequent pages of results.
        FString ContinuationToken;

        // [optional] Maximum number of profiles to load. Default is 1,000. Maximum is 10,000.
        Boxed<uint32> MaxBatchSize;

        /**
         * [optional] Number of seconds to keep the continuation token active. After token expiration it is not possible to continue paging
         * results. Default is 300 (5 minutes). Maximum is 1,800 (30 minutes).
         */
        Boxed<uint32> SecondsToLive;

        // Unique identifier for this segment.
        FString SegmentId;

        FGetPlayersInSegmentRequest() :
            FPlayFabBaseModel(),
            ContinuationToken(),
            MaxBatchSize(),
            SecondsToLive(),
            SegmentId()
            {}

        FGetPlayersInSegmentRequest(const FGetPlayersInSegmentRequest& src) :
            FPlayFabBaseModel(),
            ContinuationToken(src.ContinuationToken),
            MaxBatchSize(src.MaxBatchSize),
            SecondsToLive(src.SecondsToLive),
            SegmentId(src.SegmentId)
            {}

        FGetPlayersInSegmentRequest(const TSharedPtr<FJsonObject>& obj) : FGetPlayersInSegmentRequest()
        {
            readFromValue(obj);
        }

        ~FGetPlayersInSegmentRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FPlayerLinkedAccount : public FPlayFabBaseModel
    {
        // [optional] Linked account's email
        FString Email;

        // [optional] Authentication platform
        Boxed<LoginIdentityProvider> Platform;

        // [optional] Platform user identifier
        FString PlatformUserId;

        // [optional] Linked account's username
        FString Username;

        FPlayerLinkedAccount() :
            FPlayFabBaseModel(),
            Email(),
            Platform(),
            PlatformUserId(),
            Username()
            {}

        FPlayerLinkedAccount(const FPlayerLinkedAccount& src) :
            FPlayFabBaseModel(),
            Email(src.Email),
            Platform(src.Platform),
            PlatformUserId(src.PlatformUserId),
            Username(src.Username)
            {}

        FPlayerLinkedAccount(const TSharedPtr<FJsonObject>& obj) : FPlayerLinkedAccount()
        {
            readFromValue(obj);
        }

        ~FPlayerLinkedAccount();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FPlayerLocation : public FPlayFabBaseModel
    {
        // [optional] City of the player's geographic location.
        FString City;

        // The two-character continent code for this location
        ContinentCode pfContinentCode;

        // The two-character ISO 3166-1 country code for the country associated with the location
        CountryCode pfCountryCode;

        // [optional] Latitude coordinate of the player's geographic location.
        Boxed<double> Latitude;

        // [optional] Longitude coordinate of the player's geographic location.
        Boxed<double> Longitude;

        FPlayerLocation() :
            FPlayFabBaseModel(),
            City(),
            pfContinentCode(),
            pfCountryCode(),
            Latitude(),
            Longitude()
            {}

        FPlayerLocation(const FPlayerLocation& src) :
            FPlayFabBaseModel(),
            City(src.City),
            pfContinentCode(src.pfContinentCode),
            pfCountryCode(src.pfCountryCode),
            Latitude(src.Latitude),
            Longitude(src.Longitude)
            {}

        FPlayerLocation(const TSharedPtr<FJsonObject>& obj) : FPlayerLocation()
        {
            readFromValue(obj);
        }

        ~FPlayerLocation();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FPlayerStatistic : public FPlayFabBaseModel
    {
        // [optional] Statistic ID
        FString Id;

        // [optional] Statistic name
        FString Name;

        // Current statistic value
        int32 StatisticValue;

        // Statistic version (0 if not a versioned statistic)
        int32 StatisticVersion;

        FPlayerStatistic() :
            FPlayFabBaseModel(),
            Id(),
            Name(),
            StatisticValue(0),
            StatisticVersion(0)
            {}

        FPlayerStatistic(const FPlayerStatistic& src) :
            FPlayFabBaseModel(),
            Id(src.Id),
            Name(src.Name),
            StatisticValue(src.StatisticValue),
            StatisticVersion(src.StatisticVersion)
            {}

        FPlayerStatistic(const TSharedPtr<FJsonObject>& obj) : FPlayerStatistic()
        {
            readFromValue(obj);
        }

        ~FPlayerStatistic();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FPushNotificationRegistration : public FPlayFabBaseModel
    {
        // [optional] Notification configured endpoint
        FString NotificationEndpointARN;

        // [optional] Push notification platform
        Boxed<PushNotificationPlatform> Platform;

        FPushNotificationRegistration() :
            FPlayFabBaseModel(),
            NotificationEndpointARN(),
            Platform()
            {}

        FPushNotificationRegistration(const FPushNotificationRegistration& src) :
            FPlayFabBaseModel(),
            NotificationEndpointARN(src.NotificationEndpointARN),
            Platform(src.Platform)
            {}

        FPushNotificationRegistration(const TSharedPtr<FJsonObject>& obj) : FPushNotificationRegistration()
        {
            readFromValue(obj);
        }

        ~FPushNotificationRegistration();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FPlayerProfile : public FPlayFabBaseModel
    {
        // [optional] Array of ad campaigns player has been attributed to
        TArray<FAdCampaignAttribution> AdCampaignAttributions;
        // [optional] Image URL of the player's avatar.
        FString AvatarUrl;

        // [optional] Banned until UTC Date. If permanent ban this is set for 20 years after the original ban date.
        Boxed<FDateTime> BannedUntil;

        // [optional] Array of contact email addresses associated with the player
        TArray<FContactEmailInfo> ContactEmailAddresses;
        // [optional] Player record created
        Boxed<FDateTime> Created;

        // [optional] Player Display Name
        FString DisplayName;

        // [optional] Last login
        Boxed<FDateTime> LastLogin;

        // [optional] Array of third party accounts linked to this player
        TArray<FPlayerLinkedAccount> LinkedAccounts;
        // [optional] Dictionary of player's locations by type.
        TMap<FString, FPlayerLocation> Locations;
        // [optional] Player account origination
        Boxed<LoginIdentityProvider> Origination;

        // [optional] PlayFab Player ID
        FString PlayerId;

        // [optional] Array of player statistics
        TArray<FPlayerStatistic> PlayerStatistics;
        // [optional] Publisher this player belongs to
        FString PublisherId;

        // [optional] Array of configured push notification end points
        TArray<FPushNotificationRegistration> PushNotificationRegistrations;
        // [optional] Dictionary of player's statistics using only the latest version's value
        TMap<FString, int32> Statistics;
        // [optional] List of player's tags for segmentation.
        TArray<FString> Tags;
        // [optional] Title ID this profile applies to
        FString TitleId;

        // [optional] A sum of player's total purchases in USD across all currencies.
        Boxed<uint32> TotalValueToDateInUSD;

        // [optional] Dictionary of player's total purchases by currency.
        TMap<FString, uint32> ValuesToDate;
        // [optional] Dictionary of player's virtual currency balances
        TMap<FString, int32> VirtualCurrencyBalances;
        FPlayerProfile() :
            FPlayFabBaseModel(),
            AdCampaignAttributions(),
            AvatarUrl(),
            BannedUntil(),
            ContactEmailAddresses(),
            Created(),
            DisplayName(),
            LastLogin(),
            LinkedAccounts(),
            Locations(),
            Origination(),
            PlayerId(),
            PlayerStatistics(),
            PublisherId(),
            PushNotificationRegistrations(),
            Statistics(),
            Tags(),
            TitleId(),
            TotalValueToDateInUSD(),
            ValuesToDate(),
            VirtualCurrencyBalances()
            {}

        FPlayerProfile(const FPlayerProfile& src) :
            FPlayFabBaseModel(),
            AdCampaignAttributions(src.AdCampaignAttributions),
            AvatarUrl(src.AvatarUrl),
            BannedUntil(src.BannedUntil),
            ContactEmailAddresses(src.ContactEmailAddresses),
            Created(src.Created),
            DisplayName(src.DisplayName),
            LastLogin(src.LastLogin),
            LinkedAccounts(src.LinkedAccounts),
            Locations(src.Locations),
            Origination(src.Origination),
            PlayerId(src.PlayerId),
            PlayerStatistics(src.PlayerStatistics),
            PublisherId(src.PublisherId),
            PushNotificationRegistrations(src.PushNotificationRegistrations),
            Statistics(src.Statistics),
            Tags(src.Tags),
            TitleId(src.TitleId),
            TotalValueToDateInUSD(src.TotalValueToDateInUSD),
            ValuesToDate(src.ValuesToDate),
            VirtualCurrencyBalances(src.VirtualCurrencyBalances)
            {}

        FPlayerProfile(const TSharedPtr<FJsonObject>& obj) : FPlayerProfile()
        {
            readFromValue(obj);
        }

        ~FPlayerProfile();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetPlayersInSegmentResult : public FPlayFabBaseModel
    {
        // [optional] Continuation token to use to retrieve subsequent pages of results. If token returns null there are no more results.
        FString ContinuationToken;

        // [optional] Array of player profiles in this segment.
        TArray<FPlayerProfile> PlayerProfiles;
        // Count of profiles matching this segment.
        int32 ProfilesInSegment;

        FGetPlayersInSegmentResult() :
            FPlayFabBaseModel(),
            ContinuationToken(),
            PlayerProfiles(),
            ProfilesInSegment(0)
            {}

        FGetPlayersInSegmentResult(const FGetPlayersInSegmentResult& src) :
            FPlayFabBaseModel(),
            ContinuationToken(src.ContinuationToken),
            PlayerProfiles(src.PlayerProfiles),
            ProfilesInSegment(src.ProfilesInSegment)
            {}

        FGetPlayersInSegmentResult(const TSharedPtr<FJsonObject>& obj) : FGetPlayersInSegmentResult()
        {
            readFromValue(obj);
        }

        ~FGetPlayersInSegmentResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetPlayersSegmentsRequest : public FPlayFabBaseModel
    {
        // Unique PlayFab assigned ID of the user on whom the operation will be performed.
        FString PlayFabId;

        FGetPlayersSegmentsRequest() :
            FPlayFabBaseModel(),
            PlayFabId()
            {}

        FGetPlayersSegmentsRequest(const FGetPlayersSegmentsRequest& src) :
            FPlayFabBaseModel(),
            PlayFabId(src.PlayFabId)
            {}

        FGetPlayersSegmentsRequest(const TSharedPtr<FJsonObject>& obj) : FGetPlayersSegmentsRequest()
        {
            readFromValue(obj);
        }

        ~FGetPlayersSegmentsRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetPlayerStatisticDefinitionsRequest : public FPlayFabBaseModel
    {
        FGetPlayerStatisticDefinitionsRequest() :
            FPlayFabBaseModel()
            {}

        FGetPlayerStatisticDefinitionsRequest(const FGetPlayerStatisticDefinitionsRequest& src) :
            FPlayFabBaseModel()
            {}

        FGetPlayerStatisticDefinitionsRequest(const TSharedPtr<FJsonObject>& obj) : FGetPlayerStatisticDefinitionsRequest()
        {
            readFromValue(obj);
        }

        ~FGetPlayerStatisticDefinitionsRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetPlayerStatisticDefinitionsResult : public FPlayFabBaseModel
    {
        // [optional] the player statistic definitions for the title
        TArray<FPlayerStatisticDefinition> Statistics;
        FGetPlayerStatisticDefinitionsResult() :
            FPlayFabBaseModel(),
            Statistics()
            {}

        FGetPlayerStatisticDefinitionsResult(const FGetPlayerStatisticDefinitionsResult& src) :
            FPlayFabBaseModel(),
            Statistics(src.Statistics)
            {}

        FGetPlayerStatisticDefinitionsResult(const TSharedPtr<FJsonObject>& obj) : FGetPlayerStatisticDefinitionsResult()
        {
            readFromValue(obj);
        }

        ~FGetPlayerStatisticDefinitionsResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetPlayerStatisticVersionsRequest : public FPlayFabBaseModel
    {
        // [optional] unique name of the statistic
        FString StatisticName;

        FGetPlayerStatisticVersionsRequest() :
            FPlayFabBaseModel(),
            StatisticName()
            {}

        FGetPlayerStatisticVersionsRequest(const FGetPlayerStatisticVersionsRequest& src) :
            FPlayFabBaseModel(),
            StatisticName(src.StatisticName)
            {}

        FGetPlayerStatisticVersionsRequest(const TSharedPtr<FJsonObject>& obj) : FGetPlayerStatisticVersionsRequest()
        {
            readFromValue(obj);
        }

        ~FGetPlayerStatisticVersionsRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    enum StatisticVersionStatus
    {
        StatisticVersionStatusActive,
        StatisticVersionStatusSnapshotPending,
        StatisticVersionStatusSnapshot,
        StatisticVersionStatusArchivalPending,
        StatisticVersionStatusArchived
    };

    PLAYFAB_API void writeStatisticVersionStatusEnumJSON(StatisticVersionStatus enumVal, JsonWriter& writer);
    PLAYFAB_API StatisticVersionStatus readStatisticVersionStatusFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFAB_API StatisticVersionStatus readStatisticVersionStatusFromValue(const FString& value);

    struct PLAYFAB_API FPlayerStatisticVersion : public FPlayFabBaseModel
    {
        // time when the statistic version became active
        FDateTime ActivationTime;

        // [optional] URL for the downloadable archive of player statistic values, if available
        FString ArchiveDownloadUrl;

        // [optional] time when the statistic version became inactive due to statistic version incrementing
        Boxed<FDateTime> DeactivationTime;

        // [optional] time at which the statistic version was scheduled to become active, based on the configured ResetInterval
        Boxed<FDateTime> ScheduledActivationTime;

        // [optional] time at which the statistic version was scheduled to become inactive, based on the configured ResetInterval
        Boxed<FDateTime> ScheduledDeactivationTime;

        // [optional] name of the statistic when the version became active
        FString StatisticName;

        // [optional] status of the statistic version
        Boxed<StatisticVersionStatus> Status;

        // version of the statistic
        uint32 Version;

        FPlayerStatisticVersion() :
            FPlayFabBaseModel(),
            ActivationTime(0),
            ArchiveDownloadUrl(),
            DeactivationTime(),
            ScheduledActivationTime(),
            ScheduledDeactivationTime(),
            StatisticName(),
            Status(),
            Version(0)
            {}

        FPlayerStatisticVersion(const FPlayerStatisticVersion& src) :
            FPlayFabBaseModel(),
            ActivationTime(src.ActivationTime),
            ArchiveDownloadUrl(src.ArchiveDownloadUrl),
            DeactivationTime(src.DeactivationTime),
            ScheduledActivationTime(src.ScheduledActivationTime),
            ScheduledDeactivationTime(src.ScheduledDeactivationTime),
            StatisticName(src.StatisticName),
            Status(src.Status),
            Version(src.Version)
            {}

        FPlayerStatisticVersion(const TSharedPtr<FJsonObject>& obj) : FPlayerStatisticVersion()
        {
            readFromValue(obj);
        }

        ~FPlayerStatisticVersion();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetPlayerStatisticVersionsResult : public FPlayFabBaseModel
    {
        // [optional] version change history of the statistic
        TArray<FPlayerStatisticVersion> StatisticVersions;
        FGetPlayerStatisticVersionsResult() :
            FPlayFabBaseModel(),
            StatisticVersions()
            {}

        FGetPlayerStatisticVersionsResult(const FGetPlayerStatisticVersionsResult& src) :
            FPlayFabBaseModel(),
            StatisticVersions(src.StatisticVersions)
            {}

        FGetPlayerStatisticVersionsResult(const TSharedPtr<FJsonObject>& obj) : FGetPlayerStatisticVersionsResult()
        {
            readFromValue(obj);
        }

        ~FGetPlayerStatisticVersionsResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetPlayerTagsRequest : public FPlayFabBaseModel
    {
        // [optional] Optional namespace to filter results by
        FString Namespace;

        // Unique PlayFab assigned ID of the user on whom the operation will be performed.
        FString PlayFabId;

        FGetPlayerTagsRequest() :
            FPlayFabBaseModel(),
            Namespace(),
            PlayFabId()
            {}

        FGetPlayerTagsRequest(const FGetPlayerTagsRequest& src) :
            FPlayFabBaseModel(),
            Namespace(src.Namespace),
            PlayFabId(src.PlayFabId)
            {}

        FGetPlayerTagsRequest(const TSharedPtr<FJsonObject>& obj) : FGetPlayerTagsRequest()
        {
            readFromValue(obj);
        }

        ~FGetPlayerTagsRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetPlayerTagsResult : public FPlayFabBaseModel
    {
        // Unique PlayFab assigned ID of the user on whom the operation will be performed.
        FString PlayFabId;

        // Canonical tags (including namespace and tag's name) for the requested user
        TArray<FString> Tags;
        FGetPlayerTagsResult() :
            FPlayFabBaseModel(),
            PlayFabId(),
            Tags()
            {}

        FGetPlayerTagsResult(const FGetPlayerTagsResult& src) :
            FPlayFabBaseModel(),
            PlayFabId(src.PlayFabId),
            Tags(src.Tags)
            {}

        FGetPlayerTagsResult(const TSharedPtr<FJsonObject>& obj) : FGetPlayerTagsResult()
        {
            readFromValue(obj);
        }

        ~FGetPlayerTagsResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetPolicyRequest : public FPlayFabBaseModel
    {
        // [optional] The name of the policy to read. Only supported name is 'ApiPolicy'.
        FString PolicyName;

        FGetPolicyRequest() :
            FPlayFabBaseModel(),
            PolicyName()
            {}

        FGetPolicyRequest(const FGetPolicyRequest& src) :
            FPlayFabBaseModel(),
            PolicyName(src.PolicyName)
            {}

        FGetPolicyRequest(const TSharedPtr<FJsonObject>& obj) : FGetPolicyRequest()
        {
            readFromValue(obj);
        }

        ~FGetPolicyRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FPermissionStatement : public FPlayFabBaseModel
    {
        // The action this statement effects. The only supported action is 'Execute'.
        FString Action;

        // [optional] Additional conditions to be applied for API Resources.
        TSharedPtr<FApiCondition> ApiConditions;

        // [optional] A comment about the statement. Intended solely for bookkeeping and debugging.
        FString Comment;

        // The effect this statement will have. It could be either Allow or Deny
        EffectType Effect;

        // The principal this statement will effect. The only supported principal is '*'.
        FString Principal;

        /**
         * The resource this statements effects. The only supported resources look like 'pfrn:api--*' for all apis, or
         * 'pfrn:api--/Client/ConfirmPurchase' for specific apis.
         */
        FString Resource;

        FPermissionStatement() :
            FPlayFabBaseModel(),
            Action(),
            ApiConditions(nullptr),
            Comment(),
            Effect(),
            Principal(),
            Resource()
            {}

        FPermissionStatement(const FPermissionStatement& src) :
            FPlayFabBaseModel(),
            Action(src.Action),
            ApiConditions(src.ApiConditions.IsValid() ? MakeShareable(new FApiCondition(*src.ApiConditions)) : nullptr),
            Comment(src.Comment),
            Effect(src.Effect),
            Principal(src.Principal),
            Resource(src.Resource)
            {}

        FPermissionStatement(const TSharedPtr<FJsonObject>& obj) : FPermissionStatement()
        {
            readFromValue(obj);
        }

        ~FPermissionStatement();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetPolicyResponse : public FPlayFabBaseModel
    {
        // [optional] The name of the policy read.
        FString PolicyName;

        // [optional] The statements in the requested policy.
        TArray<FPermissionStatement> Statements;
        FGetPolicyResponse() :
            FPlayFabBaseModel(),
            PolicyName(),
            Statements()
            {}

        FGetPolicyResponse(const FGetPolicyResponse& src) :
            FPlayFabBaseModel(),
            PolicyName(src.PolicyName),
            Statements(src.Statements)
            {}

        FGetPolicyResponse(const TSharedPtr<FJsonObject>& obj) : FGetPolicyResponse()
        {
            readFromValue(obj);
        }

        ~FGetPolicyResponse();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetPublisherDataRequest : public FPlayFabBaseModel
    {
        // array of keys to get back data from the Publisher data blob, set by the admin tools
        TArray<FString> Keys;
        FGetPublisherDataRequest() :
            FPlayFabBaseModel(),
            Keys()
            {}

        FGetPublisherDataRequest(const FGetPublisherDataRequest& src) :
            FPlayFabBaseModel(),
            Keys(src.Keys)
            {}

        FGetPublisherDataRequest(const TSharedPtr<FJsonObject>& obj) : FGetPublisherDataRequest()
        {
            readFromValue(obj);
        }

        ~FGetPublisherDataRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetPublisherDataResult : public FPlayFabBaseModel
    {
        // [optional] a dictionary object of key / value pairs
        TMap<FString, FString> Data;
        FGetPublisherDataResult() :
            FPlayFabBaseModel(),
            Data()
            {}

        FGetPublisherDataResult(const FGetPublisherDataResult& src) :
            FPlayFabBaseModel(),
            Data(src.Data)
            {}

        FGetPublisherDataResult(const TSharedPtr<FJsonObject>& obj) : FGetPublisherDataResult()
        {
            readFromValue(obj);
        }

        ~FGetPublisherDataResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetRandomResultTablesRequest : public FPlayFabBaseModel
    {
        // [optional] catalog version to fetch tables from. Use default catalog version if null
        FString CatalogVersion;

        FGetRandomResultTablesRequest() :
            FPlayFabBaseModel(),
            CatalogVersion()
            {}

        FGetRandomResultTablesRequest(const FGetRandomResultTablesRequest& src) :
            FPlayFabBaseModel(),
            CatalogVersion(src.CatalogVersion)
            {}

        FGetRandomResultTablesRequest(const TSharedPtr<FJsonObject>& obj) : FGetRandomResultTablesRequest()
        {
            readFromValue(obj);
        }

        ~FGetRandomResultTablesRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    enum ResultTableNodeType
    {
        ResultTableNodeTypeItemId,
        ResultTableNodeTypeTableId
    };

    PLAYFAB_API void writeResultTableNodeTypeEnumJSON(ResultTableNodeType enumVal, JsonWriter& writer);
    PLAYFAB_API ResultTableNodeType readResultTableNodeTypeFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFAB_API ResultTableNodeType readResultTableNodeTypeFromValue(const FString& value);

    struct PLAYFAB_API FResultTableNode : public FPlayFabBaseModel
    {
        // Either an ItemId, or the TableId of another random result table
        FString ResultItem;

        // Whether this entry in the table is an item or a link to another table
        ResultTableNodeType ResultItemType;

        // How likely this is to be rolled - larger numbers add more weight
        int32 Weight;

        FResultTableNode() :
            FPlayFabBaseModel(),
            ResultItem(),
            ResultItemType(),
            Weight(0)
            {}

        FResultTableNode(const FResultTableNode& src) :
            FPlayFabBaseModel(),
            ResultItem(src.ResultItem),
            ResultItemType(src.ResultItemType),
            Weight(src.Weight)
            {}

        FResultTableNode(const TSharedPtr<FJsonObject>& obj) : FResultTableNode()
        {
            readFromValue(obj);
        }

        ~FResultTableNode();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FRandomResultTableListing : public FPlayFabBaseModel
    {
        // [optional] Catalog version this table is associated with
        FString CatalogVersion;

        // Child nodes that indicate what kind of drop table item this actually is.
        TArray<FResultTableNode> Nodes;
        // Unique name for this drop table
        FString TableId;

        FRandomResultTableListing() :
            FPlayFabBaseModel(),
            CatalogVersion(),
            Nodes(),
            TableId()
            {}

        FRandomResultTableListing(const FRandomResultTableListing& src) :
            FPlayFabBaseModel(),
            CatalogVersion(src.CatalogVersion),
            Nodes(src.Nodes),
            TableId(src.TableId)
            {}

        FRandomResultTableListing(const TSharedPtr<FJsonObject>& obj) : FRandomResultTableListing()
        {
            readFromValue(obj);
        }

        ~FRandomResultTableListing();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetRandomResultTablesResult : public FPlayFabBaseModel
    {
        // [optional] array of random result tables currently available
        TMap<FString, FRandomResultTableListing> Tables;
        FGetRandomResultTablesResult() :
            FPlayFabBaseModel(),
            Tables()
            {}

        FGetRandomResultTablesResult(const FGetRandomResultTablesResult& src) :
            FPlayFabBaseModel(),
            Tables(src.Tables)
            {}

        FGetRandomResultTablesResult(const TSharedPtr<FJsonObject>& obj) : FGetRandomResultTablesResult()
        {
            readFromValue(obj);
        }

        ~FGetRandomResultTablesResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetServerBuildInfoRequest : public FPlayFabBaseModel
    {
        // unique identifier of the previously uploaded build executable for which information is being requested
        FString BuildId;

        FGetServerBuildInfoRequest() :
            FPlayFabBaseModel(),
            BuildId()
            {}

        FGetServerBuildInfoRequest(const FGetServerBuildInfoRequest& src) :
            FPlayFabBaseModel(),
            BuildId(src.BuildId)
            {}

        FGetServerBuildInfoRequest(const TSharedPtr<FJsonObject>& obj) : FGetServerBuildInfoRequest()
        {
            readFromValue(obj);
        }

        ~FGetServerBuildInfoRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetServerBuildInfoResult : public FPlayFabBaseModel
    {
        // [optional] array of regions where this build can used, when it is active
        TArray<Region> ActiveRegions;
        // [optional] unique identifier for this build executable
        FString BuildId;

        // [optional] developer comment(s) for this build
        FString Comment;

        // [optional] error message, if any, about this build
        FString ErrorMessage;

        // maximum number of game server instances that can run on a single host machine
        int32 MaxGamesPerHost;

        /**
         * minimum capacity of additional game server instances that can be started before the autoscaling service starts new host
         * machines (given the number of current running host machines and game server instances)
         */
        int32 MinFreeGameSlots;

        // [optional] the current status of the build validation and processing steps
        Boxed<GameBuildStatus> Status;

        // time this build was last modified (or uploaded, if this build has never been modified)
        FDateTime Timestamp;

        /**
         * [optional] Unique identifier for the title, found in the Settings > Game Properties section of the PlayFab developer site when a
         * title has been selected.
         */
        FString TitleId;

        FGetServerBuildInfoResult() :
            FPlayFabBaseModel(),
            ActiveRegions(),
            BuildId(),
            Comment(),
            ErrorMessage(),
            MaxGamesPerHost(0),
            MinFreeGameSlots(0),
            Status(),
            Timestamp(0),
            TitleId()
            {}

        FGetServerBuildInfoResult(const FGetServerBuildInfoResult& src) :
            FPlayFabBaseModel(),
            ActiveRegions(src.ActiveRegions),
            BuildId(src.BuildId),
            Comment(src.Comment),
            ErrorMessage(src.ErrorMessage),
            MaxGamesPerHost(src.MaxGamesPerHost),
            MinFreeGameSlots(src.MinFreeGameSlots),
            Status(src.Status),
            Timestamp(src.Timestamp),
            TitleId(src.TitleId)
            {}

        FGetServerBuildInfoResult(const TSharedPtr<FJsonObject>& obj) : FGetServerBuildInfoResult()
        {
            readFromValue(obj);
        }

        ~FGetServerBuildInfoResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetServerBuildUploadURLRequest : public FPlayFabBaseModel
    {
        // unique identifier of the game server build to upload
        FString BuildId;

        FGetServerBuildUploadURLRequest() :
            FPlayFabBaseModel(),
            BuildId()
            {}

        FGetServerBuildUploadURLRequest(const FGetServerBuildUploadURLRequest& src) :
            FPlayFabBaseModel(),
            BuildId(src.BuildId)
            {}

        FGetServerBuildUploadURLRequest(const TSharedPtr<FJsonObject>& obj) : FGetServerBuildUploadURLRequest()
        {
            readFromValue(obj);
        }

        ~FGetServerBuildUploadURLRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetServerBuildUploadURLResult : public FPlayFabBaseModel
    {
        // [optional] pre-authorized URL for uploading the game server build package
        FString URL;

        FGetServerBuildUploadURLResult() :
            FPlayFabBaseModel(),
            URL()
            {}

        FGetServerBuildUploadURLResult(const FGetServerBuildUploadURLResult& src) :
            FPlayFabBaseModel(),
            URL(src.URL)
            {}

        FGetServerBuildUploadURLResult(const TSharedPtr<FJsonObject>& obj) : FGetServerBuildUploadURLResult()
        {
            readFromValue(obj);
        }

        ~FGetServerBuildUploadURLResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetStoreItemsRequest : public FPlayFabBaseModel
    {
        // [optional] catalog version to store items from. Use default catalog version if null
        FString CatalogVersion;

        // Unqiue identifier for the store which is being requested.
        FString StoreId;

        FGetStoreItemsRequest() :
            FPlayFabBaseModel(),
            CatalogVersion(),
            StoreId()
            {}

        FGetStoreItemsRequest(const FGetStoreItemsRequest& src) :
            FPlayFabBaseModel(),
            CatalogVersion(src.CatalogVersion),
            StoreId(src.StoreId)
            {}

        FGetStoreItemsRequest(const TSharedPtr<FJsonObject>& obj) : FGetStoreItemsRequest()
        {
            readFromValue(obj);
        }

        ~FGetStoreItemsRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FStoreMarketingModel : public FPlayFabBaseModel
    {
        // [optional] Tagline for a store.
        FString Description;

        // [optional] Display name of a store as it will appear to users.
        FString DisplayName;

        // [optional] Custom data about a store.
        FJsonKeeper Metadata;

        FStoreMarketingModel() :
            FPlayFabBaseModel(),
            Description(),
            DisplayName(),
            Metadata()
            {}

        FStoreMarketingModel(const FStoreMarketingModel& src) :
            FPlayFabBaseModel(),
            Description(src.Description),
            DisplayName(src.DisplayName),
            Metadata(src.Metadata)
            {}

        FStoreMarketingModel(const TSharedPtr<FJsonObject>& obj) : FStoreMarketingModel()
        {
            readFromValue(obj);
        }

        ~FStoreMarketingModel();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    enum SourceType
    {
        SourceTypeAdmin,
        SourceTypeBackEnd,
        SourceTypeGameClient,
        SourceTypeGameServer,
        SourceTypePartner
    };

    PLAYFAB_API void writeSourceTypeEnumJSON(SourceType enumVal, JsonWriter& writer);
    PLAYFAB_API SourceType readSourceTypeFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFAB_API SourceType readSourceTypeFromValue(const FString& value);

    struct PLAYFAB_API FStoreItem : public FPlayFabBaseModel
    {
        // [optional] Store specific custom data. The data only exists as part of this store; it is not transferred to item instances
        FJsonKeeper CustomData;

        // [optional] Intended display position for this item. Note that 0 is the first position
        Boxed<uint32> DisplayPosition;

        /**
         * Unique identifier of the item as it exists in the catalog - note that this must exactly match the ItemId from the
         * catalog
         */
        FString ItemId;

        // [optional] Override prices for this item for specific currencies
        TMap<FString, uint32> RealCurrencyPrices;
        // [optional] Override prices for this item in virtual currencies and "RM" (the base Real Money purchase price, in USD pennies)
        TMap<FString, uint32> VirtualCurrencyPrices;
        FStoreItem() :
            FPlayFabBaseModel(),
            CustomData(),
            DisplayPosition(),
            ItemId(),
            RealCurrencyPrices(),
            VirtualCurrencyPrices()
            {}

        FStoreItem(const FStoreItem& src) :
            FPlayFabBaseModel(),
            CustomData(src.CustomData),
            DisplayPosition(src.DisplayPosition),
            ItemId(src.ItemId),
            RealCurrencyPrices(src.RealCurrencyPrices),
            VirtualCurrencyPrices(src.VirtualCurrencyPrices)
            {}

        FStoreItem(const TSharedPtr<FJsonObject>& obj) : FStoreItem()
        {
            readFromValue(obj);
        }

        ~FStoreItem();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetStoreItemsResult : public FPlayFabBaseModel
    {
        // [optional] The base catalog that this store is a part of.
        FString CatalogVersion;

        // [optional] Additional data about the store.
        TSharedPtr<FStoreMarketingModel> MarketingData;

        // [optional] How the store was last updated (Admin or a third party).
        Boxed<SourceType> Source;

        // [optional] Array of items which can be purchased from this store.
        TArray<FStoreItem> Store;
        // [optional] The ID of this store.
        FString StoreId;

        FGetStoreItemsResult() :
            FPlayFabBaseModel(),
            CatalogVersion(),
            MarketingData(nullptr),
            Source(),
            Store(),
            StoreId()
            {}

        FGetStoreItemsResult(const FGetStoreItemsResult& src) :
            FPlayFabBaseModel(),
            CatalogVersion(src.CatalogVersion),
            MarketingData(src.MarketingData.IsValid() ? MakeShareable(new FStoreMarketingModel(*src.MarketingData)) : nullptr),
            Source(src.Source),
            Store(src.Store),
            StoreId(src.StoreId)
            {}

        FGetStoreItemsResult(const TSharedPtr<FJsonObject>& obj) : FGetStoreItemsResult()
        {
            readFromValue(obj);
        }

        ~FGetStoreItemsResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetTaskInstanceRequest : public FPlayFabBaseModel
    {
        // ID of the requested task instance.
        FString TaskInstanceId;

        FGetTaskInstanceRequest() :
            FPlayFabBaseModel(),
            TaskInstanceId()
            {}

        FGetTaskInstanceRequest(const FGetTaskInstanceRequest& src) :
            FPlayFabBaseModel(),
            TaskInstanceId(src.TaskInstanceId)
            {}

        FGetTaskInstanceRequest(const TSharedPtr<FJsonObject>& obj) : FGetTaskInstanceRequest()
        {
            readFromValue(obj);
        }

        ~FGetTaskInstanceRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetTaskInstancesRequest : public FPlayFabBaseModel
    {
        // [optional] Optional range-from filter for task instances' StartedAt timestamp.
        Boxed<FDateTime> StartedAtRangeFrom;

        // [optional] Optional range-to filter for task instances' StartedAt timestamp.
        Boxed<FDateTime> StartedAtRangeTo;

        // [optional] Optional filter for task instances that are of a specific status.
        Boxed<TaskInstanceStatus> StatusFilter;

        /**
         * [optional] Name or ID of the task whose instances are being queried. If not specified, return all task instances that satisfy
         * conditions set by other filters.
         */
        TSharedPtr<FNameIdentifier> TaskIdentifier;

        FGetTaskInstancesRequest() :
            FPlayFabBaseModel(),
            StartedAtRangeFrom(),
            StartedAtRangeTo(),
            StatusFilter(),
            TaskIdentifier(nullptr)
            {}

        FGetTaskInstancesRequest(const FGetTaskInstancesRequest& src) :
            FPlayFabBaseModel(),
            StartedAtRangeFrom(src.StartedAtRangeFrom),
            StartedAtRangeTo(src.StartedAtRangeTo),
            StatusFilter(src.StatusFilter),
            TaskIdentifier(src.TaskIdentifier.IsValid() ? MakeShareable(new FNameIdentifier(*src.TaskIdentifier)) : nullptr)
            {}

        FGetTaskInstancesRequest(const TSharedPtr<FJsonObject>& obj) : FGetTaskInstancesRequest()
        {
            readFromValue(obj);
        }

        ~FGetTaskInstancesRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    enum ScheduledTaskType
    {
        ScheduledTaskTypeCloudScript,
        ScheduledTaskTypeActionsOnPlayerSegment
    };

    PLAYFAB_API void writeScheduledTaskTypeEnumJSON(ScheduledTaskType enumVal, JsonWriter& writer);
    PLAYFAB_API ScheduledTaskType readScheduledTaskTypeFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFAB_API ScheduledTaskType readScheduledTaskTypeFromValue(const FString& value);

    struct PLAYFAB_API FTaskInstanceBasicSummary : public FPlayFabBaseModel
    {
        // [optional] UTC timestamp when the task completed.
        Boxed<FDateTime> CompletedAt;

        // [optional] Estimated time remaining in seconds.
        Boxed<double> EstimatedSecondsRemaining;

        // [optional] Progress represented as percentage.
        Boxed<double> PercentComplete;

        // [optional] If manually scheduled, ID of user who scheduled the task.
        FString ScheduledByUserId;

        // UTC timestamp when the task started.
        FDateTime StartedAt;

        // [optional] Current status of the task instance.
        Boxed<TaskInstanceStatus> Status;

        // [optional] Identifier of the task this instance belongs to.
        TSharedPtr<FNameIdentifier> TaskIdentifier;

        // [optional] ID of the task instance.
        FString TaskInstanceId;

        // [optional] Type of the task.
        Boxed<ScheduledTaskType> Type;

        FTaskInstanceBasicSummary() :
            FPlayFabBaseModel(),
            CompletedAt(),
            EstimatedSecondsRemaining(),
            PercentComplete(),
            ScheduledByUserId(),
            StartedAt(0),
            Status(),
            TaskIdentifier(nullptr),
            TaskInstanceId(),
            Type()
            {}

        FTaskInstanceBasicSummary(const FTaskInstanceBasicSummary& src) :
            FPlayFabBaseModel(),
            CompletedAt(src.CompletedAt),
            EstimatedSecondsRemaining(src.EstimatedSecondsRemaining),
            PercentComplete(src.PercentComplete),
            ScheduledByUserId(src.ScheduledByUserId),
            StartedAt(src.StartedAt),
            Status(src.Status),
            TaskIdentifier(src.TaskIdentifier.IsValid() ? MakeShareable(new FNameIdentifier(*src.TaskIdentifier)) : nullptr),
            TaskInstanceId(src.TaskInstanceId),
            Type(src.Type)
            {}

        FTaskInstanceBasicSummary(const TSharedPtr<FJsonObject>& obj) : FTaskInstanceBasicSummary()
        {
            readFromValue(obj);
        }

        ~FTaskInstanceBasicSummary();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetTaskInstancesResult : public FPlayFabBaseModel
    {
        /**
         * [optional] Basic status summaries of the queried task instances. Empty If no task instances meets the filter criteria. To get
         * detailed status summary, use Get*TaskInstance API according to task type (e.g.
         * GetActionsOnPlayersInSegmentTaskInstance).
         */
        TArray<FTaskInstanceBasicSummary> Summaries;
        FGetTaskInstancesResult() :
            FPlayFabBaseModel(),
            Summaries()
            {}

        FGetTaskInstancesResult(const FGetTaskInstancesResult& src) :
            FPlayFabBaseModel(),
            Summaries(src.Summaries)
            {}

        FGetTaskInstancesResult(const TSharedPtr<FJsonObject>& obj) : FGetTaskInstancesResult()
        {
            readFromValue(obj);
        }

        ~FGetTaskInstancesResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetTasksRequest : public FPlayFabBaseModel
    {
        // [optional] Provide either the task ID or the task name to get a specific task. If not specified, return all defined tasks.
        TSharedPtr<FNameIdentifier> Identifier;

        FGetTasksRequest() :
            FPlayFabBaseModel(),
            Identifier(nullptr)
            {}

        FGetTasksRequest(const FGetTasksRequest& src) :
            FPlayFabBaseModel(),
            Identifier(src.Identifier.IsValid() ? MakeShareable(new FNameIdentifier(*src.Identifier)) : nullptr)
            {}

        FGetTasksRequest(const TSharedPtr<FJsonObject>& obj) : FGetTasksRequest()
        {
            readFromValue(obj);
        }

        ~FGetTasksRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FScheduledTask : public FPlayFabBaseModel
    {
        // [optional] Description the task
        FString Description;

        // Whether the schedule is active. Inactive schedule will not trigger task execution.
        bool IsActive;

        // [optional] UTC time of last run
        Boxed<FDateTime> LastRunTime;

        // Name of the task. This is a unique identifier for tasks in the title.
        FString Name;

        // [optional] UTC time of next run
        Boxed<FDateTime> NextRunTime;

        /**
         * [optional] Task parameter. Different types of task have different parameter structure. See each task type's create API
         * documentation for the details.
         */
        FJsonKeeper Parameter;

        // [optional] Cron expression for the run schedule of the task. The expression should be in UTC.
        FString Schedule;

        // [optional] ID of the task
        FString TaskId;

        // [optional] Task type.
        Boxed<ScheduledTaskType> Type;

        FScheduledTask() :
            FPlayFabBaseModel(),
            Description(),
            IsActive(false),
            LastRunTime(),
            Name(),
            NextRunTime(),
            Parameter(),
            Schedule(),
            TaskId(),
            Type()
            {}

        FScheduledTask(const FScheduledTask& src) :
            FPlayFabBaseModel(),
            Description(src.Description),
            IsActive(src.IsActive),
            LastRunTime(src.LastRunTime),
            Name(src.Name),
            NextRunTime(src.NextRunTime),
            Parameter(src.Parameter),
            Schedule(src.Schedule),
            TaskId(src.TaskId),
            Type(src.Type)
            {}

        FScheduledTask(const TSharedPtr<FJsonObject>& obj) : FScheduledTask()
        {
            readFromValue(obj);
        }

        ~FScheduledTask();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetTasksResult : public FPlayFabBaseModel
    {
        // [optional] Result tasks. Empty if there is no task found.
        TArray<FScheduledTask> Tasks;
        FGetTasksResult() :
            FPlayFabBaseModel(),
            Tasks()
            {}

        FGetTasksResult(const FGetTasksResult& src) :
            FPlayFabBaseModel(),
            Tasks(src.Tasks)
            {}

        FGetTasksResult(const TSharedPtr<FJsonObject>& obj) : FGetTasksResult()
        {
            readFromValue(obj);
        }

        ~FGetTasksResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetTitleDataRequest : public FPlayFabBaseModel
    {
        // [optional] Specific keys to search for in the title data (leave null to get all keys)
        TArray<FString> Keys;
        FGetTitleDataRequest() :
            FPlayFabBaseModel(),
            Keys()
            {}

        FGetTitleDataRequest(const FGetTitleDataRequest& src) :
            FPlayFabBaseModel(),
            Keys(src.Keys)
            {}

        FGetTitleDataRequest(const TSharedPtr<FJsonObject>& obj) : FGetTitleDataRequest()
        {
            readFromValue(obj);
        }

        ~FGetTitleDataRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetTitleDataResult : public FPlayFabBaseModel
    {
        // [optional] a dictionary object of key / value pairs
        TMap<FString, FString> Data;
        FGetTitleDataResult() :
            FPlayFabBaseModel(),
            Data()
            {}

        FGetTitleDataResult(const FGetTitleDataResult& src) :
            FPlayFabBaseModel(),
            Data(src.Data)
            {}

        FGetTitleDataResult(const TSharedPtr<FJsonObject>& obj) : FGetTitleDataResult()
        {
            readFromValue(obj);
        }

        ~FGetTitleDataResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetUserBansRequest : public FPlayFabBaseModel
    {
        // Unique PlayFab assigned ID of the user on whom the operation will be performed.
        FString PlayFabId;

        FGetUserBansRequest() :
            FPlayFabBaseModel(),
            PlayFabId()
            {}

        FGetUserBansRequest(const FGetUserBansRequest& src) :
            FPlayFabBaseModel(),
            PlayFabId(src.PlayFabId)
            {}

        FGetUserBansRequest(const TSharedPtr<FJsonObject>& obj) : FGetUserBansRequest()
        {
            readFromValue(obj);
        }

        ~FGetUserBansRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetUserBansResult : public FPlayFabBaseModel
    {
        // [optional] Information about the bans
        TArray<FBanInfo> BanData;
        FGetUserBansResult() :
            FPlayFabBaseModel(),
            BanData()
            {}

        FGetUserBansResult(const FGetUserBansResult& src) :
            FPlayFabBaseModel(),
            BanData(src.BanData)
            {}

        FGetUserBansResult(const TSharedPtr<FJsonObject>& obj) : FGetUserBansResult()
        {
            readFromValue(obj);
        }

        ~FGetUserBansResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetUserDataRequest : public FPlayFabBaseModel
    {
        /**
         * [optional] The version that currently exists according to the caller. The call will return the data for all of the keys if the
         * version in the system is greater than this.
         */
        Boxed<uint32> IfChangedFromDataVersion;

        // [optional] Specific keys to search for in the custom user data.
        TArray<FString> Keys;
        // Unique PlayFab assigned ID of the user on whom the operation will be performed.
        FString PlayFabId;

        FGetUserDataRequest() :
            FPlayFabBaseModel(),
            IfChangedFromDataVersion(),
            Keys(),
            PlayFabId()
            {}

        FGetUserDataRequest(const FGetUserDataRequest& src) :
            FPlayFabBaseModel(),
            IfChangedFromDataVersion(src.IfChangedFromDataVersion),
            Keys(src.Keys),
            PlayFabId(src.PlayFabId)
            {}

        FGetUserDataRequest(const TSharedPtr<FJsonObject>& obj) : FGetUserDataRequest()
        {
            readFromValue(obj);
        }

        ~FGetUserDataRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    enum UserDataPermission
    {
        UserDataPermissionPrivate,
        UserDataPermissionPublic
    };

    PLAYFAB_API void writeUserDataPermissionEnumJSON(UserDataPermission enumVal, JsonWriter& writer);
    PLAYFAB_API UserDataPermission readUserDataPermissionFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFAB_API UserDataPermission readUserDataPermissionFromValue(const FString& value);

    struct PLAYFAB_API FUserDataRecord : public FPlayFabBaseModel
    {
        // Timestamp for when this data was last updated.
        FDateTime LastUpdated;

        /**
         * [optional] Indicates whether this data can be read by all users (public) or only the user (private). This is used for GetUserData
         * requests being made by one player about another player.
         */
        Boxed<UserDataPermission> Permission;

        // [optional] Data stored for the specified user data key.
        FString Value;

        FUserDataRecord() :
            FPlayFabBaseModel(),
            LastUpdated(0),
            Permission(),
            Value()
            {}

        FUserDataRecord(const FUserDataRecord& src) :
            FPlayFabBaseModel(),
            LastUpdated(src.LastUpdated),
            Permission(src.Permission),
            Value(src.Value)
            {}

        FUserDataRecord(const TSharedPtr<FJsonObject>& obj) : FUserDataRecord()
        {
            readFromValue(obj);
        }

        ~FUserDataRecord();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetUserDataResult : public FPlayFabBaseModel
    {
        // [optional] User specific data for this title.
        TMap<FString, FUserDataRecord> Data;
        /**
         * Indicates the current version of the data that has been set. This is incremented with every set call for that type of
         * data (read-only, internal, etc). This version can be provided in Get calls to find updated data.
         */
        uint32 DataVersion;

        // [optional] PlayFab unique identifier of the user whose custom data is being returned.
        FString PlayFabId;

        FGetUserDataResult() :
            FPlayFabBaseModel(),
            Data(),
            DataVersion(0),
            PlayFabId()
            {}

        FGetUserDataResult(const FGetUserDataResult& src) :
            FPlayFabBaseModel(),
            Data(src.Data),
            DataVersion(src.DataVersion),
            PlayFabId(src.PlayFabId)
            {}

        FGetUserDataResult(const TSharedPtr<FJsonObject>& obj) : FGetUserDataResult()
        {
            readFromValue(obj);
        }

        ~FGetUserDataResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetUserInventoryRequest : public FPlayFabBaseModel
    {
        // Unique PlayFab assigned ID of the user on whom the operation will be performed.
        FString PlayFabId;

        FGetUserInventoryRequest() :
            FPlayFabBaseModel(),
            PlayFabId()
            {}

        FGetUserInventoryRequest(const FGetUserInventoryRequest& src) :
            FPlayFabBaseModel(),
            PlayFabId(src.PlayFabId)
            {}

        FGetUserInventoryRequest(const TSharedPtr<FJsonObject>& obj) : FGetUserInventoryRequest()
        {
            readFromValue(obj);
        }

        ~FGetUserInventoryRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FItemInstance : public FPlayFabBaseModel
    {
        // [optional] Game specific comment associated with this instance when it was added to the user inventory.
        FString Annotation;

        // [optional] Array of unique items that were awarded when this catalog item was purchased.
        TArray<FString> BundleContents;
        /**
         * [optional] Unique identifier for the parent inventory item, as defined in the catalog, for object which were added from a bundle or
         * container.
         */
        FString BundleParent;

        // [optional] Catalog version for the inventory item, when this instance was created.
        FString CatalogVersion;

        // [optional] A set of custom key-value pairs on the inventory item.
        TMap<FString, FString> CustomData;
        // [optional] CatalogItem.DisplayName at the time this item was purchased.
        FString DisplayName;

        // [optional] Timestamp for when this instance will expire.
        Boxed<FDateTime> Expiration;

        // [optional] Class name for the inventory item, as defined in the catalog.
        FString ItemClass;

        // [optional] Unique identifier for the inventory item, as defined in the catalog.
        FString ItemId;

        // [optional] Unique item identifier for this specific instance of the item.
        FString ItemInstanceId;

        // [optional] Timestamp for when this instance was purchased.
        Boxed<FDateTime> PurchaseDate;

        // [optional] Total number of remaining uses, if this is a consumable item.
        Boxed<int32> RemainingUses;

        // [optional] Currency type for the cost of the catalog item.
        FString UnitCurrency;

        // Cost of the catalog item in the given currency.
        uint32 UnitPrice;

        // [optional] The number of uses that were added or removed to this item in this call.
        Boxed<int32> UsesIncrementedBy;

        FItemInstance() :
            FPlayFabBaseModel(),
            Annotation(),
            BundleContents(),
            BundleParent(),
            CatalogVersion(),
            CustomData(),
            DisplayName(),
            Expiration(),
            ItemClass(),
            ItemId(),
            ItemInstanceId(),
            PurchaseDate(),
            RemainingUses(),
            UnitCurrency(),
            UnitPrice(0),
            UsesIncrementedBy()
            {}

        FItemInstance(const FItemInstance& src) :
            FPlayFabBaseModel(),
            Annotation(src.Annotation),
            BundleContents(src.BundleContents),
            BundleParent(src.BundleParent),
            CatalogVersion(src.CatalogVersion),
            CustomData(src.CustomData),
            DisplayName(src.DisplayName),
            Expiration(src.Expiration),
            ItemClass(src.ItemClass),
            ItemId(src.ItemId),
            ItemInstanceId(src.ItemInstanceId),
            PurchaseDate(src.PurchaseDate),
            RemainingUses(src.RemainingUses),
            UnitCurrency(src.UnitCurrency),
            UnitPrice(src.UnitPrice),
            UsesIncrementedBy(src.UsesIncrementedBy)
            {}

        FItemInstance(const TSharedPtr<FJsonObject>& obj) : FItemInstance()
        {
            readFromValue(obj);
        }

        ~FItemInstance();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FVirtualCurrencyRechargeTime : public FPlayFabBaseModel
    {
        /**
         * Maximum value to which the regenerating currency will automatically increment. Note that it can exceed this value
         * through use of the AddUserVirtualCurrency API call. However, it will not regenerate automatically until it has fallen
         * below this value.
         */
        int32 RechargeMax;

        // Server timestamp in UTC indicating the next time the virtual currency will be incremented.
        FDateTime RechargeTime;

        // Time remaining (in seconds) before the next recharge increment of the virtual currency.
        int32 SecondsToRecharge;

        FVirtualCurrencyRechargeTime() :
            FPlayFabBaseModel(),
            RechargeMax(0),
            RechargeTime(0),
            SecondsToRecharge(0)
            {}

        FVirtualCurrencyRechargeTime(const FVirtualCurrencyRechargeTime& src) :
            FPlayFabBaseModel(),
            RechargeMax(src.RechargeMax),
            RechargeTime(src.RechargeTime),
            SecondsToRecharge(src.SecondsToRecharge)
            {}

        FVirtualCurrencyRechargeTime(const TSharedPtr<FJsonObject>& obj) : FVirtualCurrencyRechargeTime()
        {
            readFromValue(obj);
        }

        ~FVirtualCurrencyRechargeTime();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetUserInventoryResult : public FPlayFabBaseModel
    {
        // [optional] Array of inventory items belonging to the user.
        TArray<FItemInstance> Inventory;
        // [optional] Unique PlayFab assigned ID of the user on whom the operation will be performed.
        FString PlayFabId;

        // [optional] Array of virtual currency balance(s) belonging to the user.
        TMap<FString, int32> VirtualCurrency;
        // [optional] Array of remaining times and timestamps for virtual currencies.
        TMap<FString, FVirtualCurrencyRechargeTime> VirtualCurrencyRechargeTimes;
        FGetUserInventoryResult() :
            FPlayFabBaseModel(),
            Inventory(),
            PlayFabId(),
            VirtualCurrency(),
            VirtualCurrencyRechargeTimes()
            {}

        FGetUserInventoryResult(const FGetUserInventoryResult& src) :
            FPlayFabBaseModel(),
            Inventory(src.Inventory),
            PlayFabId(src.PlayFabId),
            VirtualCurrency(src.VirtualCurrency),
            VirtualCurrencyRechargeTimes(src.VirtualCurrencyRechargeTimes)
            {}

        FGetUserInventoryResult(const TSharedPtr<FJsonObject>& obj) : FGetUserInventoryResult()
        {
            readFromValue(obj);
        }

        ~FGetUserInventoryResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGrantedItemInstance : public FPlayFabBaseModel
    {
        // [optional] Game specific comment associated with this instance when it was added to the user inventory.
        FString Annotation;

        // [optional] Array of unique items that were awarded when this catalog item was purchased.
        TArray<FString> BundleContents;
        /**
         * [optional] Unique identifier for the parent inventory item, as defined in the catalog, for object which were added from a bundle or
         * container.
         */
        FString BundleParent;

        // [optional] Catalog version for the inventory item, when this instance was created.
        FString CatalogVersion;

        // [optional] Unique PlayFab assigned ID for a specific character owned by a user
        FString CharacterId;

        // [optional] A set of custom key-value pairs on the inventory item.
        TMap<FString, FString> CustomData;
        // [optional] CatalogItem.DisplayName at the time this item was purchased.
        FString DisplayName;

        // [optional] Timestamp for when this instance will expire.
        Boxed<FDateTime> Expiration;

        // [optional] Class name for the inventory item, as defined in the catalog.
        FString ItemClass;

        // [optional] Unique identifier for the inventory item, as defined in the catalog.
        FString ItemId;

        // [optional] Unique item identifier for this specific instance of the item.
        FString ItemInstanceId;

        // [optional] Unique PlayFab assigned ID of the user on whom the operation will be performed.
        FString PlayFabId;

        // [optional] Timestamp for when this instance was purchased.
        Boxed<FDateTime> PurchaseDate;

        // [optional] Total number of remaining uses, if this is a consumable item.
        Boxed<int32> RemainingUses;

        // Result of this operation.
        bool Result;

        // [optional] Currency type for the cost of the catalog item.
        FString UnitCurrency;

        // Cost of the catalog item in the given currency.
        uint32 UnitPrice;

        // [optional] The number of uses that were added or removed to this item in this call.
        Boxed<int32> UsesIncrementedBy;

        FGrantedItemInstance() :
            FPlayFabBaseModel(),
            Annotation(),
            BundleContents(),
            BundleParent(),
            CatalogVersion(),
            CharacterId(),
            CustomData(),
            DisplayName(),
            Expiration(),
            ItemClass(),
            ItemId(),
            ItemInstanceId(),
            PlayFabId(),
            PurchaseDate(),
            RemainingUses(),
            Result(false),
            UnitCurrency(),
            UnitPrice(0),
            UsesIncrementedBy()
            {}

        FGrantedItemInstance(const FGrantedItemInstance& src) :
            FPlayFabBaseModel(),
            Annotation(src.Annotation),
            BundleContents(src.BundleContents),
            BundleParent(src.BundleParent),
            CatalogVersion(src.CatalogVersion),
            CharacterId(src.CharacterId),
            CustomData(src.CustomData),
            DisplayName(src.DisplayName),
            Expiration(src.Expiration),
            ItemClass(src.ItemClass),
            ItemId(src.ItemId),
            ItemInstanceId(src.ItemInstanceId),
            PlayFabId(src.PlayFabId),
            PurchaseDate(src.PurchaseDate),
            RemainingUses(src.RemainingUses),
            Result(src.Result),
            UnitCurrency(src.UnitCurrency),
            UnitPrice(src.UnitPrice),
            UsesIncrementedBy(src.UsesIncrementedBy)
            {}

        FGrantedItemInstance(const TSharedPtr<FJsonObject>& obj) : FGrantedItemInstance()
        {
            readFromValue(obj);
        }

        ~FGrantedItemInstance();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FItemGrant : public FPlayFabBaseModel
    {
        // [optional] String detailing any additional information concerning this operation.
        FString Annotation;

        // [optional] Unique PlayFab assigned ID for a specific character owned by a user
        FString CharacterId;

        /**
         * [optional] Key-value pairs to be written to the custom data. Note that keys are trimmed of whitespace, are limited in size, and may
         * not begin with a '!' character or be null.
         */
        TMap<FString, FString> Data;
        // Unique identifier of the catalog item to be granted to the user.
        FString ItemId;

        /**
         * [optional] Optional list of Data-keys to remove from UserData. Some SDKs cannot insert null-values into Data due to language
         * constraints. Use this to delete the keys directly.
         */
        TArray<FString> KeysToRemove;
        // Unique PlayFab assigned ID of the user on whom the operation will be performed.
        FString PlayFabId;

        FItemGrant() :
            FPlayFabBaseModel(),
            Annotation(),
            CharacterId(),
            Data(),
            ItemId(),
            KeysToRemove(),
            PlayFabId()
            {}

        FItemGrant(const FItemGrant& src) :
            FPlayFabBaseModel(),
            Annotation(src.Annotation),
            CharacterId(src.CharacterId),
            Data(src.Data),
            ItemId(src.ItemId),
            KeysToRemove(src.KeysToRemove),
            PlayFabId(src.PlayFabId)
            {}

        FItemGrant(const TSharedPtr<FJsonObject>& obj) : FItemGrant()
        {
            readFromValue(obj);
        }

        ~FItemGrant();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGrantItemsToUsersRequest : public FPlayFabBaseModel
    {
        // [optional] Catalog version from which items are to be granted.
        FString CatalogVersion;

        // Array of items to grant and the users to whom the items are to be granted.
        TArray<FItemGrant> ItemGrants;
        FGrantItemsToUsersRequest() :
            FPlayFabBaseModel(),
            CatalogVersion(),
            ItemGrants()
            {}

        FGrantItemsToUsersRequest(const FGrantItemsToUsersRequest& src) :
            FPlayFabBaseModel(),
            CatalogVersion(src.CatalogVersion),
            ItemGrants(src.ItemGrants)
            {}

        FGrantItemsToUsersRequest(const TSharedPtr<FJsonObject>& obj) : FGrantItemsToUsersRequest()
        {
            readFromValue(obj);
        }

        ~FGrantItemsToUsersRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGrantItemsToUsersResult : public FPlayFabBaseModel
    {
        // [optional] Array of items granted to users.
        TArray<FGrantedItemInstance> ItemGrantResults;
        FGrantItemsToUsersResult() :
            FPlayFabBaseModel(),
            ItemGrantResults()
            {}

        FGrantItemsToUsersResult(const FGrantItemsToUsersResult& src) :
            FPlayFabBaseModel(),
            ItemGrantResults(src.ItemGrantResults)
            {}

        FGrantItemsToUsersResult(const TSharedPtr<FJsonObject>& obj) : FGrantItemsToUsersResult()
        {
            readFromValue(obj);
        }

        ~FGrantItemsToUsersResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FIncrementLimitedEditionItemAvailabilityRequest : public FPlayFabBaseModel
    {
        // Amount to increase availability by.
        int32 Amount;

        // [optional] Which catalog is being updated. If null, uses the default catalog.
        FString CatalogVersion;

        // The item which needs more availability.
        FString ItemId;

        FIncrementLimitedEditionItemAvailabilityRequest() :
            FPlayFabBaseModel(),
            Amount(0),
            CatalogVersion(),
            ItemId()
            {}

        FIncrementLimitedEditionItemAvailabilityRequest(const FIncrementLimitedEditionItemAvailabilityRequest& src) :
            FPlayFabBaseModel(),
            Amount(src.Amount),
            CatalogVersion(src.CatalogVersion),
            ItemId(src.ItemId)
            {}

        FIncrementLimitedEditionItemAvailabilityRequest(const TSharedPtr<FJsonObject>& obj) : FIncrementLimitedEditionItemAvailabilityRequest()
        {
            readFromValue(obj);
        }

        ~FIncrementLimitedEditionItemAvailabilityRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FIncrementLimitedEditionItemAvailabilityResult : public FPlayFabBaseModel
    {
        FIncrementLimitedEditionItemAvailabilityResult() :
            FPlayFabBaseModel()
            {}

        FIncrementLimitedEditionItemAvailabilityResult(const FIncrementLimitedEditionItemAvailabilityResult& src) :
            FPlayFabBaseModel()
            {}

        FIncrementLimitedEditionItemAvailabilityResult(const TSharedPtr<FJsonObject>& obj) : FIncrementLimitedEditionItemAvailabilityResult()
        {
            readFromValue(obj);
        }

        ~FIncrementLimitedEditionItemAvailabilityResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FIncrementPlayerStatisticVersionRequest : public FPlayFabBaseModel
    {
        // [optional] unique name of the statistic
        FString StatisticName;

        FIncrementPlayerStatisticVersionRequest() :
            FPlayFabBaseModel(),
            StatisticName()
            {}

        FIncrementPlayerStatisticVersionRequest(const FIncrementPlayerStatisticVersionRequest& src) :
            FPlayFabBaseModel(),
            StatisticName(src.StatisticName)
            {}

        FIncrementPlayerStatisticVersionRequest(const TSharedPtr<FJsonObject>& obj) : FIncrementPlayerStatisticVersionRequest()
        {
            readFromValue(obj);
        }

        ~FIncrementPlayerStatisticVersionRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FIncrementPlayerStatisticVersionResult : public FPlayFabBaseModel
    {
        // [optional] version change history of the statistic
        TSharedPtr<FPlayerStatisticVersion> StatisticVersion;

        FIncrementPlayerStatisticVersionResult() :
            FPlayFabBaseModel(),
            StatisticVersion(nullptr)
            {}

        FIncrementPlayerStatisticVersionResult(const FIncrementPlayerStatisticVersionResult& src) :
            FPlayFabBaseModel(),
            StatisticVersion(src.StatisticVersion.IsValid() ? MakeShareable(new FPlayerStatisticVersion(*src.StatisticVersion)) : nullptr)
            {}

        FIncrementPlayerStatisticVersionResult(const TSharedPtr<FJsonObject>& obj) : FIncrementPlayerStatisticVersionResult()
        {
            readFromValue(obj);
        }

        ~FIncrementPlayerStatisticVersionResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FListBuildsRequest : public FPlayFabBaseModel
    {
        FListBuildsRequest() :
            FPlayFabBaseModel()
            {}

        FListBuildsRequest(const FListBuildsRequest& src) :
            FPlayFabBaseModel()
            {}

        FListBuildsRequest(const TSharedPtr<FJsonObject>& obj) : FListBuildsRequest()
        {
            readFromValue(obj);
        }

        ~FListBuildsRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FListBuildsResult : public FPlayFabBaseModel
    {
        // [optional] array of uploaded game server builds
        TArray<FGetServerBuildInfoResult> Builds;
        FListBuildsResult() :
            FPlayFabBaseModel(),
            Builds()
            {}

        FListBuildsResult(const FListBuildsResult& src) :
            FPlayFabBaseModel(),
            Builds(src.Builds)
            {}

        FListBuildsResult(const TSharedPtr<FJsonObject>& obj) : FListBuildsResult()
        {
            readFromValue(obj);
        }

        ~FListBuildsResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FListVirtualCurrencyTypesRequest : public FPlayFabBaseModel
    {
        FListVirtualCurrencyTypesRequest() :
            FPlayFabBaseModel()
            {}

        FListVirtualCurrencyTypesRequest(const FListVirtualCurrencyTypesRequest& src) :
            FPlayFabBaseModel()
            {}

        FListVirtualCurrencyTypesRequest(const TSharedPtr<FJsonObject>& obj) : FListVirtualCurrencyTypesRequest()
        {
            readFromValue(obj);
        }

        ~FListVirtualCurrencyTypesRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FListVirtualCurrencyTypesResult : public FPlayFabBaseModel
    {
        // [optional] List of virtual currency names defined for this title
        TArray<FVirtualCurrencyData> VirtualCurrencies;
        FListVirtualCurrencyTypesResult() :
            FPlayFabBaseModel(),
            VirtualCurrencies()
            {}

        FListVirtualCurrencyTypesResult(const FListVirtualCurrencyTypesResult& src) :
            FPlayFabBaseModel(),
            VirtualCurrencies(src.VirtualCurrencies)
            {}

        FListVirtualCurrencyTypesResult(const TSharedPtr<FJsonObject>& obj) : FListVirtualCurrencyTypesResult()
        {
            readFromValue(obj);
        }

        ~FListVirtualCurrencyTypesResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FLookupUserAccountInfoRequest : public FPlayFabBaseModel
    {
        // [optional] User email address attached to their account
        FString Email;

        // [optional] Unique PlayFab assigned ID of the user on whom the operation will be performed.
        FString PlayFabId;

        // [optional] Title specific username to match against existing user accounts
        FString TitleDisplayName;

        // [optional] PlayFab username for the account (3-20 characters)
        FString Username;

        FLookupUserAccountInfoRequest() :
            FPlayFabBaseModel(),
            Email(),
            PlayFabId(),
            TitleDisplayName(),
            Username()
            {}

        FLookupUserAccountInfoRequest(const FLookupUserAccountInfoRequest& src) :
            FPlayFabBaseModel(),
            Email(src.Email),
            PlayFabId(src.PlayFabId),
            TitleDisplayName(src.TitleDisplayName),
            Username(src.Username)
            {}

        FLookupUserAccountInfoRequest(const TSharedPtr<FJsonObject>& obj) : FLookupUserAccountInfoRequest()
        {
            readFromValue(obj);
        }

        ~FLookupUserAccountInfoRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUserAndroidDeviceInfo : public FPlayFabBaseModel
    {
        // [optional] Android device ID
        FString AndroidDeviceId;

        FUserAndroidDeviceInfo() :
            FPlayFabBaseModel(),
            AndroidDeviceId()
            {}

        FUserAndroidDeviceInfo(const FUserAndroidDeviceInfo& src) :
            FPlayFabBaseModel(),
            AndroidDeviceId(src.AndroidDeviceId)
            {}

        FUserAndroidDeviceInfo(const TSharedPtr<FJsonObject>& obj) : FUserAndroidDeviceInfo()
        {
            readFromValue(obj);
        }

        ~FUserAndroidDeviceInfo();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUserCustomIdInfo : public FPlayFabBaseModel
    {
        // [optional] Custom ID
        FString CustomId;

        FUserCustomIdInfo() :
            FPlayFabBaseModel(),
            CustomId()
            {}

        FUserCustomIdInfo(const FUserCustomIdInfo& src) :
            FPlayFabBaseModel(),
            CustomId(src.CustomId)
            {}

        FUserCustomIdInfo(const TSharedPtr<FJsonObject>& obj) : FUserCustomIdInfo()
        {
            readFromValue(obj);
        }

        ~FUserCustomIdInfo();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUserFacebookInfo : public FPlayFabBaseModel
    {
        // [optional] Facebook identifier
        FString FacebookId;

        // [optional] Facebook full name
        FString FullName;

        FUserFacebookInfo() :
            FPlayFabBaseModel(),
            FacebookId(),
            FullName()
            {}

        FUserFacebookInfo(const FUserFacebookInfo& src) :
            FPlayFabBaseModel(),
            FacebookId(src.FacebookId),
            FullName(src.FullName)
            {}

        FUserFacebookInfo(const TSharedPtr<FJsonObject>& obj) : FUserFacebookInfo()
        {
            readFromValue(obj);
        }

        ~FUserFacebookInfo();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUserGameCenterInfo : public FPlayFabBaseModel
    {
        // [optional] Gamecenter identifier
        FString GameCenterId;

        FUserGameCenterInfo() :
            FPlayFabBaseModel(),
            GameCenterId()
            {}

        FUserGameCenterInfo(const FUserGameCenterInfo& src) :
            FPlayFabBaseModel(),
            GameCenterId(src.GameCenterId)
            {}

        FUserGameCenterInfo(const TSharedPtr<FJsonObject>& obj) : FUserGameCenterInfo()
        {
            readFromValue(obj);
        }

        ~FUserGameCenterInfo();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUserGoogleInfo : public FPlayFabBaseModel
    {
        // [optional] Email address of the Google account
        FString GoogleEmail;

        // [optional] Gender information of the Google account
        FString GoogleGender;

        // [optional] Google ID
        FString GoogleId;

        // [optional] Locale of the Google account
        FString GoogleLocale;

        FUserGoogleInfo() :
            FPlayFabBaseModel(),
            GoogleEmail(),
            GoogleGender(),
            GoogleId(),
            GoogleLocale()
            {}

        FUserGoogleInfo(const FUserGoogleInfo& src) :
            FPlayFabBaseModel(),
            GoogleEmail(src.GoogleEmail),
            GoogleGender(src.GoogleGender),
            GoogleId(src.GoogleId),
            GoogleLocale(src.GoogleLocale)
            {}

        FUserGoogleInfo(const TSharedPtr<FJsonObject>& obj) : FUserGoogleInfo()
        {
            readFromValue(obj);
        }

        ~FUserGoogleInfo();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUserIosDeviceInfo : public FPlayFabBaseModel
    {
        // [optional] iOS device ID
        FString IosDeviceId;

        FUserIosDeviceInfo() :
            FPlayFabBaseModel(),
            IosDeviceId()
            {}

        FUserIosDeviceInfo(const FUserIosDeviceInfo& src) :
            FPlayFabBaseModel(),
            IosDeviceId(src.IosDeviceId)
            {}

        FUserIosDeviceInfo(const TSharedPtr<FJsonObject>& obj) : FUserIosDeviceInfo()
        {
            readFromValue(obj);
        }

        ~FUserIosDeviceInfo();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUserKongregateInfo : public FPlayFabBaseModel
    {
        // [optional] Kongregate ID
        FString KongregateId;

        // [optional] Kongregate Username
        FString KongregateName;

        FUserKongregateInfo() :
            FPlayFabBaseModel(),
            KongregateId(),
            KongregateName()
            {}

        FUserKongregateInfo(const FUserKongregateInfo& src) :
            FPlayFabBaseModel(),
            KongregateId(src.KongregateId),
            KongregateName(src.KongregateName)
            {}

        FUserKongregateInfo(const TSharedPtr<FJsonObject>& obj) : FUserKongregateInfo()
        {
            readFromValue(obj);
        }

        ~FUserKongregateInfo();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUserPrivateAccountInfo : public FPlayFabBaseModel
    {
        // [optional] user email address
        FString Email;

        FUserPrivateAccountInfo() :
            FPlayFabBaseModel(),
            Email()
            {}

        FUserPrivateAccountInfo(const FUserPrivateAccountInfo& src) :
            FPlayFabBaseModel(),
            Email(src.Email)
            {}

        FUserPrivateAccountInfo(const TSharedPtr<FJsonObject>& obj) : FUserPrivateAccountInfo()
        {
            readFromValue(obj);
        }

        ~FUserPrivateAccountInfo();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUserPsnInfo : public FPlayFabBaseModel
    {
        // [optional] PSN account ID
        FString PsnAccountId;

        // [optional] PSN online ID
        FString PsnOnlineId;

        FUserPsnInfo() :
            FPlayFabBaseModel(),
            PsnAccountId(),
            PsnOnlineId()
            {}

        FUserPsnInfo(const FUserPsnInfo& src) :
            FPlayFabBaseModel(),
            PsnAccountId(src.PsnAccountId),
            PsnOnlineId(src.PsnOnlineId)
            {}

        FUserPsnInfo(const TSharedPtr<FJsonObject>& obj) : FUserPsnInfo()
        {
            readFromValue(obj);
        }

        ~FUserPsnInfo();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    enum TitleActivationStatus
    {
        TitleActivationStatusNone,
        TitleActivationStatusActivatedTitleKey,
        TitleActivationStatusPendingSteam,
        TitleActivationStatusActivatedSteam,
        TitleActivationStatusRevokedSteam
    };

    PLAYFAB_API void writeTitleActivationStatusEnumJSON(TitleActivationStatus enumVal, JsonWriter& writer);
    PLAYFAB_API TitleActivationStatus readTitleActivationStatusFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFAB_API TitleActivationStatus readTitleActivationStatusFromValue(const FString& value);

    struct PLAYFAB_API FUserSteamInfo : public FPlayFabBaseModel
    {
        // [optional] what stage of game ownership the user is listed as being in, from Steam
        Boxed<TitleActivationStatus> SteamActivationStatus;

        // [optional] the country in which the player resides, from Steam data
        FString SteamCountry;

        // [optional] currency type set in the user Steam account
        Boxed<Currency> SteamCurrency;

        // [optional] Steam identifier
        FString SteamId;

        FUserSteamInfo() :
            FPlayFabBaseModel(),
            SteamActivationStatus(),
            SteamCountry(),
            SteamCurrency(),
            SteamId()
            {}

        FUserSteamInfo(const FUserSteamInfo& src) :
            FPlayFabBaseModel(),
            SteamActivationStatus(src.SteamActivationStatus),
            SteamCountry(src.SteamCountry),
            SteamCurrency(src.SteamCurrency),
            SteamId(src.SteamId)
            {}

        FUserSteamInfo(const TSharedPtr<FJsonObject>& obj) : FUserSteamInfo()
        {
            readFromValue(obj);
        }

        ~FUserSteamInfo();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    enum UserOrigination
    {
        UserOriginationOrganic,
        UserOriginationSteam,
        UserOriginationGoogle,
        UserOriginationAmazon,
        UserOriginationFacebook,
        UserOriginationKongregate,
        UserOriginationGamersFirst,
        UserOriginationUnknown,
        UserOriginationIOS,
        UserOriginationLoadTest,
        UserOriginationAndroid,
        UserOriginationPSN,
        UserOriginationGameCenter,
        UserOriginationCustomId,
        UserOriginationXboxLive,
        UserOriginationParse,
        UserOriginationTwitch,
        UserOriginationWindowsHello
    };

    PLAYFAB_API void writeUserOriginationEnumJSON(UserOrigination enumVal, JsonWriter& writer);
    PLAYFAB_API UserOrigination readUserOriginationFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFAB_API UserOrigination readUserOriginationFromValue(const FString& value);

    struct PLAYFAB_API FUserTitleInfo : public FPlayFabBaseModel
    {
        // [optional] URL to the player's avatar.
        FString AvatarUrl;

        /**
         * timestamp indicating when the user was first associated with this game (this can differ significantly from when the user
         * first registered with PlayFab)
         */
        FDateTime Created;

        // [optional] name of the user, as it is displayed in-game
        FString DisplayName;

        /**
         * [optional] timestamp indicating when the user first signed into this game (this can differ from the Created timestamp, as other
         * events, such as issuing a beta key to the user, can associate the title to the user)
         */
        Boxed<FDateTime> FirstLogin;

        // [optional] boolean indicating whether or not the user is currently banned for a title
        Boxed<bool> isBanned;

        // [optional] timestamp for the last user login for this title
        Boxed<FDateTime> LastLogin;

        // [optional] source by which the user first joined the game, if known
        Boxed<UserOrigination> Origination;

        // [optional] Title player account entity for this user
        TSharedPtr<FEntityKey> TitlePlayerAccount;

        FUserTitleInfo() :
            FPlayFabBaseModel(),
            AvatarUrl(),
            Created(0),
            DisplayName(),
            FirstLogin(),
            isBanned(),
            LastLogin(),
            Origination(),
            TitlePlayerAccount(nullptr)
            {}

        FUserTitleInfo(const FUserTitleInfo& src) :
            FPlayFabBaseModel(),
            AvatarUrl(src.AvatarUrl),
            Created(src.Created),
            DisplayName(src.DisplayName),
            FirstLogin(src.FirstLogin),
            isBanned(src.isBanned),
            LastLogin(src.LastLogin),
            Origination(src.Origination),
            TitlePlayerAccount(src.TitlePlayerAccount.IsValid() ? MakeShareable(new FEntityKey(*src.TitlePlayerAccount)) : nullptr)
            {}

        FUserTitleInfo(const TSharedPtr<FJsonObject>& obj) : FUserTitleInfo()
        {
            readFromValue(obj);
        }

        ~FUserTitleInfo();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUserTwitchInfo : public FPlayFabBaseModel
    {
        // [optional] Twitch ID
        FString TwitchId;

        // [optional] Twitch Username
        FString TwitchUserName;

        FUserTwitchInfo() :
            FPlayFabBaseModel(),
            TwitchId(),
            TwitchUserName()
            {}

        FUserTwitchInfo(const FUserTwitchInfo& src) :
            FPlayFabBaseModel(),
            TwitchId(src.TwitchId),
            TwitchUserName(src.TwitchUserName)
            {}

        FUserTwitchInfo(const TSharedPtr<FJsonObject>& obj) : FUserTwitchInfo()
        {
            readFromValue(obj);
        }

        ~FUserTwitchInfo();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUserXboxInfo : public FPlayFabBaseModel
    {
        // [optional] XBox user ID
        FString XboxUserId;

        FUserXboxInfo() :
            FPlayFabBaseModel(),
            XboxUserId()
            {}

        FUserXboxInfo(const FUserXboxInfo& src) :
            FPlayFabBaseModel(),
            XboxUserId(src.XboxUserId)
            {}

        FUserXboxInfo(const TSharedPtr<FJsonObject>& obj) : FUserXboxInfo()
        {
            readFromValue(obj);
        }

        ~FUserXboxInfo();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUserAccountInfo : public FPlayFabBaseModel
    {
        // [optional] User Android device information, if an Android device has been linked
        TSharedPtr<FUserAndroidDeviceInfo> AndroidDeviceInfo;

        // Timestamp indicating when the user account was created
        FDateTime Created;

        // [optional] Custom ID information, if a custom ID has been assigned
        TSharedPtr<FUserCustomIdInfo> CustomIdInfo;

        // [optional] User Facebook information, if a Facebook account has been linked
        TSharedPtr<FUserFacebookInfo> FacebookInfo;

        // [optional] User Gamecenter information, if a Gamecenter account has been linked
        TSharedPtr<FUserGameCenterInfo> GameCenterInfo;

        // [optional] User Google account information, if a Google account has been linked
        TSharedPtr<FUserGoogleInfo> GoogleInfo;

        // [optional] User iOS device information, if an iOS device has been linked
        TSharedPtr<FUserIosDeviceInfo> IosDeviceInfo;

        // [optional] User Kongregate account information, if a Kongregate account has been linked
        TSharedPtr<FUserKongregateInfo> KongregateInfo;

        // [optional] Unique identifier for the user account
        FString PlayFabId;

        // [optional] Personal information for the user which is considered more sensitive
        TSharedPtr<FUserPrivateAccountInfo> PrivateInfo;

        // [optional] User PSN account information, if a PSN account has been linked
        TSharedPtr<FUserPsnInfo> PsnInfo;

        // [optional] User Steam information, if a Steam account has been linked
        TSharedPtr<FUserSteamInfo> SteamInfo;

        // [optional] Title-specific information for the user account
        TSharedPtr<FUserTitleInfo> TitleInfo;

        // [optional] User Twitch account information, if a Twitch account has been linked
        TSharedPtr<FUserTwitchInfo> TwitchInfo;

        // [optional] User account name in the PlayFab service
        FString Username;

        // [optional] User XBox account information, if a XBox account has been linked
        TSharedPtr<FUserXboxInfo> XboxInfo;

        FUserAccountInfo() :
            FPlayFabBaseModel(),
            AndroidDeviceInfo(nullptr),
            Created(0),
            CustomIdInfo(nullptr),
            FacebookInfo(nullptr),
            GameCenterInfo(nullptr),
            GoogleInfo(nullptr),
            IosDeviceInfo(nullptr),
            KongregateInfo(nullptr),
            PlayFabId(),
            PrivateInfo(nullptr),
            PsnInfo(nullptr),
            SteamInfo(nullptr),
            TitleInfo(nullptr),
            TwitchInfo(nullptr),
            Username(),
            XboxInfo(nullptr)
            {}

        FUserAccountInfo(const FUserAccountInfo& src) :
            FPlayFabBaseModel(),
            AndroidDeviceInfo(src.AndroidDeviceInfo.IsValid() ? MakeShareable(new FUserAndroidDeviceInfo(*src.AndroidDeviceInfo)) : nullptr),
            Created(src.Created),
            CustomIdInfo(src.CustomIdInfo.IsValid() ? MakeShareable(new FUserCustomIdInfo(*src.CustomIdInfo)) : nullptr),
            FacebookInfo(src.FacebookInfo.IsValid() ? MakeShareable(new FUserFacebookInfo(*src.FacebookInfo)) : nullptr),
            GameCenterInfo(src.GameCenterInfo.IsValid() ? MakeShareable(new FUserGameCenterInfo(*src.GameCenterInfo)) : nullptr),
            GoogleInfo(src.GoogleInfo.IsValid() ? MakeShareable(new FUserGoogleInfo(*src.GoogleInfo)) : nullptr),
            IosDeviceInfo(src.IosDeviceInfo.IsValid() ? MakeShareable(new FUserIosDeviceInfo(*src.IosDeviceInfo)) : nullptr),
            KongregateInfo(src.KongregateInfo.IsValid() ? MakeShareable(new FUserKongregateInfo(*src.KongregateInfo)) : nullptr),
            PlayFabId(src.PlayFabId),
            PrivateInfo(src.PrivateInfo.IsValid() ? MakeShareable(new FUserPrivateAccountInfo(*src.PrivateInfo)) : nullptr),
            PsnInfo(src.PsnInfo.IsValid() ? MakeShareable(new FUserPsnInfo(*src.PsnInfo)) : nullptr),
            SteamInfo(src.SteamInfo.IsValid() ? MakeShareable(new FUserSteamInfo(*src.SteamInfo)) : nullptr),
            TitleInfo(src.TitleInfo.IsValid() ? MakeShareable(new FUserTitleInfo(*src.TitleInfo)) : nullptr),
            TwitchInfo(src.TwitchInfo.IsValid() ? MakeShareable(new FUserTwitchInfo(*src.TwitchInfo)) : nullptr),
            Username(src.Username),
            XboxInfo(src.XboxInfo.IsValid() ? MakeShareable(new FUserXboxInfo(*src.XboxInfo)) : nullptr)
            {}

        FUserAccountInfo(const TSharedPtr<FJsonObject>& obj) : FUserAccountInfo()
        {
            readFromValue(obj);
        }

        ~FUserAccountInfo();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FLookupUserAccountInfoResult : public FPlayFabBaseModel
    {
        // [optional] User info for the user matching the request
        TSharedPtr<FUserAccountInfo> UserInfo;

        FLookupUserAccountInfoResult() :
            FPlayFabBaseModel(),
            UserInfo(nullptr)
            {}

        FLookupUserAccountInfoResult(const FLookupUserAccountInfoResult& src) :
            FPlayFabBaseModel(),
            UserInfo(src.UserInfo.IsValid() ? MakeShareable(new FUserAccountInfo(*src.UserInfo)) : nullptr)
            {}

        FLookupUserAccountInfoResult(const TSharedPtr<FJsonObject>& obj) : FLookupUserAccountInfoResult()
        {
            readFromValue(obj);
        }

        ~FLookupUserAccountInfoResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FModifyMatchmakerGameModesRequest : public FPlayFabBaseModel
    {
        // previously uploaded build version for which game modes are being specified
        FString BuildVersion;

        // array of game modes (Note: this will replace all game modes for the indicated build version)
        TArray<FGameModeInfo> GameModes;
        FModifyMatchmakerGameModesRequest() :
            FPlayFabBaseModel(),
            BuildVersion(),
            GameModes()
            {}

        FModifyMatchmakerGameModesRequest(const FModifyMatchmakerGameModesRequest& src) :
            FPlayFabBaseModel(),
            BuildVersion(src.BuildVersion),
            GameModes(src.GameModes)
            {}

        FModifyMatchmakerGameModesRequest(const TSharedPtr<FJsonObject>& obj) : FModifyMatchmakerGameModesRequest()
        {
            readFromValue(obj);
        }

        ~FModifyMatchmakerGameModesRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FModifyMatchmakerGameModesResult : public FPlayFabBaseModel
    {
        FModifyMatchmakerGameModesResult() :
            FPlayFabBaseModel()
            {}

        FModifyMatchmakerGameModesResult(const FModifyMatchmakerGameModesResult& src) :
            FPlayFabBaseModel()
            {}

        FModifyMatchmakerGameModesResult(const TSharedPtr<FJsonObject>& obj) : FModifyMatchmakerGameModesResult()
        {
            readFromValue(obj);
        }

        ~FModifyMatchmakerGameModesResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FModifyServerBuildRequest : public FPlayFabBaseModel
    {
        // [optional] array of regions where this build can used, when it is active
        TArray<Region> ActiveRegions;
        // unique identifier of the previously uploaded build executable to be updated
        FString BuildId;

        // [optional] appended to the end of the command line when starting game servers
        FString CommandLineTemplate;

        // [optional] developer comment(s) for this build
        FString Comment;

        // [optional] path to the game server executable. Defaults to gameserver.exe
        FString ExecutablePath;

        // maximum number of game server instances that can run on a single host machine
        int32 MaxGamesPerHost;

        /**
         * minimum capacity of additional game server instances that can be started before the autoscaling service starts new host
         * machines (given the number of current running host machines and game server instances)
         */
        int32 MinFreeGameSlots;

        // [optional] new timestamp
        Boxed<FDateTime> Timestamp;

        FModifyServerBuildRequest() :
            FPlayFabBaseModel(),
            ActiveRegions(),
            BuildId(),
            CommandLineTemplate(),
            Comment(),
            ExecutablePath(),
            MaxGamesPerHost(0),
            MinFreeGameSlots(0),
            Timestamp()
            {}

        FModifyServerBuildRequest(const FModifyServerBuildRequest& src) :
            FPlayFabBaseModel(),
            ActiveRegions(src.ActiveRegions),
            BuildId(src.BuildId),
            CommandLineTemplate(src.CommandLineTemplate),
            Comment(src.Comment),
            ExecutablePath(src.ExecutablePath),
            MaxGamesPerHost(src.MaxGamesPerHost),
            MinFreeGameSlots(src.MinFreeGameSlots),
            Timestamp(src.Timestamp)
            {}

        FModifyServerBuildRequest(const TSharedPtr<FJsonObject>& obj) : FModifyServerBuildRequest()
        {
            readFromValue(obj);
        }

        ~FModifyServerBuildRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FModifyServerBuildResult : public FPlayFabBaseModel
    {
        // [optional] array of regions where this build can used, when it is active
        TArray<Region> ActiveRegions;
        // [optional] unique identifier for this build executable
        FString BuildId;

        // [optional] appended to the end of the command line when starting game servers
        FString CommandLineTemplate;

        // [optional] developer comment(s) for this build
        FString Comment;

        // [optional] path to the game server executable. Defaults to gameserver.exe
        FString ExecutablePath;

        // maximum number of game server instances that can run on a single host machine
        int32 MaxGamesPerHost;

        /**
         * minimum capacity of additional game server instances that can be started before the autoscaling service starts new host
         * machines (given the number of current running host machines and game server instances)
         */
        int32 MinFreeGameSlots;

        // [optional] the current status of the build validation and processing steps
        Boxed<GameBuildStatus> Status;

        // time this build was last modified (or uploaded, if this build has never been modified)
        FDateTime Timestamp;

        /**
         * [optional] Unique identifier for the title, found in the Settings > Game Properties section of the PlayFab developer site when a
         * title has been selected.
         */
        FString TitleId;

        FModifyServerBuildResult() :
            FPlayFabBaseModel(),
            ActiveRegions(),
            BuildId(),
            CommandLineTemplate(),
            Comment(),
            ExecutablePath(),
            MaxGamesPerHost(0),
            MinFreeGameSlots(0),
            Status(),
            Timestamp(0),
            TitleId()
            {}

        FModifyServerBuildResult(const FModifyServerBuildResult& src) :
            FPlayFabBaseModel(),
            ActiveRegions(src.ActiveRegions),
            BuildId(src.BuildId),
            CommandLineTemplate(src.CommandLineTemplate),
            Comment(src.Comment),
            ExecutablePath(src.ExecutablePath),
            MaxGamesPerHost(src.MaxGamesPerHost),
            MinFreeGameSlots(src.MinFreeGameSlots),
            Status(src.Status),
            Timestamp(src.Timestamp),
            TitleId(src.TitleId)
            {}

        FModifyServerBuildResult(const TSharedPtr<FJsonObject>& obj) : FModifyServerBuildResult()
        {
            readFromValue(obj);
        }

        ~FModifyServerBuildResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FModifyUserVirtualCurrencyResult : public FPlayFabBaseModel
    {
        // Balance of the virtual currency after modification.
        int32 Balance;

        /**
         * Amount added or subtracted from the user's virtual currency. Maximum VC balance is Int32 (2,147,483,647). Any increase
         * over this value will be discarded.
         */
        int32 BalanceChange;

        // [optional] User currency was subtracted from.
        FString PlayFabId;

        // [optional] Name of the virtual currency which was modified.
        FString VirtualCurrency;

        FModifyUserVirtualCurrencyResult() :
            FPlayFabBaseModel(),
            Balance(0),
            BalanceChange(0),
            PlayFabId(),
            VirtualCurrency()
            {}

        FModifyUserVirtualCurrencyResult(const FModifyUserVirtualCurrencyResult& src) :
            FPlayFabBaseModel(),
            Balance(src.Balance),
            BalanceChange(src.BalanceChange),
            PlayFabId(src.PlayFabId),
            VirtualCurrency(src.VirtualCurrency)
            {}

        FModifyUserVirtualCurrencyResult(const TSharedPtr<FJsonObject>& obj) : FModifyUserVirtualCurrencyResult()
        {
            readFromValue(obj);
        }

        ~FModifyUserVirtualCurrencyResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    enum PushSetupPlatform
    {
        PushSetupPlatformGCM,
        PushSetupPlatformAPNS,
        PushSetupPlatformAPNS_SANDBOX
    };

    PLAYFAB_API void writePushSetupPlatformEnumJSON(PushSetupPlatform enumVal, JsonWriter& writer);
    PLAYFAB_API PushSetupPlatform readPushSetupPlatformFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFAB_API PushSetupPlatform readPushSetupPlatformFromValue(const FString& value);

    struct PLAYFAB_API FRandomResultTable : public FPlayFabBaseModel
    {
        // Child nodes that indicate what kind of drop table item this actually is.
        TArray<FResultTableNode> Nodes;
        // Unique name for this drop table
        FString TableId;

        FRandomResultTable() :
            FPlayFabBaseModel(),
            Nodes(),
            TableId()
            {}

        FRandomResultTable(const FRandomResultTable& src) :
            FPlayFabBaseModel(),
            Nodes(src.Nodes),
            TableId(src.TableId)
            {}

        FRandomResultTable(const TSharedPtr<FJsonObject>& obj) : FRandomResultTable()
        {
            readFromValue(obj);
        }

        ~FRandomResultTable();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FRefundPurchaseRequest : public FPlayFabBaseModel
    {
        // Unique order ID for the purchase in question.
        FString OrderId;

        // Unique PlayFab assigned ID of the user on whom the operation will be performed.
        FString PlayFabId;

        /**
         * [optional] Reason for refund. In the case of Facebook this must match one of their refund or dispute resolution enums (See:
         * https://developers.facebook.com/docs/payments/implementation-guide/handling-disputes-refunds)
         */
        FString Reason;

        FRefundPurchaseRequest() :
            FPlayFabBaseModel(),
            OrderId(),
            PlayFabId(),
            Reason()
            {}

        FRefundPurchaseRequest(const FRefundPurchaseRequest& src) :
            FPlayFabBaseModel(),
            OrderId(src.OrderId),
            PlayFabId(src.PlayFabId),
            Reason(src.Reason)
            {}

        FRefundPurchaseRequest(const TSharedPtr<FJsonObject>& obj) : FRefundPurchaseRequest()
        {
            readFromValue(obj);
        }

        ~FRefundPurchaseRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FRefundPurchaseResponse : public FPlayFabBaseModel
    {
        // [optional] The order's updated purchase status.
        FString PurchaseStatus;

        FRefundPurchaseResponse() :
            FPlayFabBaseModel(),
            PurchaseStatus()
            {}

        FRefundPurchaseResponse(const FRefundPurchaseResponse& src) :
            FPlayFabBaseModel(),
            PurchaseStatus(src.PurchaseStatus)
            {}

        FRefundPurchaseResponse(const TSharedPtr<FJsonObject>& obj) : FRefundPurchaseResponse()
        {
            readFromValue(obj);
        }

        ~FRefundPurchaseResponse();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FRemovePlayerTagRequest : public FPlayFabBaseModel
    {
        // Unique PlayFab assigned ID of the user on whom the operation will be performed.
        FString PlayFabId;

        // Unique tag for player profile.
        FString TagName;

        FRemovePlayerTagRequest() :
            FPlayFabBaseModel(),
            PlayFabId(),
            TagName()
            {}

        FRemovePlayerTagRequest(const FRemovePlayerTagRequest& src) :
            FPlayFabBaseModel(),
            PlayFabId(src.PlayFabId),
            TagName(src.TagName)
            {}

        FRemovePlayerTagRequest(const TSharedPtr<FJsonObject>& obj) : FRemovePlayerTagRequest()
        {
            readFromValue(obj);
        }

        ~FRemovePlayerTagRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FRemovePlayerTagResult : public FPlayFabBaseModel
    {
        FRemovePlayerTagResult() :
            FPlayFabBaseModel()
            {}

        FRemovePlayerTagResult(const FRemovePlayerTagResult& src) :
            FPlayFabBaseModel()
            {}

        FRemovePlayerTagResult(const TSharedPtr<FJsonObject>& obj) : FRemovePlayerTagResult()
        {
            readFromValue(obj);
        }

        ~FRemovePlayerTagResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FRemoveServerBuildRequest : public FPlayFabBaseModel
    {
        // unique identifier of the previously uploaded build executable to be removed
        FString BuildId;

        FRemoveServerBuildRequest() :
            FPlayFabBaseModel(),
            BuildId()
            {}

        FRemoveServerBuildRequest(const FRemoveServerBuildRequest& src) :
            FPlayFabBaseModel(),
            BuildId(src.BuildId)
            {}

        FRemoveServerBuildRequest(const TSharedPtr<FJsonObject>& obj) : FRemoveServerBuildRequest()
        {
            readFromValue(obj);
        }

        ~FRemoveServerBuildRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FRemoveServerBuildResult : public FPlayFabBaseModel
    {
        FRemoveServerBuildResult() :
            FPlayFabBaseModel()
            {}

        FRemoveServerBuildResult(const FRemoveServerBuildResult& src) :
            FPlayFabBaseModel()
            {}

        FRemoveServerBuildResult(const TSharedPtr<FJsonObject>& obj) : FRemoveServerBuildResult()
        {
            readFromValue(obj);
        }

        ~FRemoveServerBuildResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FRemoveVirtualCurrencyTypesRequest : public FPlayFabBaseModel
    {
        // List of virtual currencies to delete
        TArray<FVirtualCurrencyData> VirtualCurrencies;
        FRemoveVirtualCurrencyTypesRequest() :
            FPlayFabBaseModel(),
            VirtualCurrencies()
            {}

        FRemoveVirtualCurrencyTypesRequest(const FRemoveVirtualCurrencyTypesRequest& src) :
            FPlayFabBaseModel(),
            VirtualCurrencies(src.VirtualCurrencies)
            {}

        FRemoveVirtualCurrencyTypesRequest(const TSharedPtr<FJsonObject>& obj) : FRemoveVirtualCurrencyTypesRequest()
        {
            readFromValue(obj);
        }

        ~FRemoveVirtualCurrencyTypesRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FResetCharacterStatisticsRequest : public FPlayFabBaseModel
    {
        // Unique PlayFab assigned ID for a specific character owned by a user
        FString CharacterId;

        // Unique PlayFab assigned ID of the user on whom the operation will be performed.
        FString PlayFabId;

        FResetCharacterStatisticsRequest() :
            FPlayFabBaseModel(),
            CharacterId(),
            PlayFabId()
            {}

        FResetCharacterStatisticsRequest(const FResetCharacterStatisticsRequest& src) :
            FPlayFabBaseModel(),
            CharacterId(src.CharacterId),
            PlayFabId(src.PlayFabId)
            {}

        FResetCharacterStatisticsRequest(const TSharedPtr<FJsonObject>& obj) : FResetCharacterStatisticsRequest()
        {
            readFromValue(obj);
        }

        ~FResetCharacterStatisticsRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FResetCharacterStatisticsResult : public FPlayFabBaseModel
    {
        FResetCharacterStatisticsResult() :
            FPlayFabBaseModel()
            {}

        FResetCharacterStatisticsResult(const FResetCharacterStatisticsResult& src) :
            FPlayFabBaseModel()
            {}

        FResetCharacterStatisticsResult(const TSharedPtr<FJsonObject>& obj) : FResetCharacterStatisticsResult()
        {
            readFromValue(obj);
        }

        ~FResetCharacterStatisticsResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FResetPasswordRequest : public FPlayFabBaseModel
    {
        // The new password for the player.
        FString Password;

        // The token of the player requesting the password reset.
        FString Token;

        FResetPasswordRequest() :
            FPlayFabBaseModel(),
            Password(),
            Token()
            {}

        FResetPasswordRequest(const FResetPasswordRequest& src) :
            FPlayFabBaseModel(),
            Password(src.Password),
            Token(src.Token)
            {}

        FResetPasswordRequest(const TSharedPtr<FJsonObject>& obj) : FResetPasswordRequest()
        {
            readFromValue(obj);
        }

        ~FResetPasswordRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FResetPasswordResult : public FPlayFabBaseModel
    {
        FResetPasswordResult() :
            FPlayFabBaseModel()
            {}

        FResetPasswordResult(const FResetPasswordResult& src) :
            FPlayFabBaseModel()
            {}

        FResetPasswordResult(const TSharedPtr<FJsonObject>& obj) : FResetPasswordResult()
        {
            readFromValue(obj);
        }

        ~FResetPasswordResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FResetUserStatisticsRequest : public FPlayFabBaseModel
    {
        // Unique PlayFab assigned ID of the user on whom the operation will be performed.
        FString PlayFabId;

        FResetUserStatisticsRequest() :
            FPlayFabBaseModel(),
            PlayFabId()
            {}

        FResetUserStatisticsRequest(const FResetUserStatisticsRequest& src) :
            FPlayFabBaseModel(),
            PlayFabId(src.PlayFabId)
            {}

        FResetUserStatisticsRequest(const TSharedPtr<FJsonObject>& obj) : FResetUserStatisticsRequest()
        {
            readFromValue(obj);
        }

        ~FResetUserStatisticsRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FResetUserStatisticsResult : public FPlayFabBaseModel
    {
        FResetUserStatisticsResult() :
            FPlayFabBaseModel()
            {}

        FResetUserStatisticsResult(const FResetUserStatisticsResult& src) :
            FPlayFabBaseModel()
            {}

        FResetUserStatisticsResult(const TSharedPtr<FJsonObject>& obj) : FResetUserStatisticsResult()
        {
            readFromValue(obj);
        }

        ~FResetUserStatisticsResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    enum ResolutionOutcome
    {
        ResolutionOutcomeRevoke,
        ResolutionOutcomeReinstate,
        ResolutionOutcomeManual
    };

    PLAYFAB_API void writeResolutionOutcomeEnumJSON(ResolutionOutcome enumVal, JsonWriter& writer);
    PLAYFAB_API ResolutionOutcome readResolutionOutcomeFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFAB_API ResolutionOutcome readResolutionOutcomeFromValue(const FString& value);

    struct PLAYFAB_API FResolvePurchaseDisputeRequest : public FPlayFabBaseModel
    {
        // Unique order ID for the purchase in question.
        FString OrderId;

        /**
         * Enum for the desired purchase result state after notifying the payment provider. Valid values are Revoke, Reinstate and
         * Manual. Manual will cause no change to the order state.
         */
        ResolutionOutcome Outcome;

        // Unique PlayFab assigned ID of the user on whom the operation will be performed.
        FString PlayFabId;

        /**
         * [optional] Reason for refund. In the case of Facebook this must match one of their refund or dispute resolution enums (See:
         * https://developers.facebook.com/docs/payments/implementation-guide/handling-disputes-refunds)
         */
        FString Reason;

        FResolvePurchaseDisputeRequest() :
            FPlayFabBaseModel(),
            OrderId(),
            Outcome(),
            PlayFabId(),
            Reason()
            {}

        FResolvePurchaseDisputeRequest(const FResolvePurchaseDisputeRequest& src) :
            FPlayFabBaseModel(),
            OrderId(src.OrderId),
            Outcome(src.Outcome),
            PlayFabId(src.PlayFabId),
            Reason(src.Reason)
            {}

        FResolvePurchaseDisputeRequest(const TSharedPtr<FJsonObject>& obj) : FResolvePurchaseDisputeRequest()
        {
            readFromValue(obj);
        }

        ~FResolvePurchaseDisputeRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FResolvePurchaseDisputeResponse : public FPlayFabBaseModel
    {
        // [optional] The order's updated purchase status.
        FString PurchaseStatus;

        FResolvePurchaseDisputeResponse() :
            FPlayFabBaseModel(),
            PurchaseStatus()
            {}

        FResolvePurchaseDisputeResponse(const FResolvePurchaseDisputeResponse& src) :
            FPlayFabBaseModel(),
            PurchaseStatus(src.PurchaseStatus)
            {}

        FResolvePurchaseDisputeResponse(const TSharedPtr<FJsonObject>& obj) : FResolvePurchaseDisputeResponse()
        {
            readFromValue(obj);
        }

        ~FResolvePurchaseDisputeResponse();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FRevokeAllBansForUserRequest : public FPlayFabBaseModel
    {
        // Unique PlayFab assigned ID of the user on whom the operation will be performed.
        FString PlayFabId;

        FRevokeAllBansForUserRequest() :
            FPlayFabBaseModel(),
            PlayFabId()
            {}

        FRevokeAllBansForUserRequest(const FRevokeAllBansForUserRequest& src) :
            FPlayFabBaseModel(),
            PlayFabId(src.PlayFabId)
            {}

        FRevokeAllBansForUserRequest(const TSharedPtr<FJsonObject>& obj) : FRevokeAllBansForUserRequest()
        {
            readFromValue(obj);
        }

        ~FRevokeAllBansForUserRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FRevokeAllBansForUserResult : public FPlayFabBaseModel
    {
        // [optional] Information on the bans that were revoked.
        TArray<FBanInfo> BanData;
        FRevokeAllBansForUserResult() :
            FPlayFabBaseModel(),
            BanData()
            {}

        FRevokeAllBansForUserResult(const FRevokeAllBansForUserResult& src) :
            FPlayFabBaseModel(),
            BanData(src.BanData)
            {}

        FRevokeAllBansForUserResult(const TSharedPtr<FJsonObject>& obj) : FRevokeAllBansForUserResult()
        {
            readFromValue(obj);
        }

        ~FRevokeAllBansForUserResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FRevokeBansRequest : public FPlayFabBaseModel
    {
        // Ids of the bans to be revoked. Maximum 100.
        TArray<FString> BanIds;
        FRevokeBansRequest() :
            FPlayFabBaseModel(),
            BanIds()
            {}

        FRevokeBansRequest(const FRevokeBansRequest& src) :
            FPlayFabBaseModel(),
            BanIds(src.BanIds)
            {}

        FRevokeBansRequest(const TSharedPtr<FJsonObject>& obj) : FRevokeBansRequest()
        {
            readFromValue(obj);
        }

        ~FRevokeBansRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FRevokeBansResult : public FPlayFabBaseModel
    {
        // [optional] Information on the bans that were revoked
        TArray<FBanInfo> BanData;
        FRevokeBansResult() :
            FPlayFabBaseModel(),
            BanData()
            {}

        FRevokeBansResult(const FRevokeBansResult& src) :
            FPlayFabBaseModel(),
            BanData(src.BanData)
            {}

        FRevokeBansResult(const TSharedPtr<FJsonObject>& obj) : FRevokeBansResult()
        {
            readFromValue(obj);
        }

        ~FRevokeBansResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FRevokeInventoryItem : public FPlayFabBaseModel
    {
        // [optional] Unique PlayFab assigned ID for a specific character owned by a user
        FString CharacterId;

        // Unique PlayFab assigned instance identifier of the item
        FString ItemInstanceId;

        // Unique PlayFab assigned ID of the user on whom the operation will be performed.
        FString PlayFabId;

        FRevokeInventoryItem() :
            FPlayFabBaseModel(),
            CharacterId(),
            ItemInstanceId(),
            PlayFabId()
            {}

        FRevokeInventoryItem(const FRevokeInventoryItem& src) :
            FPlayFabBaseModel(),
            CharacterId(src.CharacterId),
            ItemInstanceId(src.ItemInstanceId),
            PlayFabId(src.PlayFabId)
            {}

        FRevokeInventoryItem(const TSharedPtr<FJsonObject>& obj) : FRevokeInventoryItem()
        {
            readFromValue(obj);
        }

        ~FRevokeInventoryItem();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FRevokeInventoryItemRequest : public FPlayFabBaseModel
    {
        // [optional] Unique PlayFab assigned ID for a specific character owned by a user
        FString CharacterId;

        // Unique PlayFab assigned instance identifier of the item
        FString ItemInstanceId;

        // Unique PlayFab assigned ID of the user on whom the operation will be performed.
        FString PlayFabId;

        FRevokeInventoryItemRequest() :
            FPlayFabBaseModel(),
            CharacterId(),
            ItemInstanceId(),
            PlayFabId()
            {}

        FRevokeInventoryItemRequest(const FRevokeInventoryItemRequest& src) :
            FPlayFabBaseModel(),
            CharacterId(src.CharacterId),
            ItemInstanceId(src.ItemInstanceId),
            PlayFabId(src.PlayFabId)
            {}

        FRevokeInventoryItemRequest(const TSharedPtr<FJsonObject>& obj) : FRevokeInventoryItemRequest()
        {
            readFromValue(obj);
        }

        ~FRevokeInventoryItemRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FRevokeInventoryItemsRequest : public FPlayFabBaseModel
    {
        // Array of player items to revoke, between 1 and 25 items.
        TArray<FRevokeInventoryItem> Items;
        FRevokeInventoryItemsRequest() :
            FPlayFabBaseModel(),
            Items()
            {}

        FRevokeInventoryItemsRequest(const FRevokeInventoryItemsRequest& src) :
            FPlayFabBaseModel(),
            Items(src.Items)
            {}

        FRevokeInventoryItemsRequest(const TSharedPtr<FJsonObject>& obj) : FRevokeInventoryItemsRequest()
        {
            readFromValue(obj);
        }

        ~FRevokeInventoryItemsRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FRevokeItemError : public FPlayFabBaseModel
    {
        // [optional] Specific error that was encountered.
        FString Error;

        // [optional] Item information that failed to be revoked.
        TSharedPtr<FRevokeInventoryItem> Item;

        FRevokeItemError() :
            FPlayFabBaseModel(),
            Error(),
            Item(nullptr)
            {}

        FRevokeItemError(const FRevokeItemError& src) :
            FPlayFabBaseModel(),
            Error(src.Error),
            Item(src.Item.IsValid() ? MakeShareable(new FRevokeInventoryItem(*src.Item)) : nullptr)
            {}

        FRevokeItemError(const TSharedPtr<FJsonObject>& obj) : FRevokeItemError()
        {
            readFromValue(obj);
        }

        ~FRevokeItemError();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FRevokeInventoryItemsResult : public FPlayFabBaseModel
    {
        // [optional] Collection of any errors that occurred during processing.
        TArray<FRevokeItemError> Errors;
        FRevokeInventoryItemsResult() :
            FPlayFabBaseModel(),
            Errors()
            {}

        FRevokeInventoryItemsResult(const FRevokeInventoryItemsResult& src) :
            FPlayFabBaseModel(),
            Errors(src.Errors)
            {}

        FRevokeInventoryItemsResult(const TSharedPtr<FJsonObject>& obj) : FRevokeInventoryItemsResult()
        {
            readFromValue(obj);
        }

        ~FRevokeInventoryItemsResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FRevokeInventoryResult : public FPlayFabBaseModel
    {
        FRevokeInventoryResult() :
            FPlayFabBaseModel()
            {}

        FRevokeInventoryResult(const FRevokeInventoryResult& src) :
            FPlayFabBaseModel()
            {}

        FRevokeInventoryResult(const TSharedPtr<FJsonObject>& obj) : FRevokeInventoryResult()
        {
            readFromValue(obj);
        }

        ~FRevokeInventoryResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FRunTaskRequest : public FPlayFabBaseModel
    {
        // [optional] Provide either the task ID or the task name to run a task.
        TSharedPtr<FNameIdentifier> Identifier;

        FRunTaskRequest() :
            FPlayFabBaseModel(),
            Identifier(nullptr)
            {}

        FRunTaskRequest(const FRunTaskRequest& src) :
            FPlayFabBaseModel(),
            Identifier(src.Identifier.IsValid() ? MakeShareable(new FNameIdentifier(*src.Identifier)) : nullptr)
            {}

        FRunTaskRequest(const TSharedPtr<FJsonObject>& obj) : FRunTaskRequest()
        {
            readFromValue(obj);
        }

        ~FRunTaskRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FRunTaskResult : public FPlayFabBaseModel
    {
        /**
         * [optional] ID of the task instance that is started. This can be used in Get*TaskInstance (e.g. GetCloudScriptTaskInstance) API call
         * to retrieve status for the task instance.
         */
        FString TaskInstanceId;

        FRunTaskResult() :
            FPlayFabBaseModel(),
            TaskInstanceId()
            {}

        FRunTaskResult(const FRunTaskResult& src) :
            FPlayFabBaseModel(),
            TaskInstanceId(src.TaskInstanceId)
            {}

        FRunTaskResult(const TSharedPtr<FJsonObject>& obj) : FRunTaskResult()
        {
            readFromValue(obj);
        }

        ~FRunTaskResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FSendAccountRecoveryEmailRequest : public FPlayFabBaseModel
    {
        // User email address attached to their account
        FString Email;

        // [optional] The email template id of the account recovery email template to send.
        FString EmailTemplateId;

        FSendAccountRecoveryEmailRequest() :
            FPlayFabBaseModel(),
            Email(),
            EmailTemplateId()
            {}

        FSendAccountRecoveryEmailRequest(const FSendAccountRecoveryEmailRequest& src) :
            FPlayFabBaseModel(),
            Email(src.Email),
            EmailTemplateId(src.EmailTemplateId)
            {}

        FSendAccountRecoveryEmailRequest(const TSharedPtr<FJsonObject>& obj) : FSendAccountRecoveryEmailRequest()
        {
            readFromValue(obj);
        }

        ~FSendAccountRecoveryEmailRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FSendAccountRecoveryEmailResult : public FPlayFabBaseModel
    {
        FSendAccountRecoveryEmailResult() :
            FPlayFabBaseModel()
            {}

        FSendAccountRecoveryEmailResult(const FSendAccountRecoveryEmailResult& src) :
            FPlayFabBaseModel()
            {}

        FSendAccountRecoveryEmailResult(const TSharedPtr<FJsonObject>& obj) : FSendAccountRecoveryEmailResult()
        {
            readFromValue(obj);
        }

        ~FSendAccountRecoveryEmailResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FSetPlayerSecretRequest : public FPlayFabBaseModel
    {
        // Player secret that is used to verify API request signatures (Enterprise Only).
        FString PlayerSecret;

        // Unique PlayFab assigned ID of the user on whom the operation will be performed.
        FString PlayFabId;

        FSetPlayerSecretRequest() :
            FPlayFabBaseModel(),
            PlayerSecret(),
            PlayFabId()
            {}

        FSetPlayerSecretRequest(const FSetPlayerSecretRequest& src) :
            FPlayFabBaseModel(),
            PlayerSecret(src.PlayerSecret),
            PlayFabId(src.PlayFabId)
            {}

        FSetPlayerSecretRequest(const TSharedPtr<FJsonObject>& obj) : FSetPlayerSecretRequest()
        {
            readFromValue(obj);
        }

        ~FSetPlayerSecretRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FSetPlayerSecretResult : public FPlayFabBaseModel
    {
        FSetPlayerSecretResult() :
            FPlayFabBaseModel()
            {}

        FSetPlayerSecretResult(const FSetPlayerSecretResult& src) :
            FPlayFabBaseModel()
            {}

        FSetPlayerSecretResult(const TSharedPtr<FJsonObject>& obj) : FSetPlayerSecretResult()
        {
            readFromValue(obj);
        }

        ~FSetPlayerSecretResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FSetPublishedRevisionRequest : public FPlayFabBaseModel
    {
        // Revision to make the current published revision
        int32 Revision;

        // Version number
        int32 Version;

        FSetPublishedRevisionRequest() :
            FPlayFabBaseModel(),
            Revision(0),
            Version(0)
            {}

        FSetPublishedRevisionRequest(const FSetPublishedRevisionRequest& src) :
            FPlayFabBaseModel(),
            Revision(src.Revision),
            Version(src.Version)
            {}

        FSetPublishedRevisionRequest(const TSharedPtr<FJsonObject>& obj) : FSetPublishedRevisionRequest()
        {
            readFromValue(obj);
        }

        ~FSetPublishedRevisionRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FSetPublishedRevisionResult : public FPlayFabBaseModel
    {
        FSetPublishedRevisionResult() :
            FPlayFabBaseModel()
            {}

        FSetPublishedRevisionResult(const FSetPublishedRevisionResult& src) :
            FPlayFabBaseModel()
            {}

        FSetPublishedRevisionResult(const TSharedPtr<FJsonObject>& obj) : FSetPublishedRevisionResult()
        {
            readFromValue(obj);
        }

        ~FSetPublishedRevisionResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FSetPublisherDataRequest : public FPlayFabBaseModel
    {
        /**
         * key we want to set a value on (note, this is additive - will only replace an existing key's value if they are the same
         * name.) Keys are trimmed of whitespace. Keys may not begin with the '!' character.
         */
        FString Key;

        // [optional] new value to set. Set to null to remove a value
        FString Value;

        FSetPublisherDataRequest() :
            FPlayFabBaseModel(),
            Key(),
            Value()
            {}

        FSetPublisherDataRequest(const FSetPublisherDataRequest& src) :
            FPlayFabBaseModel(),
            Key(src.Key),
            Value(src.Value)
            {}

        FSetPublisherDataRequest(const TSharedPtr<FJsonObject>& obj) : FSetPublisherDataRequest()
        {
            readFromValue(obj);
        }

        ~FSetPublisherDataRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FSetPublisherDataResult : public FPlayFabBaseModel
    {
        FSetPublisherDataResult() :
            FPlayFabBaseModel()
            {}

        FSetPublisherDataResult(const FSetPublisherDataResult& src) :
            FPlayFabBaseModel()
            {}

        FSetPublisherDataResult(const TSharedPtr<FJsonObject>& obj) : FSetPublisherDataResult()
        {
            readFromValue(obj);
        }

        ~FSetPublisherDataResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FSetTitleDataRequest : public FPlayFabBaseModel
    {
        /**
         * key we want to set a value on (note, this is additive - will only replace an existing key's value if they are the same
         * name.) Keys are trimmed of whitespace. Keys may not begin with the '!' character.
         */
        FString Key;

        // [optional] new value to set. Set to null to remove a value
        FString Value;

        FSetTitleDataRequest() :
            FPlayFabBaseModel(),
            Key(),
            Value()
            {}

        FSetTitleDataRequest(const FSetTitleDataRequest& src) :
            FPlayFabBaseModel(),
            Key(src.Key),
            Value(src.Value)
            {}

        FSetTitleDataRequest(const TSharedPtr<FJsonObject>& obj) : FSetTitleDataRequest()
        {
            readFromValue(obj);
        }

        ~FSetTitleDataRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FSetTitleDataResult : public FPlayFabBaseModel
    {
        FSetTitleDataResult() :
            FPlayFabBaseModel()
            {}

        FSetTitleDataResult(const FSetTitleDataResult& src) :
            FPlayFabBaseModel()
            {}

        FSetTitleDataResult(const TSharedPtr<FJsonObject>& obj) : FSetTitleDataResult()
        {
            readFromValue(obj);
        }

        ~FSetTitleDataResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FSetupPushNotificationRequest : public FPlayFabBaseModel
    {
        // Credential is the Private Key for APNS/APNS_SANDBOX, and the API Key for GCM
        FString Credential;

        // [optional] for APNS, this is the PlatformPrincipal (SSL Certificate)
        FString Key;

        /**
         * name of the application sending the message (application names must be made up of only uppercase and lowercase ASCII
         * letters, numbers, underscores, hyphens, and periods, and must be between 1 and 256 characters long)
         */
        FString Name;

        /**
         * replace any existing ARN with the newly generated one. If this is set to false, an error will be returned if
         * notifications have already setup for this platform.
         */
        bool OverwriteOldARN;

        /**
         * supported notification platforms are Apple Push Notification Service (APNS and APNS_SANDBOX) for iOS and Google Cloud
         * Messaging (GCM) for Android
         */
        PushSetupPlatform Platform;

        FSetupPushNotificationRequest() :
            FPlayFabBaseModel(),
            Credential(),
            Key(),
            Name(),
            OverwriteOldARN(false),
            Platform()
            {}

        FSetupPushNotificationRequest(const FSetupPushNotificationRequest& src) :
            FPlayFabBaseModel(),
            Credential(src.Credential),
            Key(src.Key),
            Name(src.Name),
            OverwriteOldARN(src.OverwriteOldARN),
            Platform(src.Platform)
            {}

        FSetupPushNotificationRequest(const TSharedPtr<FJsonObject>& obj) : FSetupPushNotificationRequest()
        {
            readFromValue(obj);
        }

        ~FSetupPushNotificationRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FSetupPushNotificationResult : public FPlayFabBaseModel
    {
        // [optional] Amazon Resource Name for the created notification topic.
        FString ARN;

        FSetupPushNotificationResult() :
            FPlayFabBaseModel(),
            ARN()
            {}

        FSetupPushNotificationResult(const FSetupPushNotificationResult& src) :
            FPlayFabBaseModel(),
            ARN(src.ARN)
            {}

        FSetupPushNotificationResult(const TSharedPtr<FJsonObject>& obj) : FSetupPushNotificationResult()
        {
            readFromValue(obj);
        }

        ~FSetupPushNotificationResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    enum StatisticVersionArchivalStatus
    {
        StatisticVersionArchivalStatusNotScheduled,
        StatisticVersionArchivalStatusScheduled,
        StatisticVersionArchivalStatusQueued,
        StatisticVersionArchivalStatusInProgress,
        StatisticVersionArchivalStatusComplete
    };

    PLAYFAB_API void writeStatisticVersionArchivalStatusEnumJSON(StatisticVersionArchivalStatus enumVal, JsonWriter& writer);
    PLAYFAB_API StatisticVersionArchivalStatus readStatisticVersionArchivalStatusFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFAB_API StatisticVersionArchivalStatus readStatisticVersionArchivalStatusFromValue(const FString& value);

    struct PLAYFAB_API FSubtractUserVirtualCurrencyRequest : public FPlayFabBaseModel
    {
        // Amount to be subtracted from the user balance of the specified virtual currency.
        int32 Amount;

        // PlayFab unique identifier of the user whose virtual currency balance is to be decreased.
        FString PlayFabId;

        // Name of the virtual currency which is to be decremented.
        FString VirtualCurrency;

        FSubtractUserVirtualCurrencyRequest() :
            FPlayFabBaseModel(),
            Amount(0),
            PlayFabId(),
            VirtualCurrency()
            {}

        FSubtractUserVirtualCurrencyRequest(const FSubtractUserVirtualCurrencyRequest& src) :
            FPlayFabBaseModel(),
            Amount(src.Amount),
            PlayFabId(src.PlayFabId),
            VirtualCurrency(src.VirtualCurrency)
            {}

        FSubtractUserVirtualCurrencyRequest(const TSharedPtr<FJsonObject>& obj) : FSubtractUserVirtualCurrencyRequest()
        {
            readFromValue(obj);
        }

        ~FSubtractUserVirtualCurrencyRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUpdateBanRequest : public FPlayFabBaseModel
    {
        // [optional] The updated active state for the ban. Null for no change.
        Boxed<bool> Active;

        // The id of the ban to be updated.
        FString BanId;

        // [optional] The updated expiration date for the ban. Null for no change.
        Boxed<FDateTime> Expires;

        // [optional] The updated IP address for the ban. Null for no change.
        FString IPAddress;

        // [optional] The updated MAC address for the ban. Null for no change.
        FString MACAddress;

        // [optional] Whether to make this ban permanent. Set to true to make this ban permanent. This will not modify Active state.
        Boxed<bool> Permanent;

        // [optional] The updated reason for the ban to be updated. Maximum 140 characters. Null for no change.
        FString Reason;

        FUpdateBanRequest() :
            FPlayFabBaseModel(),
            Active(),
            BanId(),
            Expires(),
            IPAddress(),
            MACAddress(),
            Permanent(),
            Reason()
            {}

        FUpdateBanRequest(const FUpdateBanRequest& src) :
            FPlayFabBaseModel(),
            Active(src.Active),
            BanId(src.BanId),
            Expires(src.Expires),
            IPAddress(src.IPAddress),
            MACAddress(src.MACAddress),
            Permanent(src.Permanent),
            Reason(src.Reason)
            {}

        FUpdateBanRequest(const TSharedPtr<FJsonObject>& obj) : FUpdateBanRequest()
        {
            readFromValue(obj);
        }

        ~FUpdateBanRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUpdateBansRequest : public FPlayFabBaseModel
    {
        // List of bans to be updated. Maximum 100.
        TArray<FUpdateBanRequest> Bans;
        FUpdateBansRequest() :
            FPlayFabBaseModel(),
            Bans()
            {}

        FUpdateBansRequest(const FUpdateBansRequest& src) :
            FPlayFabBaseModel(),
            Bans(src.Bans)
            {}

        FUpdateBansRequest(const TSharedPtr<FJsonObject>& obj) : FUpdateBansRequest()
        {
            readFromValue(obj);
        }

        ~FUpdateBansRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUpdateBansResult : public FPlayFabBaseModel
    {
        // [optional] Information on the bans that were updated
        TArray<FBanInfo> BanData;
        FUpdateBansResult() :
            FPlayFabBaseModel(),
            BanData()
            {}

        FUpdateBansResult(const FUpdateBansResult& src) :
            FPlayFabBaseModel(),
            BanData(src.BanData)
            {}

        FUpdateBansResult(const TSharedPtr<FJsonObject>& obj) : FUpdateBansResult()
        {
            readFromValue(obj);
        }

        ~FUpdateBansResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUpdateCatalogItemsRequest : public FPlayFabBaseModel
    {
        /**
         * [optional] Array of catalog items to be submitted. Note that while CatalogItem has a parameter for CatalogVersion, it is not
         * required and ignored in this call.
         */
        TArray<FCatalogItem> Catalog;
        // [optional] Which catalog is being updated. If null, uses the default catalog.
        FString CatalogVersion;

        /**
         * [optional] Should this catalog be set as the default catalog. Defaults to true. If there is currently no default catalog, this will
         * always set it.
         */
        Boxed<bool> SetAsDefaultCatalog;

        FUpdateCatalogItemsRequest() :
            FPlayFabBaseModel(),
            Catalog(),
            CatalogVersion(),
            SetAsDefaultCatalog()
            {}

        FUpdateCatalogItemsRequest(const FUpdateCatalogItemsRequest& src) :
            FPlayFabBaseModel(),
            Catalog(src.Catalog),
            CatalogVersion(src.CatalogVersion),
            SetAsDefaultCatalog(src.SetAsDefaultCatalog)
            {}

        FUpdateCatalogItemsRequest(const TSharedPtr<FJsonObject>& obj) : FUpdateCatalogItemsRequest()
        {
            readFromValue(obj);
        }

        ~FUpdateCatalogItemsRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUpdateCatalogItemsResult : public FPlayFabBaseModel
    {
        FUpdateCatalogItemsResult() :
            FPlayFabBaseModel()
            {}

        FUpdateCatalogItemsResult(const FUpdateCatalogItemsResult& src) :
            FPlayFabBaseModel()
            {}

        FUpdateCatalogItemsResult(const TSharedPtr<FJsonObject>& obj) : FUpdateCatalogItemsResult()
        {
            readFromValue(obj);
        }

        ~FUpdateCatalogItemsResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUpdateCloudScriptRequest : public FPlayFabBaseModel
    {
        // [optional] PlayFab user ID of the developer initiating the request.
        FString DeveloperPlayFabId;

        // List of Cloud Script files to upload to create the new revision. Must have at least one file.
        TArray<FCloudScriptFile> Files;
        // Immediately publish the new revision
        bool Publish;

        FUpdateCloudScriptRequest() :
            FPlayFabBaseModel(),
            DeveloperPlayFabId(),
            Files(),
            Publish(false)
            {}

        FUpdateCloudScriptRequest(const FUpdateCloudScriptRequest& src) :
            FPlayFabBaseModel(),
            DeveloperPlayFabId(src.DeveloperPlayFabId),
            Files(src.Files),
            Publish(src.Publish)
            {}

        FUpdateCloudScriptRequest(const TSharedPtr<FJsonObject>& obj) : FUpdateCloudScriptRequest()
        {
            readFromValue(obj);
        }

        ~FUpdateCloudScriptRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUpdateCloudScriptResult : public FPlayFabBaseModel
    {
        // New revision number created
        int32 Revision;

        // Cloud Script version updated
        int32 Version;

        FUpdateCloudScriptResult() :
            FPlayFabBaseModel(),
            Revision(0),
            Version(0)
            {}

        FUpdateCloudScriptResult(const FUpdateCloudScriptResult& src) :
            FPlayFabBaseModel(),
            Revision(src.Revision),
            Version(src.Version)
            {}

        FUpdateCloudScriptResult(const TSharedPtr<FJsonObject>& obj) : FUpdateCloudScriptResult()
        {
            readFromValue(obj);
        }

        ~FUpdateCloudScriptResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUpdatePlayerSharedSecretRequest : public FPlayFabBaseModel
    {
        // Disable or Enable this key
        bool Disabled;

        // [optional] Friendly name for this key
        FString FriendlyName;

        // [optional] The shared secret key to update
        FString SecretKey;

        FUpdatePlayerSharedSecretRequest() :
            FPlayFabBaseModel(),
            Disabled(false),
            FriendlyName(),
            SecretKey()
            {}

        FUpdatePlayerSharedSecretRequest(const FUpdatePlayerSharedSecretRequest& src) :
            FPlayFabBaseModel(),
            Disabled(src.Disabled),
            FriendlyName(src.FriendlyName),
            SecretKey(src.SecretKey)
            {}

        FUpdatePlayerSharedSecretRequest(const TSharedPtr<FJsonObject>& obj) : FUpdatePlayerSharedSecretRequest()
        {
            readFromValue(obj);
        }

        ~FUpdatePlayerSharedSecretRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUpdatePlayerSharedSecretResult : public FPlayFabBaseModel
    {
        FUpdatePlayerSharedSecretResult() :
            FPlayFabBaseModel()
            {}

        FUpdatePlayerSharedSecretResult(const FUpdatePlayerSharedSecretResult& src) :
            FPlayFabBaseModel()
            {}

        FUpdatePlayerSharedSecretResult(const TSharedPtr<FJsonObject>& obj) : FUpdatePlayerSharedSecretResult()
        {
            readFromValue(obj);
        }

        ~FUpdatePlayerSharedSecretResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUpdatePlayerStatisticDefinitionRequest : public FPlayFabBaseModel
    {
        // [optional] the aggregation method to use in updating the statistic (defaults to last)
        Boxed<StatisticAggregationMethod> AggregationMethod;

        // unique name of the statistic
        FString StatisticName;

        /**
         * [optional] interval at which the values of the statistic for all players are reset (changes are effective at the next occurance of
         * the new interval boundary)
         */
        Boxed<StatisticResetIntervalOption> VersionChangeInterval;

        FUpdatePlayerStatisticDefinitionRequest() :
            FPlayFabBaseModel(),
            AggregationMethod(),
            StatisticName(),
            VersionChangeInterval()
            {}

        FUpdatePlayerStatisticDefinitionRequest(const FUpdatePlayerStatisticDefinitionRequest& src) :
            FPlayFabBaseModel(),
            AggregationMethod(src.AggregationMethod),
            StatisticName(src.StatisticName),
            VersionChangeInterval(src.VersionChangeInterval)
            {}

        FUpdatePlayerStatisticDefinitionRequest(const TSharedPtr<FJsonObject>& obj) : FUpdatePlayerStatisticDefinitionRequest()
        {
            readFromValue(obj);
        }

        ~FUpdatePlayerStatisticDefinitionRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUpdatePlayerStatisticDefinitionResult : public FPlayFabBaseModel
    {
        // [optional] updated statistic definition
        TSharedPtr<FPlayerStatisticDefinition> Statistic;

        FUpdatePlayerStatisticDefinitionResult() :
            FPlayFabBaseModel(),
            Statistic(nullptr)
            {}

        FUpdatePlayerStatisticDefinitionResult(const FUpdatePlayerStatisticDefinitionResult& src) :
            FPlayFabBaseModel(),
            Statistic(src.Statistic.IsValid() ? MakeShareable(new FPlayerStatisticDefinition(*src.Statistic)) : nullptr)
            {}

        FUpdatePlayerStatisticDefinitionResult(const TSharedPtr<FJsonObject>& obj) : FUpdatePlayerStatisticDefinitionResult()
        {
            readFromValue(obj);
        }

        ~FUpdatePlayerStatisticDefinitionResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUpdatePolicyRequest : public FPlayFabBaseModel
    {
        // Whether to overwrite or append to the existing policy.
        bool OverwritePolicy;

        // The name of the policy being updated. Only supported name is 'ApiPolicy'
        FString PolicyName;

        // The new statements to include in the policy.
        TArray<FPermissionStatement> Statements;
        FUpdatePolicyRequest() :
            FPlayFabBaseModel(),
            OverwritePolicy(false),
            PolicyName(),
            Statements()
            {}

        FUpdatePolicyRequest(const FUpdatePolicyRequest& src) :
            FPlayFabBaseModel(),
            OverwritePolicy(src.OverwritePolicy),
            PolicyName(src.PolicyName),
            Statements(src.Statements)
            {}

        FUpdatePolicyRequest(const TSharedPtr<FJsonObject>& obj) : FUpdatePolicyRequest()
        {
            readFromValue(obj);
        }

        ~FUpdatePolicyRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUpdatePolicyResponse : public FPlayFabBaseModel
    {
        // [optional] The name of the policy that was updated.
        FString PolicyName;

        // [optional] The statements included in the new version of the policy.
        TArray<FPermissionStatement> Statements;
        FUpdatePolicyResponse() :
            FPlayFabBaseModel(),
            PolicyName(),
            Statements()
            {}

        FUpdatePolicyResponse(const FUpdatePolicyResponse& src) :
            FPlayFabBaseModel(),
            PolicyName(src.PolicyName),
            Statements(src.Statements)
            {}

        FUpdatePolicyResponse(const TSharedPtr<FJsonObject>& obj) : FUpdatePolicyResponse()
        {
            readFromValue(obj);
        }

        ~FUpdatePolicyResponse();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUpdateRandomResultTablesRequest : public FPlayFabBaseModel
    {
        // [optional] which catalog is being updated. If null, update the current default catalog version
        FString CatalogVersion;

        /**
         * [optional] array of random result tables to make available (Note: specifying an existing TableId will result in overwriting that
         * table, while any others will be added to the available set)
         */
        TArray<FRandomResultTable> Tables;
        FUpdateRandomResultTablesRequest() :
            FPlayFabBaseModel(),
            CatalogVersion(),
            Tables()
            {}

        FUpdateRandomResultTablesRequest(const FUpdateRandomResultTablesRequest& src) :
            FPlayFabBaseModel(),
            CatalogVersion(src.CatalogVersion),
            Tables(src.Tables)
            {}

        FUpdateRandomResultTablesRequest(const TSharedPtr<FJsonObject>& obj) : FUpdateRandomResultTablesRequest()
        {
            readFromValue(obj);
        }

        ~FUpdateRandomResultTablesRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUpdateRandomResultTablesResult : public FPlayFabBaseModel
    {
        FUpdateRandomResultTablesResult() :
            FPlayFabBaseModel()
            {}

        FUpdateRandomResultTablesResult(const FUpdateRandomResultTablesResult& src) :
            FPlayFabBaseModel()
            {}

        FUpdateRandomResultTablesResult(const TSharedPtr<FJsonObject>& obj) : FUpdateRandomResultTablesResult()
        {
            readFromValue(obj);
        }

        ~FUpdateRandomResultTablesResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUpdateStoreItemsRequest : public FPlayFabBaseModel
    {
        // [optional] Catalog version of the store to update. If null, uses the default catalog.
        FString CatalogVersion;

        // [optional] Additional data about the store
        TSharedPtr<FStoreMarketingModel> MarketingData;

        // [optional] Array of store items - references to catalog items, with specific pricing - to be added
        TArray<FStoreItem> Store;
        // Unique identifier for the store which is to be updated
        FString StoreId;

        FUpdateStoreItemsRequest() :
            FPlayFabBaseModel(),
            CatalogVersion(),
            MarketingData(nullptr),
            Store(),
            StoreId()
            {}

        FUpdateStoreItemsRequest(const FUpdateStoreItemsRequest& src) :
            FPlayFabBaseModel(),
            CatalogVersion(src.CatalogVersion),
            MarketingData(src.MarketingData.IsValid() ? MakeShareable(new FStoreMarketingModel(*src.MarketingData)) : nullptr),
            Store(src.Store),
            StoreId(src.StoreId)
            {}

        FUpdateStoreItemsRequest(const TSharedPtr<FJsonObject>& obj) : FUpdateStoreItemsRequest()
        {
            readFromValue(obj);
        }

        ~FUpdateStoreItemsRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUpdateStoreItemsResult : public FPlayFabBaseModel
    {
        FUpdateStoreItemsResult() :
            FPlayFabBaseModel()
            {}

        FUpdateStoreItemsResult(const FUpdateStoreItemsResult& src) :
            FPlayFabBaseModel()
            {}

        FUpdateStoreItemsResult(const TSharedPtr<FJsonObject>& obj) : FUpdateStoreItemsResult()
        {
            readFromValue(obj);
        }

        ~FUpdateStoreItemsResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUpdateTaskRequest : public FPlayFabBaseModel
    {
        // [optional] Description the task
        FString Description;

        // [optional] Specify either the task ID or the name of the task to be updated.
        TSharedPtr<FNameIdentifier> Identifier;

        // Whether the schedule is active. Inactive schedule will not trigger task execution.
        bool IsActive;

        // Name of the task. This is a unique identifier for tasks in the title.
        FString Name;

        // [optional] Parameter object specific to the task type. See each task type's create API documentation for details.
        FJsonKeeper Parameter;

        // [optional] Cron expression for the run schedule of the task. The expression should be in UTC.
        FString Schedule;

        // Task type.
        ScheduledTaskType Type;

        FUpdateTaskRequest() :
            FPlayFabBaseModel(),
            Description(),
            Identifier(nullptr),
            IsActive(false),
            Name(),
            Parameter(),
            Schedule(),
            Type()
            {}

        FUpdateTaskRequest(const FUpdateTaskRequest& src) :
            FPlayFabBaseModel(),
            Description(src.Description),
            Identifier(src.Identifier.IsValid() ? MakeShareable(new FNameIdentifier(*src.Identifier)) : nullptr),
            IsActive(src.IsActive),
            Name(src.Name),
            Parameter(src.Parameter),
            Schedule(src.Schedule),
            Type(src.Type)
            {}

        FUpdateTaskRequest(const TSharedPtr<FJsonObject>& obj) : FUpdateTaskRequest()
        {
            readFromValue(obj);
        }

        ~FUpdateTaskRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUpdateUserDataRequest : public FPlayFabBaseModel
    {
        /**
         * [optional] Key-value pairs to be written to the custom data. Note that keys are trimmed of whitespace, are limited in size, and may
         * not begin with a '!' character or be null.
         */
        TMap<FString, FString> Data;
        /**
         * [optional] Optional list of Data-keys to remove from UserData. Some SDKs cannot insert null-values into Data due to language
         * constraints. Use this to delete the keys directly.
         */
        TArray<FString> KeysToRemove;
        // [optional] Permission to be applied to all user data keys written in this request. Defaults to "private" if not set.
        Boxed<UserDataPermission> Permission;

        // Unique PlayFab assigned ID of the user on whom the operation will be performed.
        FString PlayFabId;

        FUpdateUserDataRequest() :
            FPlayFabBaseModel(),
            Data(),
            KeysToRemove(),
            Permission(),
            PlayFabId()
            {}

        FUpdateUserDataRequest(const FUpdateUserDataRequest& src) :
            FPlayFabBaseModel(),
            Data(src.Data),
            KeysToRemove(src.KeysToRemove),
            Permission(src.Permission),
            PlayFabId(src.PlayFabId)
            {}

        FUpdateUserDataRequest(const TSharedPtr<FJsonObject>& obj) : FUpdateUserDataRequest()
        {
            readFromValue(obj);
        }

        ~FUpdateUserDataRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUpdateUserDataResult : public FPlayFabBaseModel
    {
        /**
         * Indicates the current version of the data that has been set. This is incremented with every set call for that type of
         * data (read-only, internal, etc). This version can be provided in Get calls to find updated data.
         */
        uint32 DataVersion;

        FUpdateUserDataResult() :
            FPlayFabBaseModel(),
            DataVersion(0)
            {}

        FUpdateUserDataResult(const FUpdateUserDataResult& src) :
            FPlayFabBaseModel(),
            DataVersion(src.DataVersion)
            {}

        FUpdateUserDataResult(const TSharedPtr<FJsonObject>& obj) : FUpdateUserDataResult()
        {
            readFromValue(obj);
        }

        ~FUpdateUserDataResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUpdateUserInternalDataRequest : public FPlayFabBaseModel
    {
        /**
         * [optional] Key-value pairs to be written to the custom data. Note that keys are trimmed of whitespace, are limited in size, and may
         * not begin with a '!' character or be null.
         */
        TMap<FString, FString> Data;
        /**
         * [optional] Optional list of Data-keys to remove from UserData. Some SDKs cannot insert null-values into Data due to language
         * constraints. Use this to delete the keys directly.
         */
        TArray<FString> KeysToRemove;
        // Unique PlayFab assigned ID of the user on whom the operation will be performed.
        FString PlayFabId;

        FUpdateUserInternalDataRequest() :
            FPlayFabBaseModel(),
            Data(),
            KeysToRemove(),
            PlayFabId()
            {}

        FUpdateUserInternalDataRequest(const FUpdateUserInternalDataRequest& src) :
            FPlayFabBaseModel(),
            Data(src.Data),
            KeysToRemove(src.KeysToRemove),
            PlayFabId(src.PlayFabId)
            {}

        FUpdateUserInternalDataRequest(const TSharedPtr<FJsonObject>& obj) : FUpdateUserInternalDataRequest()
        {
            readFromValue(obj);
        }

        ~FUpdateUserInternalDataRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUpdateUserTitleDisplayNameRequest : public FPlayFabBaseModel
    {
        // New title display name for the user - must be between 3 and 25 characters
        FString DisplayName;

        // PlayFab unique identifier of the user whose title specific display name is to be changed
        FString PlayFabId;

        FUpdateUserTitleDisplayNameRequest() :
            FPlayFabBaseModel(),
            DisplayName(),
            PlayFabId()
            {}

        FUpdateUserTitleDisplayNameRequest(const FUpdateUserTitleDisplayNameRequest& src) :
            FPlayFabBaseModel(),
            DisplayName(src.DisplayName),
            PlayFabId(src.PlayFabId)
            {}

        FUpdateUserTitleDisplayNameRequest(const TSharedPtr<FJsonObject>& obj) : FUpdateUserTitleDisplayNameRequest()
        {
            readFromValue(obj);
        }

        ~FUpdateUserTitleDisplayNameRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUpdateUserTitleDisplayNameResult : public FPlayFabBaseModel
    {
        // [optional] current title display name for the user (this will be the original display name if the rename attempt failed)
        FString DisplayName;

        FUpdateUserTitleDisplayNameResult() :
            FPlayFabBaseModel(),
            DisplayName()
            {}

        FUpdateUserTitleDisplayNameResult(const FUpdateUserTitleDisplayNameResult& src) :
            FPlayFabBaseModel(),
            DisplayName(src.DisplayName)
            {}

        FUpdateUserTitleDisplayNameResult(const TSharedPtr<FJsonObject>& obj) : FUpdateUserTitleDisplayNameResult()
        {
            readFromValue(obj);
        }

        ~FUpdateUserTitleDisplayNameResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

}
}
