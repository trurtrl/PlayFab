// This is automatically generated by PlayFab SDKGenerator. DO NOT modify this manually!
#pragma once

#include "CoreMinimal.h"
#include "Core/PlayFabBaseModel.h"

namespace PlayFab
{
namespace ClientModels
{

    struct PLAYFAB_API FAcceptTradeRequest : public FPlayFabBaseModel
    {
        /**
         * [optional] Items from the accepting player's inventory in exchange for the offered items in the trade. In the case of a gift, this
         * will be null.
         */
        TArray<FString> AcceptedInventoryInstanceIds;
        // Player who opened the trade.
        FString OfferingPlayerId;

        // Trade identifier.
        FString TradeId;

        FAcceptTradeRequest() :
            FPlayFabBaseModel(),
            AcceptedInventoryInstanceIds(),
            OfferingPlayerId(),
            TradeId()
            {}

        FAcceptTradeRequest(const FAcceptTradeRequest& src) :
            FPlayFabBaseModel(),
            AcceptedInventoryInstanceIds(src.AcceptedInventoryInstanceIds),
            OfferingPlayerId(src.OfferingPlayerId),
            TradeId(src.TradeId)
            {}

        FAcceptTradeRequest(const TSharedPtr<FJsonObject>& obj) : FAcceptTradeRequest()
        {
            readFromValue(obj);
        }

        ~FAcceptTradeRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    enum TradeStatus
    {
        TradeStatusInvalid,
        TradeStatusOpening,
        TradeStatusOpen,
        TradeStatusAccepting,
        TradeStatusAccepted,
        TradeStatusFilled,
        TradeStatusCancelled
    };

    PLAYFAB_API void writeTradeStatusEnumJSON(TradeStatus enumVal, JsonWriter& writer);
    PLAYFAB_API TradeStatus readTradeStatusFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFAB_API TradeStatus readTradeStatusFromValue(const FString& value);

    struct PLAYFAB_API FTradeInfo : public FPlayFabBaseModel
    {
        // [optional] Item instances from the accepting player that are used to fulfill the trade. If null, no one has accepted the trade.
        TArray<FString> AcceptedInventoryInstanceIds;
        // [optional] The PlayFab ID of the player who accepted the trade. If null, no one has accepted the trade.
        FString AcceptedPlayerId;

        // [optional] An optional list of players allowed to complete this trade. If null, anybody can complete the trade.
        TArray<FString> AllowedPlayerIds;
        // [optional] If set, The UTC time when this trade was canceled.
        Boxed<FDateTime> CancelledAt;

        // [optional] If set, The UTC time when this trade was fulfilled.
        Boxed<FDateTime> FilledAt;

        // [optional] If set, The UTC time when this trade was made invalid.
        Boxed<FDateTime> InvalidatedAt;

        // [optional] The catalogItem Ids of the item instances being offered.
        TArray<FString> OfferedCatalogItemIds;
        // [optional] The itemInstance Ids that are being offered.
        TArray<FString> OfferedInventoryInstanceIds;
        // [optional] The PlayFabId for the offering player.
        FString OfferingPlayerId;

        // [optional] The UTC time when this trade was created.
        Boxed<FDateTime> OpenedAt;

        // [optional] The catalogItem Ids requested in exchange.
        TArray<FString> RequestedCatalogItemIds;
        // [optional] Describes the current state of this trade.
        Boxed<TradeStatus> Status;

        // [optional] The identifier for this trade.
        FString TradeId;

        FTradeInfo() :
            FPlayFabBaseModel(),
            AcceptedInventoryInstanceIds(),
            AcceptedPlayerId(),
            AllowedPlayerIds(),
            CancelledAt(),
            FilledAt(),
            InvalidatedAt(),
            OfferedCatalogItemIds(),
            OfferedInventoryInstanceIds(),
            OfferingPlayerId(),
            OpenedAt(),
            RequestedCatalogItemIds(),
            Status(),
            TradeId()
            {}

        FTradeInfo(const FTradeInfo& src) :
            FPlayFabBaseModel(),
            AcceptedInventoryInstanceIds(src.AcceptedInventoryInstanceIds),
            AcceptedPlayerId(src.AcceptedPlayerId),
            AllowedPlayerIds(src.AllowedPlayerIds),
            CancelledAt(src.CancelledAt),
            FilledAt(src.FilledAt),
            InvalidatedAt(src.InvalidatedAt),
            OfferedCatalogItemIds(src.OfferedCatalogItemIds),
            OfferedInventoryInstanceIds(src.OfferedInventoryInstanceIds),
            OfferingPlayerId(src.OfferingPlayerId),
            OpenedAt(src.OpenedAt),
            RequestedCatalogItemIds(src.RequestedCatalogItemIds),
            Status(src.Status),
            TradeId(src.TradeId)
            {}

        FTradeInfo(const TSharedPtr<FJsonObject>& obj) : FTradeInfo()
        {
            readFromValue(obj);
        }

        ~FTradeInfo();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FAcceptTradeResponse : public FPlayFabBaseModel
    {
        // [optional] Details about trade which was just accepted.
        TSharedPtr<FTradeInfo> Trade;

        FAcceptTradeResponse() :
            FPlayFabBaseModel(),
            Trade(nullptr)
            {}

        FAcceptTradeResponse(const FAcceptTradeResponse& src) :
            FPlayFabBaseModel(),
            Trade(src.Trade.IsValid() ? MakeShareable(new FTradeInfo(*src.Trade)) : nullptr)
            {}

        FAcceptTradeResponse(const TSharedPtr<FJsonObject>& obj) : FAcceptTradeResponse()
        {
            readFromValue(obj);
        }

        ~FAcceptTradeResponse();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FAdCampaignAttributionModel : public FPlayFabBaseModel
    {
        // UTC time stamp of attribution
        FDateTime AttributedAt;

        // [optional] Attribution campaign identifier
        FString CampaignId;

        // [optional] Attribution network name
        FString Platform;

        FAdCampaignAttributionModel() :
            FPlayFabBaseModel(),
            AttributedAt(0),
            CampaignId(),
            Platform()
            {}

        FAdCampaignAttributionModel(const FAdCampaignAttributionModel& src) :
            FPlayFabBaseModel(),
            AttributedAt(src.AttributedAt),
            CampaignId(src.CampaignId),
            Platform(src.Platform)
            {}

        FAdCampaignAttributionModel(const TSharedPtr<FJsonObject>& obj) : FAdCampaignAttributionModel()
        {
            readFromValue(obj);
        }

        ~FAdCampaignAttributionModel();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FAddFriendRequest : public FPlayFabBaseModel
    {
        // [optional] Email address of the user to attempt to add to the local user's friend list.
        FString FriendEmail;

        // [optional] PlayFab identifier of the user to attempt to add to the local user's friend list.
        FString FriendPlayFabId;

        // [optional] Title-specific display name of the user to attempt to add to the local user's friend list.
        FString FriendTitleDisplayName;

        // [optional] PlayFab username of the user to attempt to add to the local user's friend list.
        FString FriendUsername;

        FAddFriendRequest() :
            FPlayFabBaseModel(),
            FriendEmail(),
            FriendPlayFabId(),
            FriendTitleDisplayName(),
            FriendUsername()
            {}

        FAddFriendRequest(const FAddFriendRequest& src) :
            FPlayFabBaseModel(),
            FriendEmail(src.FriendEmail),
            FriendPlayFabId(src.FriendPlayFabId),
            FriendTitleDisplayName(src.FriendTitleDisplayName),
            FriendUsername(src.FriendUsername)
            {}

        FAddFriendRequest(const TSharedPtr<FJsonObject>& obj) : FAddFriendRequest()
        {
            readFromValue(obj);
        }

        ~FAddFriendRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FAddFriendResult : public FPlayFabBaseModel
    {
        // True if the friend request was processed successfully.
        bool Created;

        FAddFriendResult() :
            FPlayFabBaseModel(),
            Created(false)
            {}

        FAddFriendResult(const FAddFriendResult& src) :
            FPlayFabBaseModel(),
            Created(src.Created)
            {}

        FAddFriendResult(const TSharedPtr<FJsonObject>& obj) : FAddFriendResult()
        {
            readFromValue(obj);
        }

        ~FAddFriendResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGenericServiceId : public FPlayFabBaseModel
    {
        // Name of the service for which the player has a unique identifier.
        FString ServiceName;

        // Unique identifier of the player in that service.
        FString UserId;

        FGenericServiceId() :
            FPlayFabBaseModel(),
            ServiceName(),
            UserId()
            {}

        FGenericServiceId(const FGenericServiceId& src) :
            FPlayFabBaseModel(),
            ServiceName(src.ServiceName),
            UserId(src.UserId)
            {}

        FGenericServiceId(const TSharedPtr<FJsonObject>& obj) : FGenericServiceId()
        {
            readFromValue(obj);
        }

        ~FGenericServiceId();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FAddGenericIDRequest : public FPlayFabBaseModel
    {
        // Generic service identifier to add to the player account.
        FGenericServiceId GenericId;

        FAddGenericIDRequest() :
            FPlayFabBaseModel(),
            GenericId()
            {}

        FAddGenericIDRequest(const FAddGenericIDRequest& src) :
            FPlayFabBaseModel(),
            GenericId(src.GenericId)
            {}

        FAddGenericIDRequest(const TSharedPtr<FJsonObject>& obj) : FAddGenericIDRequest()
        {
            readFromValue(obj);
        }

        ~FAddGenericIDRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FAddGenericIDResult : public FPlayFabBaseModel
    {
        FAddGenericIDResult() :
            FPlayFabBaseModel()
            {}

        FAddGenericIDResult(const FAddGenericIDResult& src) :
            FPlayFabBaseModel()
            {}

        FAddGenericIDResult(const TSharedPtr<FJsonObject>& obj) : FAddGenericIDResult()
        {
            readFromValue(obj);
        }

        ~FAddGenericIDResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FAddOrUpdateContactEmailRequest : public FPlayFabBaseModel
    {
        // The new contact email to associate with the player.
        FString EmailAddress;

        FAddOrUpdateContactEmailRequest() :
            FPlayFabBaseModel(),
            EmailAddress()
            {}

        FAddOrUpdateContactEmailRequest(const FAddOrUpdateContactEmailRequest& src) :
            FPlayFabBaseModel(),
            EmailAddress(src.EmailAddress)
            {}

        FAddOrUpdateContactEmailRequest(const TSharedPtr<FJsonObject>& obj) : FAddOrUpdateContactEmailRequest()
        {
            readFromValue(obj);
        }

        ~FAddOrUpdateContactEmailRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FAddOrUpdateContactEmailResult : public FPlayFabBaseModel
    {
        FAddOrUpdateContactEmailResult() :
            FPlayFabBaseModel()
            {}

        FAddOrUpdateContactEmailResult(const FAddOrUpdateContactEmailResult& src) :
            FPlayFabBaseModel()
            {}

        FAddOrUpdateContactEmailResult(const TSharedPtr<FJsonObject>& obj) : FAddOrUpdateContactEmailResult()
        {
            readFromValue(obj);
        }

        ~FAddOrUpdateContactEmailResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FAddSharedGroupMembersRequest : public FPlayFabBaseModel
    {
        // An array of unique PlayFab assigned ID of the user on whom the operation will be performed.
        TArray<FString> PlayFabIds;
        // Unique identifier for the shared group.
        FString SharedGroupId;

        FAddSharedGroupMembersRequest() :
            FPlayFabBaseModel(),
            PlayFabIds(),
            SharedGroupId()
            {}

        FAddSharedGroupMembersRequest(const FAddSharedGroupMembersRequest& src) :
            FPlayFabBaseModel(),
            PlayFabIds(src.PlayFabIds),
            SharedGroupId(src.SharedGroupId)
            {}

        FAddSharedGroupMembersRequest(const TSharedPtr<FJsonObject>& obj) : FAddSharedGroupMembersRequest()
        {
            readFromValue(obj);
        }

        ~FAddSharedGroupMembersRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FAddSharedGroupMembersResult : public FPlayFabBaseModel
    {
        FAddSharedGroupMembersResult() :
            FPlayFabBaseModel()
            {}

        FAddSharedGroupMembersResult(const FAddSharedGroupMembersResult& src) :
            FPlayFabBaseModel()
            {}

        FAddSharedGroupMembersResult(const TSharedPtr<FJsonObject>& obj) : FAddSharedGroupMembersResult()
        {
            readFromValue(obj);
        }

        ~FAddSharedGroupMembersResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FAddUsernamePasswordRequest : public FPlayFabBaseModel
    {
        // User email address attached to their account
        FString Email;

        // Password for the PlayFab account (6-100 characters)
        FString Password;

        // PlayFab username for the account (3-20 characters)
        FString Username;

        FAddUsernamePasswordRequest() :
            FPlayFabBaseModel(),
            Email(),
            Password(),
            Username()
            {}

        FAddUsernamePasswordRequest(const FAddUsernamePasswordRequest& src) :
            FPlayFabBaseModel(),
            Email(src.Email),
            Password(src.Password),
            Username(src.Username)
            {}

        FAddUsernamePasswordRequest(const TSharedPtr<FJsonObject>& obj) : FAddUsernamePasswordRequest()
        {
            readFromValue(obj);
        }

        ~FAddUsernamePasswordRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FAddUsernamePasswordResult : public FPlayFabBaseModel
    {
        // [optional] PlayFab unique user name.
        FString Username;

        FAddUsernamePasswordResult() :
            FPlayFabBaseModel(),
            Username()
            {}

        FAddUsernamePasswordResult(const FAddUsernamePasswordResult& src) :
            FPlayFabBaseModel(),
            Username(src.Username)
            {}

        FAddUsernamePasswordResult(const TSharedPtr<FJsonObject>& obj) : FAddUsernamePasswordResult()
        {
            readFromValue(obj);
        }

        ~FAddUsernamePasswordResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FAddUserVirtualCurrencyRequest : public FPlayFabBaseModel
    {
        // Amount to be added to the user balance of the specified virtual currency.
        int32 Amount;

        // Name of the virtual currency which is to be incremented.
        FString VirtualCurrency;

        FAddUserVirtualCurrencyRequest() :
            FPlayFabBaseModel(),
            Amount(0),
            VirtualCurrency()
            {}

        FAddUserVirtualCurrencyRequest(const FAddUserVirtualCurrencyRequest& src) :
            FPlayFabBaseModel(),
            Amount(src.Amount),
            VirtualCurrency(src.VirtualCurrency)
            {}

        FAddUserVirtualCurrencyRequest(const TSharedPtr<FJsonObject>& obj) : FAddUserVirtualCurrencyRequest()
        {
            readFromValue(obj);
        }

        ~FAddUserVirtualCurrencyRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FAndroidDevicePushNotificationRegistrationRequest : public FPlayFabBaseModel
    {
        // [optional] Message to display when confirming push notification.
        FString ConfirmationMessage;

        /**
         * Registration ID provided by the Google Cloud Messaging service when the title registered to receive push notifications
         * (see the GCM documentation, here: http://developer.android.com/google/gcm/client.html).
         */
        FString DeviceToken;

        // [optional] If true, send a test push message immediately after sucessful registration. Defaults to false.
        Boxed<bool> SendPushNotificationConfirmation;

        FAndroidDevicePushNotificationRegistrationRequest() :
            FPlayFabBaseModel(),
            ConfirmationMessage(),
            DeviceToken(),
            SendPushNotificationConfirmation()
            {}

        FAndroidDevicePushNotificationRegistrationRequest(const FAndroidDevicePushNotificationRegistrationRequest& src) :
            FPlayFabBaseModel(),
            ConfirmationMessage(src.ConfirmationMessage),
            DeviceToken(src.DeviceToken),
            SendPushNotificationConfirmation(src.SendPushNotificationConfirmation)
            {}

        FAndroidDevicePushNotificationRegistrationRequest(const TSharedPtr<FJsonObject>& obj) : FAndroidDevicePushNotificationRegistrationRequest()
        {
            readFromValue(obj);
        }

        ~FAndroidDevicePushNotificationRegistrationRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FAndroidDevicePushNotificationRegistrationResult : public FPlayFabBaseModel
    {
        FAndroidDevicePushNotificationRegistrationResult() :
            FPlayFabBaseModel()
            {}

        FAndroidDevicePushNotificationRegistrationResult(const FAndroidDevicePushNotificationRegistrationResult& src) :
            FPlayFabBaseModel()
            {}

        FAndroidDevicePushNotificationRegistrationResult(const TSharedPtr<FJsonObject>& obj) : FAndroidDevicePushNotificationRegistrationResult()
        {
            readFromValue(obj);
        }

        ~FAndroidDevicePushNotificationRegistrationResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FAttributeInstallRequest : public FPlayFabBaseModel
    {
        // [optional] The adid for this device.
        FString Adid;

        // [optional] The IdentifierForAdvertisers for iOS Devices.
        FString Idfa;

        FAttributeInstallRequest() :
            FPlayFabBaseModel(),
            Adid(),
            Idfa()
            {}

        FAttributeInstallRequest(const FAttributeInstallRequest& src) :
            FPlayFabBaseModel(),
            Adid(src.Adid),
            Idfa(src.Idfa)
            {}

        FAttributeInstallRequest(const TSharedPtr<FJsonObject>& obj) : FAttributeInstallRequest()
        {
            readFromValue(obj);
        }

        ~FAttributeInstallRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FAttributeInstallResult : public FPlayFabBaseModel
    {
        FAttributeInstallResult() :
            FPlayFabBaseModel()
            {}

        FAttributeInstallResult(const FAttributeInstallResult& src) :
            FPlayFabBaseModel()
            {}

        FAttributeInstallResult(const TSharedPtr<FJsonObject>& obj) : FAttributeInstallResult()
        {
            readFromValue(obj);
        }

        ~FAttributeInstallResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FCancelTradeRequest : public FPlayFabBaseModel
    {
        // Trade identifier.
        FString TradeId;

        FCancelTradeRequest() :
            FPlayFabBaseModel(),
            TradeId()
            {}

        FCancelTradeRequest(const FCancelTradeRequest& src) :
            FPlayFabBaseModel(),
            TradeId(src.TradeId)
            {}

        FCancelTradeRequest(const TSharedPtr<FJsonObject>& obj) : FCancelTradeRequest()
        {
            readFromValue(obj);
        }

        ~FCancelTradeRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FCancelTradeResponse : public FPlayFabBaseModel
    {
        // [optional] Details about trade which was just canceled.
        TSharedPtr<FTradeInfo> Trade;

        FCancelTradeResponse() :
            FPlayFabBaseModel(),
            Trade(nullptr)
            {}

        FCancelTradeResponse(const FCancelTradeResponse& src) :
            FPlayFabBaseModel(),
            Trade(src.Trade.IsValid() ? MakeShareable(new FTradeInfo(*src.Trade)) : nullptr)
            {}

        FCancelTradeResponse(const TSharedPtr<FJsonObject>& obj) : FCancelTradeResponse()
        {
            readFromValue(obj);
        }

        ~FCancelTradeResponse();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FCartItem : public FPlayFabBaseModel
    {
        // [optional] Description of the catalog item.
        FString Description;

        // [optional] Display name for the catalog item.
        FString DisplayName;

        // [optional] Class name to which catalog item belongs.
        FString ItemClass;

        // [optional] Unique identifier for the catalog item.
        FString ItemId;

        // [optional] Unique instance identifier for this catalog item.
        FString ItemInstanceId;

        // [optional] Cost of the catalog item for each applicable real world currency.
        TMap<FString, uint32> RealCurrencyPrices;
        // [optional] Amount of each applicable virtual currency which will be received as a result of purchasing this catalog item.
        TMap<FString, uint32> VCAmount;
        // [optional] Cost of the catalog item for each applicable virtual currency.
        TMap<FString, uint32> VirtualCurrencyPrices;
        FCartItem() :
            FPlayFabBaseModel(),
            Description(),
            DisplayName(),
            ItemClass(),
            ItemId(),
            ItemInstanceId(),
            RealCurrencyPrices(),
            VCAmount(),
            VirtualCurrencyPrices()
            {}

        FCartItem(const FCartItem& src) :
            FPlayFabBaseModel(),
            Description(src.Description),
            DisplayName(src.DisplayName),
            ItemClass(src.ItemClass),
            ItemId(src.ItemId),
            ItemInstanceId(src.ItemInstanceId),
            RealCurrencyPrices(src.RealCurrencyPrices),
            VCAmount(src.VCAmount),
            VirtualCurrencyPrices(src.VirtualCurrencyPrices)
            {}

        FCartItem(const TSharedPtr<FJsonObject>& obj) : FCartItem()
        {
            readFromValue(obj);
        }

        ~FCartItem();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FCatalogItemBundleInfo : public FPlayFabBaseModel
    {
        // [optional] unique ItemId values for all items which will be added to the player inventory when the bundle is added
        TArray<FString> BundledItems;
        /**
         * [optional] unique TableId values for all RandomResultTable objects which are part of the bundle (random tables will be resolved and
         * add the relevant items to the player inventory when the bundle is added)
         */
        TArray<FString> BundledResultTables;
        // [optional] virtual currency types and balances which will be added to the player inventory when the bundle is added
        TMap<FString, uint32> BundledVirtualCurrencies;
        FCatalogItemBundleInfo() :
            FPlayFabBaseModel(),
            BundledItems(),
            BundledResultTables(),
            BundledVirtualCurrencies()
            {}

        FCatalogItemBundleInfo(const FCatalogItemBundleInfo& src) :
            FPlayFabBaseModel(),
            BundledItems(src.BundledItems),
            BundledResultTables(src.BundledResultTables),
            BundledVirtualCurrencies(src.BundledVirtualCurrencies)
            {}

        FCatalogItemBundleInfo(const TSharedPtr<FJsonObject>& obj) : FCatalogItemBundleInfo()
        {
            readFromValue(obj);
        }

        ~FCatalogItemBundleInfo();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FCatalogItemConsumableInfo : public FPlayFabBaseModel
    {
        // [optional] number of times this object can be used, after which it will be removed from the player inventory
        Boxed<uint32> UsageCount;

        /**
         * [optional] duration in seconds for how long the item will remain in the player inventory - once elapsed, the item will be removed
         * (recommended minimum value is 5 seconds, as lower values can cause the item to expire before operations depending on
         * this item's details have completed)
         */
        Boxed<uint32> UsagePeriod;

        /**
         * [optional] all inventory item instances in the player inventory sharing a non-null UsagePeriodGroup have their UsagePeriod values
         * added together, and share the result - when that period has elapsed, all the items in the group will be removed
         */
        FString UsagePeriodGroup;

        FCatalogItemConsumableInfo() :
            FPlayFabBaseModel(),
            UsageCount(),
            UsagePeriod(),
            UsagePeriodGroup()
            {}

        FCatalogItemConsumableInfo(const FCatalogItemConsumableInfo& src) :
            FPlayFabBaseModel(),
            UsageCount(src.UsageCount),
            UsagePeriod(src.UsagePeriod),
            UsagePeriodGroup(src.UsagePeriodGroup)
            {}

        FCatalogItemConsumableInfo(const TSharedPtr<FJsonObject>& obj) : FCatalogItemConsumableInfo()
        {
            readFromValue(obj);
        }

        ~FCatalogItemConsumableInfo();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FCatalogItemContainerInfo : public FPlayFabBaseModel
    {
        // [optional] unique ItemId values for all items which will be added to the player inventory, once the container has been unlocked
        TArray<FString> ItemContents;
        /**
         * [optional] ItemId for the catalog item used to unlock the container, if any (if not specified, a call to UnlockContainerItem will
         * open the container, adding the contents to the player inventory and currency balances)
         */
        FString KeyItemId;

        /**
         * [optional] unique TableId values for all RandomResultTable objects which are part of the container (once unlocked, random tables
         * will be resolved and add the relevant items to the player inventory)
         */
        TArray<FString> ResultTableContents;
        // [optional] virtual currency types and balances which will be added to the player inventory when the container is unlocked
        TMap<FString, uint32> VirtualCurrencyContents;
        FCatalogItemContainerInfo() :
            FPlayFabBaseModel(),
            ItemContents(),
            KeyItemId(),
            ResultTableContents(),
            VirtualCurrencyContents()
            {}

        FCatalogItemContainerInfo(const FCatalogItemContainerInfo& src) :
            FPlayFabBaseModel(),
            ItemContents(src.ItemContents),
            KeyItemId(src.KeyItemId),
            ResultTableContents(src.ResultTableContents),
            VirtualCurrencyContents(src.VirtualCurrencyContents)
            {}

        FCatalogItemContainerInfo(const TSharedPtr<FJsonObject>& obj) : FCatalogItemContainerInfo()
        {
            readFromValue(obj);
        }

        ~FCatalogItemContainerInfo();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FCatalogItem : public FPlayFabBaseModel
    {
        /**
         * [optional] defines the bundle properties for the item - bundles are items which contain other items, including random drop tables
         * and virtual currencies
         */
        TSharedPtr<FCatalogItemBundleInfo> Bundle;

        // if true, then an item instance of this type can be used to grant a character to a user.
        bool CanBecomeCharacter;

        // [optional] catalog version for this item
        FString CatalogVersion;

        // [optional] defines the consumable properties (number of uses, timeout) for the item
        TSharedPtr<FCatalogItemConsumableInfo> Consumable;

        /**
         * [optional] defines the container properties for the item - what items it contains, including random drop tables and virtual
         * currencies, and what item (if any) is required to open it via the UnlockContainerItem API
         */
        TSharedPtr<FCatalogItemContainerInfo> Container;

        // [optional] game specific custom data
        FString CustomData;

        // [optional] text description of item, to show in-game
        FString Description;

        // [optional] text name for the item, to show in-game
        FString DisplayName;

        /**
         * If the item has IsLImitedEdition set to true, and this is the first time this ItemId has been defined as a limited
         * edition item, this value determines the total number of instances to allocate for the title. Once this limit has been
         * reached, no more instances of this ItemId can be created, and attempts to purchase or grant it will return a Result of
         * false for that ItemId. If the item has already been defined to have a limited edition count, or if this value is less
         * than zero, it will be ignored.
         */
        int32 InitialLimitedEditionCount;

        // BETA: If true, then only a fixed number can ever be granted.
        bool IsLimitedEdition;

        /**
         * if true, then only one item instance of this type will exist and its remaininguses will be incremented instead.
         * RemainingUses will cap out at Int32.Max (2,147,483,647). All subsequent increases will be discarded
         */
        bool IsStackable;

        // if true, then an item instance of this type can be traded between players using the trading APIs
        bool IsTradable;

        // [optional] class to which the item belongs
        FString ItemClass;

        // unique identifier for this item
        FString ItemId;

        /**
         * [optional] URL to the item image. For Facebook purchase to display the image on the item purchase page, this must be set to an HTTP
         * URL.
         */
        FString ItemImageUrl;

        // [optional] override prices for this item for specific currencies
        TMap<FString, uint32> RealCurrencyPrices;
        // [optional] list of item tags
        TArray<FString> Tags;
        // [optional] price of this item in virtual currencies and "RM" (the base Real Money purchase price, in USD pennies)
        TMap<FString, uint32> VirtualCurrencyPrices;
        FCatalogItem() :
            FPlayFabBaseModel(),
            Bundle(nullptr),
            CanBecomeCharacter(false),
            CatalogVersion(),
            Consumable(nullptr),
            Container(nullptr),
            CustomData(),
            Description(),
            DisplayName(),
            InitialLimitedEditionCount(0),
            IsLimitedEdition(false),
            IsStackable(false),
            IsTradable(false),
            ItemClass(),
            ItemId(),
            ItemImageUrl(),
            RealCurrencyPrices(),
            Tags(),
            VirtualCurrencyPrices()
            {}

        FCatalogItem(const FCatalogItem& src) :
            FPlayFabBaseModel(),
            Bundle(src.Bundle.IsValid() ? MakeShareable(new FCatalogItemBundleInfo(*src.Bundle)) : nullptr),
            CanBecomeCharacter(src.CanBecomeCharacter),
            CatalogVersion(src.CatalogVersion),
            Consumable(src.Consumable.IsValid() ? MakeShareable(new FCatalogItemConsumableInfo(*src.Consumable)) : nullptr),
            Container(src.Container.IsValid() ? MakeShareable(new FCatalogItemContainerInfo(*src.Container)) : nullptr),
            CustomData(src.CustomData),
            Description(src.Description),
            DisplayName(src.DisplayName),
            InitialLimitedEditionCount(src.InitialLimitedEditionCount),
            IsLimitedEdition(src.IsLimitedEdition),
            IsStackable(src.IsStackable),
            IsTradable(src.IsTradable),
            ItemClass(src.ItemClass),
            ItemId(src.ItemId),
            ItemImageUrl(src.ItemImageUrl),
            RealCurrencyPrices(src.RealCurrencyPrices),
            Tags(src.Tags),
            VirtualCurrencyPrices(src.VirtualCurrencyPrices)
            {}

        FCatalogItem(const TSharedPtr<FJsonObject>& obj) : FCatalogItem()
        {
            readFromValue(obj);
        }

        ~FCatalogItem();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FItemInstance : public FPlayFabBaseModel
    {
        // [optional] Game specific comment associated with this instance when it was added to the user inventory.
        FString Annotation;

        // [optional] Array of unique items that were awarded when this catalog item was purchased.
        TArray<FString> BundleContents;
        /**
         * [optional] Unique identifier for the parent inventory item, as defined in the catalog, for object which were added from a bundle or
         * container.
         */
        FString BundleParent;

        // [optional] Catalog version for the inventory item, when this instance was created.
        FString CatalogVersion;

        // [optional] A set of custom key-value pairs on the inventory item.
        TMap<FString, FString> CustomData;
        // [optional] CatalogItem.DisplayName at the time this item was purchased.
        FString DisplayName;

        // [optional] Timestamp for when this instance will expire.
        Boxed<FDateTime> Expiration;

        // [optional] Class name for the inventory item, as defined in the catalog.
        FString ItemClass;

        // [optional] Unique identifier for the inventory item, as defined in the catalog.
        FString ItemId;

        // [optional] Unique item identifier for this specific instance of the item.
        FString ItemInstanceId;

        // [optional] Timestamp for when this instance was purchased.
        Boxed<FDateTime> PurchaseDate;

        // [optional] Total number of remaining uses, if this is a consumable item.
        Boxed<int32> RemainingUses;

        // [optional] Currency type for the cost of the catalog item.
        FString UnitCurrency;

        // Cost of the catalog item in the given currency.
        uint32 UnitPrice;

        // [optional] The number of uses that were added or removed to this item in this call.
        Boxed<int32> UsesIncrementedBy;

        FItemInstance() :
            FPlayFabBaseModel(),
            Annotation(),
            BundleContents(),
            BundleParent(),
            CatalogVersion(),
            CustomData(),
            DisplayName(),
            Expiration(),
            ItemClass(),
            ItemId(),
            ItemInstanceId(),
            PurchaseDate(),
            RemainingUses(),
            UnitCurrency(),
            UnitPrice(0),
            UsesIncrementedBy()
            {}

        FItemInstance(const FItemInstance& src) :
            FPlayFabBaseModel(),
            Annotation(src.Annotation),
            BundleContents(src.BundleContents),
            BundleParent(src.BundleParent),
            CatalogVersion(src.CatalogVersion),
            CustomData(src.CustomData),
            DisplayName(src.DisplayName),
            Expiration(src.Expiration),
            ItemClass(src.ItemClass),
            ItemId(src.ItemId),
            ItemInstanceId(src.ItemInstanceId),
            PurchaseDate(src.PurchaseDate),
            RemainingUses(src.RemainingUses),
            UnitCurrency(src.UnitCurrency),
            UnitPrice(src.UnitPrice),
            UsesIncrementedBy(src.UsesIncrementedBy)
            {}

        FItemInstance(const TSharedPtr<FJsonObject>& obj) : FItemInstance()
        {
            readFromValue(obj);
        }

        ~FItemInstance();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FCharacterInventory : public FPlayFabBaseModel
    {
        // [optional] The id of this character.
        FString CharacterId;

        // [optional] The inventory of this character.
        TArray<FItemInstance> Inventory;
        FCharacterInventory() :
            FPlayFabBaseModel(),
            CharacterId(),
            Inventory()
            {}

        FCharacterInventory(const FCharacterInventory& src) :
            FPlayFabBaseModel(),
            CharacterId(src.CharacterId),
            Inventory(src.Inventory)
            {}

        FCharacterInventory(const TSharedPtr<FJsonObject>& obj) : FCharacterInventory()
        {
            readFromValue(obj);
        }

        ~FCharacterInventory();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FCharacterLeaderboardEntry : public FPlayFabBaseModel
    {
        // [optional] PlayFab unique identifier of the character that belongs to the user for this leaderboard entry.
        FString CharacterId;

        // [optional] Title-specific display name of the character for this leaderboard entry.
        FString CharacterName;

        // [optional] Name of the character class for this entry.
        FString CharacterType;

        // [optional] Title-specific display name of the user for this leaderboard entry.
        FString DisplayName;

        // [optional] PlayFab unique identifier of the user for this leaderboard entry.
        FString PlayFabId;

        // User's overall position in the leaderboard.
        int32 Position;

        // Specific value of the user's statistic.
        int32 StatValue;

        FCharacterLeaderboardEntry() :
            FPlayFabBaseModel(),
            CharacterId(),
            CharacterName(),
            CharacterType(),
            DisplayName(),
            PlayFabId(),
            Position(0),
            StatValue(0)
            {}

        FCharacterLeaderboardEntry(const FCharacterLeaderboardEntry& src) :
            FPlayFabBaseModel(),
            CharacterId(src.CharacterId),
            CharacterName(src.CharacterName),
            CharacterType(src.CharacterType),
            DisplayName(src.DisplayName),
            PlayFabId(src.PlayFabId),
            Position(src.Position),
            StatValue(src.StatValue)
            {}

        FCharacterLeaderboardEntry(const TSharedPtr<FJsonObject>& obj) : FCharacterLeaderboardEntry()
        {
            readFromValue(obj);
        }

        ~FCharacterLeaderboardEntry();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FCharacterResult : public FPlayFabBaseModel
    {
        // [optional] The id for this character on this player.
        FString CharacterId;

        // [optional] The name of this character.
        FString CharacterName;

        // [optional] The type-string that was given to this character on creation.
        FString CharacterType;

        FCharacterResult() :
            FPlayFabBaseModel(),
            CharacterId(),
            CharacterName(),
            CharacterType()
            {}

        FCharacterResult(const FCharacterResult& src) :
            FPlayFabBaseModel(),
            CharacterId(src.CharacterId),
            CharacterName(src.CharacterName),
            CharacterType(src.CharacterType)
            {}

        FCharacterResult(const TSharedPtr<FJsonObject>& obj) : FCharacterResult()
        {
            readFromValue(obj);
        }

        ~FCharacterResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    enum CloudScriptRevisionOption
    {
        CloudScriptRevisionOptionLive,
        CloudScriptRevisionOptionLatest,
        CloudScriptRevisionOptionSpecific
    };

    PLAYFAB_API void writeCloudScriptRevisionOptionEnumJSON(CloudScriptRevisionOption enumVal, JsonWriter& writer);
    PLAYFAB_API CloudScriptRevisionOption readCloudScriptRevisionOptionFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFAB_API CloudScriptRevisionOption readCloudScriptRevisionOptionFromValue(const FString& value);

    struct PLAYFAB_API FContainer_Dictionary_String_String : public FPlayFabBaseModel
    {
        // [optional] Content of data
        TMap<FString, FString> Data;
        FContainer_Dictionary_String_String() :
            FPlayFabBaseModel(),
            Data()
            {}

        FContainer_Dictionary_String_String(const FContainer_Dictionary_String_String& src) :
            FPlayFabBaseModel(),
            Data(src.Data)
            {}

        FContainer_Dictionary_String_String(const TSharedPtr<FJsonObject>& obj) : FContainer_Dictionary_String_String()
        {
            readFromValue(obj);
        }

        ~FContainer_Dictionary_String_String();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FCollectionFilter : public FPlayFabBaseModel
    {
        // [optional] List of Exclude rules, with any of which if a collection matches, it is excluded by the filter.
        TArray<FContainer_Dictionary_String_String> Excludes;
        /**
         * [optional] List of Include rules, with any of which if a collection matches, it is included by the filter, unless it is excluded by
         * one of the Exclude rule
         */
        TArray<FContainer_Dictionary_String_String> Includes;
        FCollectionFilter() :
            FPlayFabBaseModel(),
            Excludes(),
            Includes()
            {}

        FCollectionFilter(const FCollectionFilter& src) :
            FPlayFabBaseModel(),
            Excludes(src.Excludes),
            Includes(src.Includes)
            {}

        FCollectionFilter(const TSharedPtr<FJsonObject>& obj) : FCollectionFilter()
        {
            readFromValue(obj);
        }

        ~FCollectionFilter();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FConfirmPurchaseRequest : public FPlayFabBaseModel
    {
        // Purchase order identifier returned from StartPurchase.
        FString OrderId;

        FConfirmPurchaseRequest() :
            FPlayFabBaseModel(),
            OrderId()
            {}

        FConfirmPurchaseRequest(const FConfirmPurchaseRequest& src) :
            FPlayFabBaseModel(),
            OrderId(src.OrderId)
            {}

        FConfirmPurchaseRequest(const TSharedPtr<FJsonObject>& obj) : FConfirmPurchaseRequest()
        {
            readFromValue(obj);
        }

        ~FConfirmPurchaseRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FConfirmPurchaseResult : public FPlayFabBaseModel
    {
        // [optional] Array of items purchased.
        TArray<FItemInstance> Items;
        // [optional] Purchase order identifier.
        FString OrderId;

        // Date and time of the purchase.
        FDateTime PurchaseDate;

        FConfirmPurchaseResult() :
            FPlayFabBaseModel(),
            Items(),
            OrderId(),
            PurchaseDate(0)
            {}

        FConfirmPurchaseResult(const FConfirmPurchaseResult& src) :
            FPlayFabBaseModel(),
            Items(src.Items),
            OrderId(src.OrderId),
            PurchaseDate(src.PurchaseDate)
            {}

        FConfirmPurchaseResult(const TSharedPtr<FJsonObject>& obj) : FConfirmPurchaseResult()
        {
            readFromValue(obj);
        }

        ~FConfirmPurchaseResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FConsumeItemRequest : public FPlayFabBaseModel
    {
        // [optional] Unique PlayFab assigned ID for a specific character owned by a user
        FString CharacterId;

        // Number of uses to consume from the item.
        int32 ConsumeCount;

        // Unique instance identifier of the item to be consumed.
        FString ItemInstanceId;

        FConsumeItemRequest() :
            FPlayFabBaseModel(),
            CharacterId(),
            ConsumeCount(0),
            ItemInstanceId()
            {}

        FConsumeItemRequest(const FConsumeItemRequest& src) :
            FPlayFabBaseModel(),
            CharacterId(src.CharacterId),
            ConsumeCount(src.ConsumeCount),
            ItemInstanceId(src.ItemInstanceId)
            {}

        FConsumeItemRequest(const TSharedPtr<FJsonObject>& obj) : FConsumeItemRequest()
        {
            readFromValue(obj);
        }

        ~FConsumeItemRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FConsumeItemResult : public FPlayFabBaseModel
    {
        // [optional] Unique instance identifier of the item with uses consumed.
        FString ItemInstanceId;

        // Number of uses remaining on the item.
        int32 RemainingUses;

        FConsumeItemResult() :
            FPlayFabBaseModel(),
            ItemInstanceId(),
            RemainingUses(0)
            {}

        FConsumeItemResult(const FConsumeItemResult& src) :
            FPlayFabBaseModel(),
            ItemInstanceId(src.ItemInstanceId),
            RemainingUses(src.RemainingUses)
            {}

        FConsumeItemResult(const TSharedPtr<FJsonObject>& obj) : FConsumeItemResult()
        {
            readFromValue(obj);
        }

        ~FConsumeItemResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    enum EmailVerificationStatus
    {
        EmailVerificationStatusUnverified,
        EmailVerificationStatusPending,
        EmailVerificationStatusConfirmed
    };

    PLAYFAB_API void writeEmailVerificationStatusEnumJSON(EmailVerificationStatus enumVal, JsonWriter& writer);
    PLAYFAB_API EmailVerificationStatus readEmailVerificationStatusFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFAB_API EmailVerificationStatus readEmailVerificationStatusFromValue(const FString& value);

    struct PLAYFAB_API FContactEmailInfoModel : public FPlayFabBaseModel
    {
        // [optional] The email address
        FString EmailAddress;

        // [optional] The name of the email info data
        FString Name;

        // [optional] The verification status of the email
        Boxed<EmailVerificationStatus> VerificationStatus;

        FContactEmailInfoModel() :
            FPlayFabBaseModel(),
            EmailAddress(),
            Name(),
            VerificationStatus()
            {}

        FContactEmailInfoModel(const FContactEmailInfoModel& src) :
            FPlayFabBaseModel(),
            EmailAddress(src.EmailAddress),
            Name(src.Name),
            VerificationStatus(src.VerificationStatus)
            {}

        FContactEmailInfoModel(const TSharedPtr<FJsonObject>& obj) : FContactEmailInfoModel()
        {
            readFromValue(obj);
        }

        ~FContactEmailInfoModel();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    enum ContinentCode
    {
        ContinentCodeAF,
        ContinentCodeAN,
        ContinentCodeAS,
        ContinentCodeEU,
        ContinentCodeNA,
        ContinentCodeOC,
        ContinentCodeSA
    };

    PLAYFAB_API void writeContinentCodeEnumJSON(ContinentCode enumVal, JsonWriter& writer);
    PLAYFAB_API ContinentCode readContinentCodeFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFAB_API ContinentCode readContinentCodeFromValue(const FString& value);

    enum CountryCode
    {
        CountryCodeAF,
        CountryCodeAX,
        CountryCodeAL,
        CountryCodeDZ,
        CountryCodeAS,
        CountryCodeAD,
        CountryCodeAO,
        CountryCodeAI,
        CountryCodeAQ,
        CountryCodeAG,
        CountryCodeAR,
        CountryCodeAM,
        CountryCodeAW,
        CountryCodeAU,
        CountryCodeAT,
        CountryCodeAZ,
        CountryCodeBS,
        CountryCodeBH,
        CountryCodeBD,
        CountryCodeBB,
        CountryCodeBY,
        CountryCodeBE,
        CountryCodeBZ,
        CountryCodeBJ,
        CountryCodeBM,
        CountryCodeBT,
        CountryCodeBO,
        CountryCodeBQ,
        CountryCodeBA,
        CountryCodeBW,
        CountryCodeBV,
        CountryCodeBR,
        CountryCodeIO,
        CountryCodeBN,
        CountryCodeBG,
        CountryCodeBF,
        CountryCodeBI,
        CountryCodeKH,
        CountryCodeCM,
        CountryCodeCA,
        CountryCodeCV,
        CountryCodeKY,
        CountryCodeCF,
        CountryCodeTD,
        CountryCodeCL,
        CountryCodeCN,
        CountryCodeCX,
        CountryCodeCC,
        CountryCodeCO,
        CountryCodeKM,
        CountryCodeCG,
        CountryCodeCD,
        CountryCodeCK,
        CountryCodeCR,
        CountryCodeCI,
        CountryCodeHR,
        CountryCodeCU,
        CountryCodeCW,
        CountryCodeCY,
        CountryCodeCZ,
        CountryCodeDK,
        CountryCodeDJ,
        CountryCodeDM,
        CountryCodeDO,
        CountryCodeEC,
        CountryCodeEG,
        CountryCodeSV,
        CountryCodeGQ,
        CountryCodeER,
        CountryCodeEE,
        CountryCodeET,
        CountryCodeFK,
        CountryCodeFO,
        CountryCodeFJ,
        CountryCodeFI,
        CountryCodeFR,
        CountryCodeGF,
        CountryCodePF,
        CountryCodeTF,
        CountryCodeGA,
        CountryCodeGM,
        CountryCodeGE,
        CountryCodeDE,
        CountryCodeGH,
        CountryCodeGI,
        CountryCodeGR,
        CountryCodeGL,
        CountryCodeGD,
        CountryCodeGP,
        CountryCodeGU,
        CountryCodeGT,
        CountryCodeGG,
        CountryCodeGN,
        CountryCodeGW,
        CountryCodeGY,
        CountryCodeHT,
        CountryCodeHM,
        CountryCodeVA,
        CountryCodeHN,
        CountryCodeHK,
        CountryCodeHU,
        CountryCodeIS,
        CountryCodeIN,
        CountryCodeID,
        CountryCodeIR,
        CountryCodeIQ,
        CountryCodeIE,
        CountryCodeIM,
        CountryCodeIL,
        CountryCodeIT,
        CountryCodeJM,
        CountryCodeJP,
        CountryCodeJE,
        CountryCodeJO,
        CountryCodeKZ,
        CountryCodeKE,
        CountryCodeKI,
        CountryCodeKP,
        CountryCodeKR,
        CountryCodeKW,
        CountryCodeKG,
        CountryCodeLA,
        CountryCodeLV,
        CountryCodeLB,
        CountryCodeLS,
        CountryCodeLR,
        CountryCodeLY,
        CountryCodeLI,
        CountryCodeLT,
        CountryCodeLU,
        CountryCodeMO,
        CountryCodeMK,
        CountryCodeMG,
        CountryCodeMW,
        CountryCodeMY,
        CountryCodeMV,
        CountryCodeML,
        CountryCodeMT,
        CountryCodeMH,
        CountryCodeMQ,
        CountryCodeMR,
        CountryCodeMU,
        CountryCodeYT,
        CountryCodeMX,
        CountryCodeFM,
        CountryCodeMD,
        CountryCodeMC,
        CountryCodeMN,
        CountryCodeME,
        CountryCodeMS,
        CountryCodeMA,
        CountryCodeMZ,
        CountryCodeMM,
        CountryCodeNA,
        CountryCodeNR,
        CountryCodeNP,
        CountryCodeNL,
        CountryCodeNC,
        CountryCodeNZ,
        CountryCodeNI,
        CountryCodeNE,
        CountryCodeNG,
        CountryCodeNU,
        CountryCodeNF,
        CountryCodeMP,
        CountryCodeNO,
        CountryCodeOM,
        CountryCodePK,
        CountryCodePW,
        CountryCodePS,
        CountryCodePA,
        CountryCodePG,
        CountryCodePY,
        CountryCodePE,
        CountryCodePH,
        CountryCodePN,
        CountryCodePL,
        CountryCodePT,
        CountryCodePR,
        CountryCodeQA,
        CountryCodeRE,
        CountryCodeRO,
        CountryCodeRU,
        CountryCodeRW,
        CountryCodeBL,
        CountryCodeSH,
        CountryCodeKN,
        CountryCodeLC,
        CountryCodeMF,
        CountryCodePM,
        CountryCodeVC,
        CountryCodeWS,
        CountryCodeSM,
        CountryCodeST,
        CountryCodeSA,
        CountryCodeSN,
        CountryCodeRS,
        CountryCodeSC,
        CountryCodeSL,
        CountryCodeSG,
        CountryCodeSX,
        CountryCodeSK,
        CountryCodeSI,
        CountryCodeSB,
        CountryCodeSO,
        CountryCodeZA,
        CountryCodeGS,
        CountryCodeSS,
        CountryCodeES,
        CountryCodeLK,
        CountryCodeSD,
        CountryCodeSR,
        CountryCodeSJ,
        CountryCodeSZ,
        CountryCodeSE,
        CountryCodeCH,
        CountryCodeSY,
        CountryCodeTW,
        CountryCodeTJ,
        CountryCodeTZ,
        CountryCodeTH,
        CountryCodeTL,
        CountryCodeTG,
        CountryCodeTK,
        CountryCodeTO,
        CountryCodeTT,
        CountryCodeTN,
        CountryCodeTR,
        CountryCodeTM,
        CountryCodeTC,
        CountryCodeTV,
        CountryCodeUG,
        CountryCodeUA,
        CountryCodeAE,
        CountryCodeGB,
        CountryCodeUS,
        CountryCodeUM,
        CountryCodeUY,
        CountryCodeUZ,
        CountryCodeVU,
        CountryCodeVE,
        CountryCodeVN,
        CountryCodeVG,
        CountryCodeVI,
        CountryCodeWF,
        CountryCodeEH,
        CountryCodeYE,
        CountryCodeZM,
        CountryCodeZW
    };

    PLAYFAB_API void writeCountryCodeEnumJSON(CountryCode enumVal, JsonWriter& writer);
    PLAYFAB_API CountryCode readCountryCodeFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFAB_API CountryCode readCountryCodeFromValue(const FString& value);

    struct PLAYFAB_API FCreateSharedGroupRequest : public FPlayFabBaseModel
    {
        // [optional] Unique identifier for the shared group (a random identifier will be assigned, if one is not specified).
        FString SharedGroupId;

        FCreateSharedGroupRequest() :
            FPlayFabBaseModel(),
            SharedGroupId()
            {}

        FCreateSharedGroupRequest(const FCreateSharedGroupRequest& src) :
            FPlayFabBaseModel(),
            SharedGroupId(src.SharedGroupId)
            {}

        FCreateSharedGroupRequest(const TSharedPtr<FJsonObject>& obj) : FCreateSharedGroupRequest()
        {
            readFromValue(obj);
        }

        ~FCreateSharedGroupRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FCreateSharedGroupResult : public FPlayFabBaseModel
    {
        // [optional] Unique identifier for the shared group.
        FString SharedGroupId;

        FCreateSharedGroupResult() :
            FPlayFabBaseModel(),
            SharedGroupId()
            {}

        FCreateSharedGroupResult(const FCreateSharedGroupResult& src) :
            FPlayFabBaseModel(),
            SharedGroupId(src.SharedGroupId)
            {}

        FCreateSharedGroupResult(const TSharedPtr<FJsonObject>& obj) : FCreateSharedGroupResult()
        {
            readFromValue(obj);
        }

        ~FCreateSharedGroupResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    enum Currency
    {
        CurrencyAED,
        CurrencyAFN,
        CurrencyALL,
        CurrencyAMD,
        CurrencyANG,
        CurrencyAOA,
        CurrencyARS,
        CurrencyAUD,
        CurrencyAWG,
        CurrencyAZN,
        CurrencyBAM,
        CurrencyBBD,
        CurrencyBDT,
        CurrencyBGN,
        CurrencyBHD,
        CurrencyBIF,
        CurrencyBMD,
        CurrencyBND,
        CurrencyBOB,
        CurrencyBRL,
        CurrencyBSD,
        CurrencyBTN,
        CurrencyBWP,
        CurrencyBYR,
        CurrencyBZD,
        CurrencyCAD,
        CurrencyCDF,
        CurrencyCHF,
        CurrencyCLP,
        CurrencyCNY,
        CurrencyCOP,
        CurrencyCRC,
        CurrencyCUC,
        CurrencyCUP,
        CurrencyCVE,
        CurrencyCZK,
        CurrencyDJF,
        CurrencyDKK,
        CurrencyDOP,
        CurrencyDZD,
        CurrencyEGP,
        CurrencyERN,
        CurrencyETB,
        CurrencyEUR,
        CurrencyFJD,
        CurrencyFKP,
        CurrencyGBP,
        CurrencyGEL,
        CurrencyGGP,
        CurrencyGHS,
        CurrencyGIP,
        CurrencyGMD,
        CurrencyGNF,
        CurrencyGTQ,
        CurrencyGYD,
        CurrencyHKD,
        CurrencyHNL,
        CurrencyHRK,
        CurrencyHTG,
        CurrencyHUF,
        CurrencyIDR,
        CurrencyILS,
        CurrencyIMP,
        CurrencyINR,
        CurrencyIQD,
        CurrencyIRR,
        CurrencyISK,
        CurrencyJEP,
        CurrencyJMD,
        CurrencyJOD,
        CurrencyJPY,
        CurrencyKES,
        CurrencyKGS,
        CurrencyKHR,
        CurrencyKMF,
        CurrencyKPW,
        CurrencyKRW,
        CurrencyKWD,
        CurrencyKYD,
        CurrencyKZT,
        CurrencyLAK,
        CurrencyLBP,
        CurrencyLKR,
        CurrencyLRD,
        CurrencyLSL,
        CurrencyLYD,
        CurrencyMAD,
        CurrencyMDL,
        CurrencyMGA,
        CurrencyMKD,
        CurrencyMMK,
        CurrencyMNT,
        CurrencyMOP,
        CurrencyMRO,
        CurrencyMUR,
        CurrencyMVR,
        CurrencyMWK,
        CurrencyMXN,
        CurrencyMYR,
        CurrencyMZN,
        CurrencyNAD,
        CurrencyNGN,
        CurrencyNIO,
        CurrencyNOK,
        CurrencyNPR,
        CurrencyNZD,
        CurrencyOMR,
        CurrencyPAB,
        CurrencyPEN,
        CurrencyPGK,
        CurrencyPHP,
        CurrencyPKR,
        CurrencyPLN,
        CurrencyPYG,
        CurrencyQAR,
        CurrencyRON,
        CurrencyRSD,
        CurrencyRUB,
        CurrencyRWF,
        CurrencySAR,
        CurrencySBD,
        CurrencySCR,
        CurrencySDG,
        CurrencySEK,
        CurrencySGD,
        CurrencySHP,
        CurrencySLL,
        CurrencySOS,
        CurrencySPL,
        CurrencySRD,
        CurrencySTD,
        CurrencySVC,
        CurrencySYP,
        CurrencySZL,
        CurrencyTHB,
        CurrencyTJS,
        CurrencyTMT,
        CurrencyTND,
        CurrencyTOP,
        CurrencyTRY,
        CurrencyTTD,
        CurrencyTVD,
        CurrencyTWD,
        CurrencyTZS,
        CurrencyUAH,
        CurrencyUGX,
        CurrencyUSD,
        CurrencyUYU,
        CurrencyUZS,
        CurrencyVEF,
        CurrencyVND,
        CurrencyVUV,
        CurrencyWST,
        CurrencyXAF,
        CurrencyXCD,
        CurrencyXDR,
        CurrencyXOF,
        CurrencyXPF,
        CurrencyYER,
        CurrencyZAR,
        CurrencyZMW,
        CurrencyZWD
    };

    PLAYFAB_API void writeCurrencyEnumJSON(Currency enumVal, JsonWriter& writer);
    PLAYFAB_API Currency readCurrencyFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFAB_API Currency readCurrencyFromValue(const FString& value);

    enum Region
    {
        RegionUSCentral,
        RegionUSEast,
        RegionEUWest,
        RegionSingapore,
        RegionJapan,
        RegionBrazil,
        RegionAustralia
    };

    PLAYFAB_API void writeRegionEnumJSON(Region enumVal, JsonWriter& writer);
    PLAYFAB_API Region readRegionFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFAB_API Region readRegionFromValue(const FString& value);

    struct PLAYFAB_API FCurrentGamesRequest : public FPlayFabBaseModel
    {
        // [optional] Build to match against.
        FString BuildVersion;

        // [optional] Game mode to look for.
        FString GameMode;

        // [optional] Region to check for Game Server Instances.
        Boxed<Region> pfRegion;

        // [optional] Statistic name to find statistic-based matches.
        FString StatisticName;

        // [optional] Filter to include and/or exclude Game Server Instances associated with certain tags.
        TSharedPtr<FCollectionFilter> TagFilter;

        FCurrentGamesRequest() :
            FPlayFabBaseModel(),
            BuildVersion(),
            GameMode(),
            pfRegion(),
            StatisticName(),
            TagFilter(nullptr)
            {}

        FCurrentGamesRequest(const FCurrentGamesRequest& src) :
            FPlayFabBaseModel(),
            BuildVersion(src.BuildVersion),
            GameMode(src.GameMode),
            pfRegion(src.pfRegion),
            StatisticName(src.StatisticName),
            TagFilter(src.TagFilter.IsValid() ? MakeShareable(new FCollectionFilter(*src.TagFilter)) : nullptr)
            {}

        FCurrentGamesRequest(const TSharedPtr<FJsonObject>& obj) : FCurrentGamesRequest()
        {
            readFromValue(obj);
        }

        ~FCurrentGamesRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    enum GameInstanceState
    {
        GameInstanceStateOpen,
        GameInstanceStateClosed
    };

    PLAYFAB_API void writeGameInstanceStateEnumJSON(GameInstanceState enumVal, JsonWriter& writer);
    PLAYFAB_API GameInstanceState readGameInstanceStateFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFAB_API GameInstanceState readGameInstanceStateFromValue(const FString& value);

    struct PLAYFAB_API FGameInfo : public FPlayFabBaseModel
    {
        // [optional] build version this server is running
        FString BuildVersion;

        // [optional] game mode this server is running
        FString GameMode;

        // [optional] game session custom data
        FString GameServerData;

        // [optional] game specific string denoting server configuration
        Boxed<GameInstanceState> GameServerStateEnum;

        // [optional] last heartbeat of the game server instance, used in external game server provider mode
        Boxed<FDateTime> LastHeartbeat;

        // [optional] unique lobby identifier for this game server
        FString LobbyID;

        // [optional] maximum players this server can support
        Boxed<int32> MaxPlayers;

        // [optional] array of current player IDs on this server
        TArray<FString> PlayerUserIds;
        // [optional] region to which this server is associated
        Boxed<Region> pfRegion;

        // duration in seconds this server has been running
        uint32 RunTime;

        // [optional] IPV4 address of the server
        FString ServerHostname;

        // [optional] IPV6 address of the server
        FString ServerIPV6Address;

        // [optional] port number to use for non-http communications with the server
        Boxed<int32> ServerPort;

        // [optional] stastic used to match this game in player statistic matchmaking
        FString StatisticName;

        // [optional] game session tags
        TMap<FString, FString> Tags;
        FGameInfo() :
            FPlayFabBaseModel(),
            BuildVersion(),
            GameMode(),
            GameServerData(),
            GameServerStateEnum(),
            LastHeartbeat(),
            LobbyID(),
            MaxPlayers(),
            PlayerUserIds(),
            pfRegion(),
            RunTime(0),
            ServerHostname(),
            ServerIPV6Address(),
            ServerPort(),
            StatisticName(),
            Tags()
            {}

        FGameInfo(const FGameInfo& src) :
            FPlayFabBaseModel(),
            BuildVersion(src.BuildVersion),
            GameMode(src.GameMode),
            GameServerData(src.GameServerData),
            GameServerStateEnum(src.GameServerStateEnum),
            LastHeartbeat(src.LastHeartbeat),
            LobbyID(src.LobbyID),
            MaxPlayers(src.MaxPlayers),
            PlayerUserIds(src.PlayerUserIds),
            pfRegion(src.pfRegion),
            RunTime(src.RunTime),
            ServerHostname(src.ServerHostname),
            ServerIPV6Address(src.ServerIPV6Address),
            ServerPort(src.ServerPort),
            StatisticName(src.StatisticName),
            Tags(src.Tags)
            {}

        FGameInfo(const TSharedPtr<FJsonObject>& obj) : FGameInfo()
        {
            readFromValue(obj);
        }

        ~FGameInfo();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FCurrentGamesResult : public FPlayFabBaseModel
    {
        // number of games running
        int32 GameCount;

        // [optional] array of games found
        TArray<FGameInfo> Games;
        // total number of players across all servers
        int32 PlayerCount;

        FCurrentGamesResult() :
            FPlayFabBaseModel(),
            GameCount(0),
            Games(),
            PlayerCount(0)
            {}

        FCurrentGamesResult(const FCurrentGamesResult& src) :
            FPlayFabBaseModel(),
            GameCount(src.GameCount),
            Games(src.Games),
            PlayerCount(src.PlayerCount)
            {}

        FCurrentGamesResult(const TSharedPtr<FJsonObject>& obj) : FCurrentGamesResult()
        {
            readFromValue(obj);
        }

        ~FCurrentGamesResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FDeviceInfoRequest : public FPlayFabBaseModel
    {
        // [optional] Information posted to the PlayStream Event. Currently arbitrary, and specific to the environment sending it.
        TMap<FString, FJsonKeeper> Info;
        FDeviceInfoRequest() :
            FPlayFabBaseModel(),
            Info()
            {}

        FDeviceInfoRequest(const FDeviceInfoRequest& src) :
            FPlayFabBaseModel(),
            Info(src.Info)
            {}

        FDeviceInfoRequest(const TSharedPtr<FJsonObject>& obj) : FDeviceInfoRequest()
        {
            readFromValue(obj);
        }

        ~FDeviceInfoRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FEmptyResult : public FPlayFabBaseModel
    {
        FEmptyResult() :
            FPlayFabBaseModel()
            {}

        FEmptyResult(const FEmptyResult& src) :
            FPlayFabBaseModel()
            {}

        FEmptyResult(const TSharedPtr<FJsonObject>& obj) : FEmptyResult()
        {
            readFromValue(obj);
        }

        ~FEmptyResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    enum EntityTypes
    {
        EntityTypestitle,
        EntityTypesmaster_player_account,
        EntityTypestitle_player_account,
        EntityTypescharacter,
        EntityTypesgroup
    };

    PLAYFAB_API void writeEntityTypesEnumJSON(EntityTypes enumVal, JsonWriter& writer);
    PLAYFAB_API EntityTypes readEntityTypesFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFAB_API EntityTypes readEntityTypesFromValue(const FString& value);

    struct PLAYFAB_API FEntityKey : public FPlayFabBaseModel
    {
        // Entity profile ID.
        FString Id;

        // [optional] Entity type. Optional to be used but one of EntityType or EntityTypeString must be set.
        Boxed<EntityTypes> Type;

        // [optional] Entity type. Optional to be used but one of EntityType or EntityTypeString must be set.
        FString TypeString;

        FEntityKey() :
            FPlayFabBaseModel(),
            Id(),
            Type(),
            TypeString()
            {}

        FEntityKey(const FEntityKey& src) :
            FPlayFabBaseModel(),
            Id(src.Id),
            Type(src.Type),
            TypeString(src.TypeString)
            {}

        FEntityKey(const TSharedPtr<FJsonObject>& obj) : FEntityKey()
        {
            readFromValue(obj);
        }

        ~FEntityKey();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FEntityTokenResponse : public FPlayFabBaseModel
    {
        // [optional] The entity id and type.
        TSharedPtr<FEntityKey> Entity;

        // [optional] The token used to set X-EntityToken for all entity based API calls.
        FString EntityToken;

        // [optional] The time the token will expire, if it is an expiring token, in UTC.
        Boxed<FDateTime> TokenExpiration;

        FEntityTokenResponse() :
            FPlayFabBaseModel(),
            Entity(nullptr),
            EntityToken(),
            TokenExpiration()
            {}

        FEntityTokenResponse(const FEntityTokenResponse& src) :
            FPlayFabBaseModel(),
            Entity(src.Entity.IsValid() ? MakeShareable(new FEntityKey(*src.Entity)) : nullptr),
            EntityToken(src.EntityToken),
            TokenExpiration(src.TokenExpiration)
            {}

        FEntityTokenResponse(const TSharedPtr<FJsonObject>& obj) : FEntityTokenResponse()
        {
            readFromValue(obj);
        }

        ~FEntityTokenResponse();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FExecuteCloudScriptRequest : public FPlayFabBaseModel
    {
        // The name of the CloudScript function to execute
        FString FunctionName;

        // [optional] Object that is passed in to the function as the first argument
        FJsonKeeper FunctionParameter;

        /**
         * [optional] Generate a 'player_executed_cloudscript' PlayStream event containing the results of the function execution and other
         * contextual information. This event will show up in the PlayStream debugger console for the player in Game Manager.
         */
        Boxed<bool> GeneratePlayStreamEvent;

        /**
         * [optional] Option for which revision of the CloudScript to execute. 'Latest' executes the most recently created revision, 'Live'
         * executes the current live, published revision, and 'Specific' executes the specified revision. The default value is
         * 'Specific', if the SpeificRevision parameter is specified, otherwise it is 'Live'.
         */
        Boxed<CloudScriptRevisionOption> RevisionSelection;

        // [optional] The specivic revision to execute, when RevisionSelection is set to 'Specific'
        Boxed<int32> SpecificRevision;

        FExecuteCloudScriptRequest() :
            FPlayFabBaseModel(),
            FunctionName(),
            FunctionParameter(),
            GeneratePlayStreamEvent(),
            RevisionSelection(),
            SpecificRevision()
            {}

        FExecuteCloudScriptRequest(const FExecuteCloudScriptRequest& src) :
            FPlayFabBaseModel(),
            FunctionName(src.FunctionName),
            FunctionParameter(src.FunctionParameter),
            GeneratePlayStreamEvent(src.GeneratePlayStreamEvent),
            RevisionSelection(src.RevisionSelection),
            SpecificRevision(src.SpecificRevision)
            {}

        FExecuteCloudScriptRequest(const TSharedPtr<FJsonObject>& obj) : FExecuteCloudScriptRequest()
        {
            readFromValue(obj);
        }

        ~FExecuteCloudScriptRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FScriptExecutionError : public FPlayFabBaseModel
    {
        /**
         * [optional] Error code, such as CloudScriptNotFound, JavascriptException, CloudScriptFunctionArgumentSizeExceeded,
         * CloudScriptAPIRequestCountExceeded, CloudScriptAPIRequestError, or CloudScriptHTTPRequestError
         */
        FString Error;

        // [optional] Details about the error
        FString Message;

        // [optional] Point during the execution of the script at which the error occurred, if any
        FString StackTrace;

        FScriptExecutionError() :
            FPlayFabBaseModel(),
            Error(),
            Message(),
            StackTrace()
            {}

        FScriptExecutionError(const FScriptExecutionError& src) :
            FPlayFabBaseModel(),
            Error(src.Error),
            Message(src.Message),
            StackTrace(src.StackTrace)
            {}

        FScriptExecutionError(const TSharedPtr<FJsonObject>& obj) : FScriptExecutionError()
        {
            readFromValue(obj);
        }

        ~FScriptExecutionError();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FLogStatement : public FPlayFabBaseModel
    {
        // [optional] Optional object accompanying the message as contextual information
        FJsonKeeper Data;

        // [optional] 'Debug', 'Info', or 'Error'
        FString Level;

        // [optional] undefined
        FString Message;

        FLogStatement() :
            FPlayFabBaseModel(),
            Data(),
            Level(),
            Message()
            {}

        FLogStatement(const FLogStatement& src) :
            FPlayFabBaseModel(),
            Data(src.Data),
            Level(src.Level),
            Message(src.Message)
            {}

        FLogStatement(const TSharedPtr<FJsonObject>& obj) : FLogStatement()
        {
            readFromValue(obj);
        }

        ~FLogStatement();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FExecuteCloudScriptResult : public FPlayFabBaseModel
    {
        // Number of PlayFab API requests issued by the CloudScript function
        int32 APIRequestsIssued;

        // [optional] Information about the error, if any, that occurred during execution
        TSharedPtr<FScriptExecutionError> Error;

        double ExecutionTimeSeconds;

        // [optional] The name of the function that executed
        FString FunctionName;

        // [optional] The object returned from the CloudScript function, if any
        FJsonKeeper FunctionResult;

        /**
         * [optional] Flag indicating if the FunctionResult was too large and was subsequently dropped from this event. This only occurs if
         * the total event size is larger than 350KB.
         */
        Boxed<bool> FunctionResultTooLarge;

        // Number of external HTTP requests issued by the CloudScript function
        int32 HttpRequestsIssued;

        /**
         * [optional] Entries logged during the function execution. These include both entries logged in the function code using log.info()
         * and log.error() and error entries for API and HTTP request failures.
         */
        TArray<FLogStatement> Logs;
        /**
         * [optional] Flag indicating if the logs were too large and were subsequently dropped from this event. This only occurs if the total
         * event size is larger than 350KB after the FunctionResult was removed.
         */
        Boxed<bool> LogsTooLarge;

        uint32 MemoryConsumedBytes;

        /**
         * Processor time consumed while executing the function. This does not include time spent waiting on API calls or HTTP
         * requests.
         */
        double ProcessorTimeSeconds;

        // The revision of the CloudScript that executed
        int32 Revision;

        FExecuteCloudScriptResult() :
            FPlayFabBaseModel(),
            APIRequestsIssued(0),
            Error(nullptr),
            ExecutionTimeSeconds(0),
            FunctionName(),
            FunctionResult(),
            FunctionResultTooLarge(),
            HttpRequestsIssued(0),
            Logs(),
            LogsTooLarge(),
            MemoryConsumedBytes(0),
            ProcessorTimeSeconds(0),
            Revision(0)
            {}

        FExecuteCloudScriptResult(const FExecuteCloudScriptResult& src) :
            FPlayFabBaseModel(),
            APIRequestsIssued(src.APIRequestsIssued),
            Error(src.Error.IsValid() ? MakeShareable(new FScriptExecutionError(*src.Error)) : nullptr),
            ExecutionTimeSeconds(src.ExecutionTimeSeconds),
            FunctionName(src.FunctionName),
            FunctionResult(src.FunctionResult),
            FunctionResultTooLarge(src.FunctionResultTooLarge),
            HttpRequestsIssued(src.HttpRequestsIssued),
            Logs(src.Logs),
            LogsTooLarge(src.LogsTooLarge),
            MemoryConsumedBytes(src.MemoryConsumedBytes),
            ProcessorTimeSeconds(src.ProcessorTimeSeconds),
            Revision(src.Revision)
            {}

        FExecuteCloudScriptResult(const TSharedPtr<FJsonObject>& obj) : FExecuteCloudScriptResult()
        {
            readFromValue(obj);
        }

        ~FExecuteCloudScriptResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FFacebookPlayFabIdPair : public FPlayFabBaseModel
    {
        // [optional] Unique Facebook identifier for a user.
        FString FacebookId;

        // [optional] Unique PlayFab identifier for a user, or null if no PlayFab account is linked to the Facebook identifier.
        FString PlayFabId;

        FFacebookPlayFabIdPair() :
            FPlayFabBaseModel(),
            FacebookId(),
            PlayFabId()
            {}

        FFacebookPlayFabIdPair(const FFacebookPlayFabIdPair& src) :
            FPlayFabBaseModel(),
            FacebookId(src.FacebookId),
            PlayFabId(src.PlayFabId)
            {}

        FFacebookPlayFabIdPair(const TSharedPtr<FJsonObject>& obj) : FFacebookPlayFabIdPair()
        {
            readFromValue(obj);
        }

        ~FFacebookPlayFabIdPair();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUserFacebookInfo : public FPlayFabBaseModel
    {
        // [optional] Facebook identifier
        FString FacebookId;

        // [optional] Facebook full name
        FString FullName;

        FUserFacebookInfo() :
            FPlayFabBaseModel(),
            FacebookId(),
            FullName()
            {}

        FUserFacebookInfo(const FUserFacebookInfo& src) :
            FPlayFabBaseModel(),
            FacebookId(src.FacebookId),
            FullName(src.FullName)
            {}

        FUserFacebookInfo(const TSharedPtr<FJsonObject>& obj) : FUserFacebookInfo()
        {
            readFromValue(obj);
        }

        ~FUserFacebookInfo();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUserGameCenterInfo : public FPlayFabBaseModel
    {
        // [optional] Gamecenter identifier
        FString GameCenterId;

        FUserGameCenterInfo() :
            FPlayFabBaseModel(),
            GameCenterId()
            {}

        FUserGameCenterInfo(const FUserGameCenterInfo& src) :
            FPlayFabBaseModel(),
            GameCenterId(src.GameCenterId)
            {}

        FUserGameCenterInfo(const TSharedPtr<FJsonObject>& obj) : FUserGameCenterInfo()
        {
            readFromValue(obj);
        }

        ~FUserGameCenterInfo();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    enum LoginIdentityProvider
    {
        LoginIdentityProviderUnknown,
        LoginIdentityProviderPlayFab,
        LoginIdentityProviderCustom,
        LoginIdentityProviderGameCenter,
        LoginIdentityProviderGooglePlay,
        LoginIdentityProviderSteam,
        LoginIdentityProviderXBoxLive,
        LoginIdentityProviderPSN,
        LoginIdentityProviderKongregate,
        LoginIdentityProviderFacebook,
        LoginIdentityProviderIOSDevice,
        LoginIdentityProviderAndroidDevice,
        LoginIdentityProviderTwitch,
        LoginIdentityProviderWindowsHello
    };

    PLAYFAB_API void writeLoginIdentityProviderEnumJSON(LoginIdentityProvider enumVal, JsonWriter& writer);
    PLAYFAB_API LoginIdentityProvider readLoginIdentityProviderFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFAB_API LoginIdentityProvider readLoginIdentityProviderFromValue(const FString& value);

    struct PLAYFAB_API FLinkedPlatformAccountModel : public FPlayFabBaseModel
    {
        // [optional] Linked account email of the user on the platform, if available
        FString Email;

        // [optional] Authentication platform
        Boxed<LoginIdentityProvider> Platform;

        // [optional] Unique account identifier of the user on the platform
        FString PlatformUserId;

        // [optional] Linked account username of the user on the platform, if available
        FString Username;

        FLinkedPlatformAccountModel() :
            FPlayFabBaseModel(),
            Email(),
            Platform(),
            PlatformUserId(),
            Username()
            {}

        FLinkedPlatformAccountModel(const FLinkedPlatformAccountModel& src) :
            FPlayFabBaseModel(),
            Email(src.Email),
            Platform(src.Platform),
            PlatformUserId(src.PlatformUserId),
            Username(src.Username)
            {}

        FLinkedPlatformAccountModel(const TSharedPtr<FJsonObject>& obj) : FLinkedPlatformAccountModel()
        {
            readFromValue(obj);
        }

        ~FLinkedPlatformAccountModel();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FLocationModel : public FPlayFabBaseModel
    {
        // [optional] City name.
        FString City;

        // [optional] The two-character continent code for this location
        Boxed<ContinentCode> pfContinentCode;

        // [optional] The two-character ISO 3166-1 country code for the country associated with the location
        Boxed<CountryCode> pfCountryCode;

        // [optional] Latitude coordinate of the geographic location.
        Boxed<double> Latitude;

        // [optional] Longitude coordinate of the geographic location.
        Boxed<double> Longitude;

        FLocationModel() :
            FPlayFabBaseModel(),
            City(),
            pfContinentCode(),
            pfCountryCode(),
            Latitude(),
            Longitude()
            {}

        FLocationModel(const FLocationModel& src) :
            FPlayFabBaseModel(),
            City(src.City),
            pfContinentCode(src.pfContinentCode),
            pfCountryCode(src.pfCountryCode),
            Latitude(src.Latitude),
            Longitude(src.Longitude)
            {}

        FLocationModel(const TSharedPtr<FJsonObject>& obj) : FLocationModel()
        {
            readFromValue(obj);
        }

        ~FLocationModel();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    enum SubscriptionProviderStatus
    {
        SubscriptionProviderStatusNoError,
        SubscriptionProviderStatusCancelled,
        SubscriptionProviderStatusUnknownError,
        SubscriptionProviderStatusBillingError,
        SubscriptionProviderStatusProductUnavailable,
        SubscriptionProviderStatusCustomerDidNotAcceptPriceChange,
        SubscriptionProviderStatusFreeTrial,
        SubscriptionProviderStatusPaymentPending
    };

    PLAYFAB_API void writeSubscriptionProviderStatusEnumJSON(SubscriptionProviderStatus enumVal, JsonWriter& writer);
    PLAYFAB_API SubscriptionProviderStatus readSubscriptionProviderStatusFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFAB_API SubscriptionProviderStatus readSubscriptionProviderStatusFromValue(const FString& value);

    struct PLAYFAB_API FSubscriptionModel : public FPlayFabBaseModel
    {
        // When this subscription expires.
        FDateTime Expiration;

        // The time the subscription was orignially purchased
        FDateTime InitialSubscriptionTime;

        // Whether this subscription is currently active. That is, if Expiration > now.
        bool IsActive;

        // [optional] The status of this subscription, according to the subscription provider.
        Boxed<SubscriptionProviderStatus> Status;

        // [optional] The id for this subscription
        FString SubscriptionId;

        // [optional] The item id for this subscription from the primary catalog
        FString SubscriptionItemId;

        // [optional] The provider for this subscription. Apple or Google Play are supported today.
        FString SubscriptionProvider;

        FSubscriptionModel() :
            FPlayFabBaseModel(),
            Expiration(0),
            InitialSubscriptionTime(0),
            IsActive(false),
            Status(),
            SubscriptionId(),
            SubscriptionItemId(),
            SubscriptionProvider()
            {}

        FSubscriptionModel(const FSubscriptionModel& src) :
            FPlayFabBaseModel(),
            Expiration(src.Expiration),
            InitialSubscriptionTime(src.InitialSubscriptionTime),
            IsActive(src.IsActive),
            Status(src.Status),
            SubscriptionId(src.SubscriptionId),
            SubscriptionItemId(src.SubscriptionItemId),
            SubscriptionProvider(src.SubscriptionProvider)
            {}

        FSubscriptionModel(const TSharedPtr<FJsonObject>& obj) : FSubscriptionModel()
        {
            readFromValue(obj);
        }

        ~FSubscriptionModel();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FMembershipModel : public FPlayFabBaseModel
    {
        // Whether this membership is active. That is, whether the MembershipExpiration time has been reached.
        bool IsActive;

        // The time this membership expires
        FDateTime MembershipExpiration;

        // [optional] The id of the membership
        FString MembershipId;

        /**
         * [optional] Membership expirations can be explicitly overridden (via game manager or the admin api). If this membership has been
         * overridden, this will be the new expiration time.
         */
        Boxed<FDateTime> OverrideExpiration;

        // [optional] Whether the override expiration is set.
        Boxed<bool> OverrideIsSet;

        // [optional] The list of subscriptions that this player has for this membership
        TArray<FSubscriptionModel> Subscriptions;
        FMembershipModel() :
            FPlayFabBaseModel(),
            IsActive(false),
            MembershipExpiration(0),
            MembershipId(),
            OverrideExpiration(),
            OverrideIsSet(),
            Subscriptions()
            {}

        FMembershipModel(const FMembershipModel& src) :
            FPlayFabBaseModel(),
            IsActive(src.IsActive),
            MembershipExpiration(src.MembershipExpiration),
            MembershipId(src.MembershipId),
            OverrideExpiration(src.OverrideExpiration),
            OverrideIsSet(src.OverrideIsSet),
            Subscriptions(src.Subscriptions)
            {}

        FMembershipModel(const TSharedPtr<FJsonObject>& obj) : FMembershipModel()
        {
            readFromValue(obj);
        }

        ~FMembershipModel();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    enum PushNotificationPlatform
    {
        PushNotificationPlatformApplePushNotificationService,
        PushNotificationPlatformGoogleCloudMessaging
    };

    PLAYFAB_API void writePushNotificationPlatformEnumJSON(PushNotificationPlatform enumVal, JsonWriter& writer);
    PLAYFAB_API PushNotificationPlatform readPushNotificationPlatformFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFAB_API PushNotificationPlatform readPushNotificationPlatformFromValue(const FString& value);

    struct PLAYFAB_API FPushNotificationRegistrationModel : public FPlayFabBaseModel
    {
        // [optional] Notification configured endpoint
        FString NotificationEndpointARN;

        // [optional] Push notification platform
        Boxed<PushNotificationPlatform> Platform;

        FPushNotificationRegistrationModel() :
            FPlayFabBaseModel(),
            NotificationEndpointARN(),
            Platform()
            {}

        FPushNotificationRegistrationModel(const FPushNotificationRegistrationModel& src) :
            FPlayFabBaseModel(),
            NotificationEndpointARN(src.NotificationEndpointARN),
            Platform(src.Platform)
            {}

        FPushNotificationRegistrationModel(const TSharedPtr<FJsonObject>& obj) : FPushNotificationRegistrationModel()
        {
            readFromValue(obj);
        }

        ~FPushNotificationRegistrationModel();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FStatisticModel : public FPlayFabBaseModel
    {
        // [optional] Statistic name
        FString Name;

        // Statistic value
        int32 Value;

        // Statistic version (0 if not a versioned statistic)
        int32 Version;

        FStatisticModel() :
            FPlayFabBaseModel(),
            Name(),
            Value(0),
            Version(0)
            {}

        FStatisticModel(const FStatisticModel& src) :
            FPlayFabBaseModel(),
            Name(src.Name),
            Value(src.Value),
            Version(src.Version)
            {}

        FStatisticModel(const TSharedPtr<FJsonObject>& obj) : FStatisticModel()
        {
            readFromValue(obj);
        }

        ~FStatisticModel();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FTagModel : public FPlayFabBaseModel
    {
        // [optional] Full value of the tag, including namespace
        FString TagValue;

        FTagModel() :
            FPlayFabBaseModel(),
            TagValue()
            {}

        FTagModel(const FTagModel& src) :
            FPlayFabBaseModel(),
            TagValue(src.TagValue)
            {}

        FTagModel(const TSharedPtr<FJsonObject>& obj) : FTagModel()
        {
            readFromValue(obj);
        }

        ~FTagModel();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FValueToDateModel : public FPlayFabBaseModel
    {
        // [optional] ISO 4217 code of the currency used in the purchases
        FString Currency;

        /**
         * Total value of the purchases in a whole number of 1/100 monetary units. For example, 999 indicates nine dollars and
         * ninety-nine cents when Currency is 'USD')
         */
        uint32 TotalValue;

        /**
         * [optional] Total value of the purchases in a string representation of decimal monetary units. For example, '9.99' indicates nine
         * dollars and ninety-nine cents when Currency is 'USD'.
         */
        FString TotalValueAsDecimal;

        FValueToDateModel() :
            FPlayFabBaseModel(),
            Currency(),
            TotalValue(0),
            TotalValueAsDecimal()
            {}

        FValueToDateModel(const FValueToDateModel& src) :
            FPlayFabBaseModel(),
            Currency(src.Currency),
            TotalValue(src.TotalValue),
            TotalValueAsDecimal(src.TotalValueAsDecimal)
            {}

        FValueToDateModel(const TSharedPtr<FJsonObject>& obj) : FValueToDateModel()
        {
            readFromValue(obj);
        }

        ~FValueToDateModel();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FPlayerProfileModel : public FPlayFabBaseModel
    {
        // [optional] List of advertising campaigns the player has been attributed to
        TArray<FAdCampaignAttributionModel> AdCampaignAttributions;
        // [optional] URL of the player's avatar image
        FString AvatarUrl;

        // [optional] If the player is currently banned, the UTC Date when the ban expires
        Boxed<FDateTime> BannedUntil;

        // [optional] List of all contact email info associated with the player account
        TArray<FContactEmailInfoModel> ContactEmailAddresses;
        // [optional] Player record created
        Boxed<FDateTime> Created;

        // [optional] Player display name
        FString DisplayName;

        // [optional] UTC time when the player most recently logged in to the title
        Boxed<FDateTime> LastLogin;

        // [optional] List of all authentication systems linked to this player account
        TArray<FLinkedPlatformAccountModel> LinkedAccounts;
        // [optional] List of geographic locations from which the player has logged in to the title
        TArray<FLocationModel> Locations;
        // [optional] List of memberships for the player, along with whether are expired.
        TArray<FMembershipModel> Memberships;
        // [optional] Player account origination
        Boxed<LoginIdentityProvider> Origination;

        // [optional] PlayFab player account unique identifier
        FString PlayerId;

        // [optional] Publisher this player belongs to
        FString PublisherId;

        // [optional] List of configured end points registered for sending the player push notifications
        TArray<FPushNotificationRegistrationModel> PushNotificationRegistrations;
        // [optional] List of leaderboard statistic values for the player
        TArray<FStatisticModel> Statistics;
        // [optional] List of player's tags for segmentation
        TArray<FTagModel> Tags;
        // [optional] Title ID this player profile applies to
        FString TitleId;

        /**
         * [optional] Sum of the player's purchases made with real-money currencies, converted to US dollars equivalent and represented as a
         * whole number of cents (1/100 USD).       For example, 999 indicates nine dollars and ninety-nine cents.
         */
        Boxed<uint32> TotalValueToDateInUSD;

        // [optional] List of the player's lifetime purchase totals, summed by real-money currency
        TArray<FValueToDateModel> ValuesToDate;
        FPlayerProfileModel() :
            FPlayFabBaseModel(),
            AdCampaignAttributions(),
            AvatarUrl(),
            BannedUntil(),
            ContactEmailAddresses(),
            Created(),
            DisplayName(),
            LastLogin(),
            LinkedAccounts(),
            Locations(),
            Memberships(),
            Origination(),
            PlayerId(),
            PublisherId(),
            PushNotificationRegistrations(),
            Statistics(),
            Tags(),
            TitleId(),
            TotalValueToDateInUSD(),
            ValuesToDate()
            {}

        FPlayerProfileModel(const FPlayerProfileModel& src) :
            FPlayFabBaseModel(),
            AdCampaignAttributions(src.AdCampaignAttributions),
            AvatarUrl(src.AvatarUrl),
            BannedUntil(src.BannedUntil),
            ContactEmailAddresses(src.ContactEmailAddresses),
            Created(src.Created),
            DisplayName(src.DisplayName),
            LastLogin(src.LastLogin),
            LinkedAccounts(src.LinkedAccounts),
            Locations(src.Locations),
            Memberships(src.Memberships),
            Origination(src.Origination),
            PlayerId(src.PlayerId),
            PublisherId(src.PublisherId),
            PushNotificationRegistrations(src.PushNotificationRegistrations),
            Statistics(src.Statistics),
            Tags(src.Tags),
            TitleId(src.TitleId),
            TotalValueToDateInUSD(src.TotalValueToDateInUSD),
            ValuesToDate(src.ValuesToDate)
            {}

        FPlayerProfileModel(const TSharedPtr<FJsonObject>& obj) : FPlayerProfileModel()
        {
            readFromValue(obj);
        }

        ~FPlayerProfileModel();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    enum TitleActivationStatus
    {
        TitleActivationStatusNone,
        TitleActivationStatusActivatedTitleKey,
        TitleActivationStatusPendingSteam,
        TitleActivationStatusActivatedSteam,
        TitleActivationStatusRevokedSteam
    };

    PLAYFAB_API void writeTitleActivationStatusEnumJSON(TitleActivationStatus enumVal, JsonWriter& writer);
    PLAYFAB_API TitleActivationStatus readTitleActivationStatusFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFAB_API TitleActivationStatus readTitleActivationStatusFromValue(const FString& value);

    struct PLAYFAB_API FUserSteamInfo : public FPlayFabBaseModel
    {
        // [optional] what stage of game ownership the user is listed as being in, from Steam
        Boxed<TitleActivationStatus> SteamActivationStatus;

        // [optional] the country in which the player resides, from Steam data
        FString SteamCountry;

        // [optional] currency type set in the user Steam account
        Boxed<Currency> SteamCurrency;

        // [optional] Steam identifier
        FString SteamId;

        FUserSteamInfo() :
            FPlayFabBaseModel(),
            SteamActivationStatus(),
            SteamCountry(),
            SteamCurrency(),
            SteamId()
            {}

        FUserSteamInfo(const FUserSteamInfo& src) :
            FPlayFabBaseModel(),
            SteamActivationStatus(src.SteamActivationStatus),
            SteamCountry(src.SteamCountry),
            SteamCurrency(src.SteamCurrency),
            SteamId(src.SteamId)
            {}

        FUserSteamInfo(const TSharedPtr<FJsonObject>& obj) : FUserSteamInfo()
        {
            readFromValue(obj);
        }

        ~FUserSteamInfo();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FFriendInfo : public FPlayFabBaseModel
    {
        // [optional] Unique lobby identifier of the Game Server Instance to which this player is currently connected.
        FString CurrentMatchmakerLobbyId;

        // [optional] Available Facebook information (if the user and PlayFab friend are also connected in Facebook).
        TSharedPtr<FUserFacebookInfo> FacebookInfo;

        // [optional] PlayFab unique identifier for this friend.
        FString FriendPlayFabId;

        // [optional] Available Game Center information (if the user and PlayFab friend are also connected in Game Center).
        TSharedPtr<FUserGameCenterInfo> GameCenterInfo;

        // [optional] The profile of the user, if requested.
        TSharedPtr<FPlayerProfileModel> Profile;

        // [optional] Available Steam information (if the user and PlayFab friend are also connected in Steam).
        TSharedPtr<FUserSteamInfo> SteamInfo;

        // [optional] Tags which have been associated with this friend.
        TArray<FString> Tags;
        // [optional] Title-specific display name for this friend.
        FString TitleDisplayName;

        // [optional] PlayFab unique username for this friend.
        FString Username;

        FFriendInfo() :
            FPlayFabBaseModel(),
            CurrentMatchmakerLobbyId(),
            FacebookInfo(nullptr),
            FriendPlayFabId(),
            GameCenterInfo(nullptr),
            Profile(nullptr),
            SteamInfo(nullptr),
            Tags(),
            TitleDisplayName(),
            Username()
            {}

        FFriendInfo(const FFriendInfo& src) :
            FPlayFabBaseModel(),
            CurrentMatchmakerLobbyId(src.CurrentMatchmakerLobbyId),
            FacebookInfo(src.FacebookInfo.IsValid() ? MakeShareable(new FUserFacebookInfo(*src.FacebookInfo)) : nullptr),
            FriendPlayFabId(src.FriendPlayFabId),
            GameCenterInfo(src.GameCenterInfo.IsValid() ? MakeShareable(new FUserGameCenterInfo(*src.GameCenterInfo)) : nullptr),
            Profile(src.Profile.IsValid() ? MakeShareable(new FPlayerProfileModel(*src.Profile)) : nullptr),
            SteamInfo(src.SteamInfo.IsValid() ? MakeShareable(new FUserSteamInfo(*src.SteamInfo)) : nullptr),
            Tags(src.Tags),
            TitleDisplayName(src.TitleDisplayName),
            Username(src.Username)
            {}

        FFriendInfo(const TSharedPtr<FJsonObject>& obj) : FFriendInfo()
        {
            readFromValue(obj);
        }

        ~FFriendInfo();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGameCenterPlayFabIdPair : public FPlayFabBaseModel
    {
        // [optional] Unique Game Center identifier for a user.
        FString GameCenterId;

        // [optional] Unique PlayFab identifier for a user, or null if no PlayFab account is linked to the Game Center identifier.
        FString PlayFabId;

        FGameCenterPlayFabIdPair() :
            FPlayFabBaseModel(),
            GameCenterId(),
            PlayFabId()
            {}

        FGameCenterPlayFabIdPair(const FGameCenterPlayFabIdPair& src) :
            FPlayFabBaseModel(),
            GameCenterId(src.GameCenterId),
            PlayFabId(src.PlayFabId)
            {}

        FGameCenterPlayFabIdPair(const TSharedPtr<FJsonObject>& obj) : FGameCenterPlayFabIdPair()
        {
            readFromValue(obj);
        }

        ~FGameCenterPlayFabIdPair();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGameServerRegionsRequest : public FPlayFabBaseModel
    {
        // version of game server for which stats are being requested
        FString BuildVersion;

        /**
         * [optional] Unique identifier for the title, found in the Settings > Game Properties section of the PlayFab developer site when a
         * title has been selected.
         */
        FString TitleId;

        FGameServerRegionsRequest() :
            FPlayFabBaseModel(),
            BuildVersion(),
            TitleId()
            {}

        FGameServerRegionsRequest(const FGameServerRegionsRequest& src) :
            FPlayFabBaseModel(),
            BuildVersion(src.BuildVersion),
            TitleId(src.TitleId)
            {}

        FGameServerRegionsRequest(const TSharedPtr<FJsonObject>& obj) : FGameServerRegionsRequest()
        {
            readFromValue(obj);
        }

        ~FGameServerRegionsRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FRegionInfo : public FPlayFabBaseModel
    {
        // indicates whether the server specified is available in this region
        bool Available;

        // [optional] name of the region
        FString Name;

        // [optional] url to ping to get roundtrip time
        FString PingUrl;

        // [optional] unique identifier for the region
        Boxed<Region> pfRegion;

        FRegionInfo() :
            FPlayFabBaseModel(),
            Available(false),
            Name(),
            PingUrl(),
            pfRegion()
            {}

        FRegionInfo(const FRegionInfo& src) :
            FPlayFabBaseModel(),
            Available(src.Available),
            Name(src.Name),
            PingUrl(src.PingUrl),
            pfRegion(src.pfRegion)
            {}

        FRegionInfo(const TSharedPtr<FJsonObject>& obj) : FRegionInfo()
        {
            readFromValue(obj);
        }

        ~FRegionInfo();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGameServerRegionsResult : public FPlayFabBaseModel
    {
        // [optional] array of regions found matching the request parameters
        TArray<FRegionInfo> Regions;
        FGameServerRegionsResult() :
            FPlayFabBaseModel(),
            Regions()
            {}

        FGameServerRegionsResult(const FGameServerRegionsResult& src) :
            FPlayFabBaseModel(),
            Regions(src.Regions)
            {}

        FGameServerRegionsResult(const TSharedPtr<FJsonObject>& obj) : FGameServerRegionsResult()
        {
            readFromValue(obj);
        }

        ~FGameServerRegionsResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGenericPlayFabIdPair : public FPlayFabBaseModel
    {
        // [optional] Unique generic service identifier for a user.
        TSharedPtr<FGenericServiceId> GenericId;

        // [optional] Unique PlayFab identifier for a user, or null if no PlayFab account is linked to the given generic identifier.
        FString PlayFabId;

        FGenericPlayFabIdPair() :
            FPlayFabBaseModel(),
            GenericId(nullptr),
            PlayFabId()
            {}

        FGenericPlayFabIdPair(const FGenericPlayFabIdPair& src) :
            FPlayFabBaseModel(),
            GenericId(src.GenericId.IsValid() ? MakeShareable(new FGenericServiceId(*src.GenericId)) : nullptr),
            PlayFabId(src.PlayFabId)
            {}

        FGenericPlayFabIdPair(const TSharedPtr<FJsonObject>& obj) : FGenericPlayFabIdPair()
        {
            readFromValue(obj);
        }

        ~FGenericPlayFabIdPair();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetAccountInfoRequest : public FPlayFabBaseModel
    {
        // [optional] User email address for the account to find (if no Username is specified).
        FString Email;

        /**
         * [optional] Unique PlayFab identifier of the user whose info is being requested. Optional, defaults to the authenticated user if no
         * other lookup identifier set.
         */
        FString PlayFabId;

        /**
         * [optional] Title-specific username for the account to find (if no Email is set). Note that if the non-unique Title Display Names
         * option is enabled for the title, attempts to look up users by Title Display Name will always return AccountNotFound.
         */
        FString TitleDisplayName;

        // [optional] PlayFab Username for the account to find (if no PlayFabId is specified).
        FString Username;

        FGetAccountInfoRequest() :
            FPlayFabBaseModel(),
            Email(),
            PlayFabId(),
            TitleDisplayName(),
            Username()
            {}

        FGetAccountInfoRequest(const FGetAccountInfoRequest& src) :
            FPlayFabBaseModel(),
            Email(src.Email),
            PlayFabId(src.PlayFabId),
            TitleDisplayName(src.TitleDisplayName),
            Username(src.Username)
            {}

        FGetAccountInfoRequest(const TSharedPtr<FJsonObject>& obj) : FGetAccountInfoRequest()
        {
            readFromValue(obj);
        }

        ~FGetAccountInfoRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUserAndroidDeviceInfo : public FPlayFabBaseModel
    {
        // [optional] Android device ID
        FString AndroidDeviceId;

        FUserAndroidDeviceInfo() :
            FPlayFabBaseModel(),
            AndroidDeviceId()
            {}

        FUserAndroidDeviceInfo(const FUserAndroidDeviceInfo& src) :
            FPlayFabBaseModel(),
            AndroidDeviceId(src.AndroidDeviceId)
            {}

        FUserAndroidDeviceInfo(const TSharedPtr<FJsonObject>& obj) : FUserAndroidDeviceInfo()
        {
            readFromValue(obj);
        }

        ~FUserAndroidDeviceInfo();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUserCustomIdInfo : public FPlayFabBaseModel
    {
        // [optional] Custom ID
        FString CustomId;

        FUserCustomIdInfo() :
            FPlayFabBaseModel(),
            CustomId()
            {}

        FUserCustomIdInfo(const FUserCustomIdInfo& src) :
            FPlayFabBaseModel(),
            CustomId(src.CustomId)
            {}

        FUserCustomIdInfo(const TSharedPtr<FJsonObject>& obj) : FUserCustomIdInfo()
        {
            readFromValue(obj);
        }

        ~FUserCustomIdInfo();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUserGoogleInfo : public FPlayFabBaseModel
    {
        // [optional] Email address of the Google account
        FString GoogleEmail;

        // [optional] Gender information of the Google account
        FString GoogleGender;

        // [optional] Google ID
        FString GoogleId;

        // [optional] Locale of the Google account
        FString GoogleLocale;

        FUserGoogleInfo() :
            FPlayFabBaseModel(),
            GoogleEmail(),
            GoogleGender(),
            GoogleId(),
            GoogleLocale()
            {}

        FUserGoogleInfo(const FUserGoogleInfo& src) :
            FPlayFabBaseModel(),
            GoogleEmail(src.GoogleEmail),
            GoogleGender(src.GoogleGender),
            GoogleId(src.GoogleId),
            GoogleLocale(src.GoogleLocale)
            {}

        FUserGoogleInfo(const TSharedPtr<FJsonObject>& obj) : FUserGoogleInfo()
        {
            readFromValue(obj);
        }

        ~FUserGoogleInfo();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUserIosDeviceInfo : public FPlayFabBaseModel
    {
        // [optional] iOS device ID
        FString IosDeviceId;

        FUserIosDeviceInfo() :
            FPlayFabBaseModel(),
            IosDeviceId()
            {}

        FUserIosDeviceInfo(const FUserIosDeviceInfo& src) :
            FPlayFabBaseModel(),
            IosDeviceId(src.IosDeviceId)
            {}

        FUserIosDeviceInfo(const TSharedPtr<FJsonObject>& obj) : FUserIosDeviceInfo()
        {
            readFromValue(obj);
        }

        ~FUserIosDeviceInfo();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUserKongregateInfo : public FPlayFabBaseModel
    {
        // [optional] Kongregate ID
        FString KongregateId;

        // [optional] Kongregate Username
        FString KongregateName;

        FUserKongregateInfo() :
            FPlayFabBaseModel(),
            KongregateId(),
            KongregateName()
            {}

        FUserKongregateInfo(const FUserKongregateInfo& src) :
            FPlayFabBaseModel(),
            KongregateId(src.KongregateId),
            KongregateName(src.KongregateName)
            {}

        FUserKongregateInfo(const TSharedPtr<FJsonObject>& obj) : FUserKongregateInfo()
        {
            readFromValue(obj);
        }

        ~FUserKongregateInfo();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUserPrivateAccountInfo : public FPlayFabBaseModel
    {
        // [optional] user email address
        FString Email;

        FUserPrivateAccountInfo() :
            FPlayFabBaseModel(),
            Email()
            {}

        FUserPrivateAccountInfo(const FUserPrivateAccountInfo& src) :
            FPlayFabBaseModel(),
            Email(src.Email)
            {}

        FUserPrivateAccountInfo(const TSharedPtr<FJsonObject>& obj) : FUserPrivateAccountInfo()
        {
            readFromValue(obj);
        }

        ~FUserPrivateAccountInfo();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUserPsnInfo : public FPlayFabBaseModel
    {
        // [optional] PSN account ID
        FString PsnAccountId;

        // [optional] PSN online ID
        FString PsnOnlineId;

        FUserPsnInfo() :
            FPlayFabBaseModel(),
            PsnAccountId(),
            PsnOnlineId()
            {}

        FUserPsnInfo(const FUserPsnInfo& src) :
            FPlayFabBaseModel(),
            PsnAccountId(src.PsnAccountId),
            PsnOnlineId(src.PsnOnlineId)
            {}

        FUserPsnInfo(const TSharedPtr<FJsonObject>& obj) : FUserPsnInfo()
        {
            readFromValue(obj);
        }

        ~FUserPsnInfo();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    enum UserOrigination
    {
        UserOriginationOrganic,
        UserOriginationSteam,
        UserOriginationGoogle,
        UserOriginationAmazon,
        UserOriginationFacebook,
        UserOriginationKongregate,
        UserOriginationGamersFirst,
        UserOriginationUnknown,
        UserOriginationIOS,
        UserOriginationLoadTest,
        UserOriginationAndroid,
        UserOriginationPSN,
        UserOriginationGameCenter,
        UserOriginationCustomId,
        UserOriginationXboxLive,
        UserOriginationParse,
        UserOriginationTwitch,
        UserOriginationWindowsHello
    };

    PLAYFAB_API void writeUserOriginationEnumJSON(UserOrigination enumVal, JsonWriter& writer);
    PLAYFAB_API UserOrigination readUserOriginationFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFAB_API UserOrigination readUserOriginationFromValue(const FString& value);

    struct PLAYFAB_API FUserTitleInfo : public FPlayFabBaseModel
    {
        // [optional] URL to the player's avatar.
        FString AvatarUrl;

        /**
         * timestamp indicating when the user was first associated with this game (this can differ significantly from when the user
         * first registered with PlayFab)
         */
        FDateTime Created;

        // [optional] name of the user, as it is displayed in-game
        FString DisplayName;

        /**
         * [optional] timestamp indicating when the user first signed into this game (this can differ from the Created timestamp, as other
         * events, such as issuing a beta key to the user, can associate the title to the user)
         */
        Boxed<FDateTime> FirstLogin;

        // [optional] boolean indicating whether or not the user is currently banned for a title
        Boxed<bool> isBanned;

        // [optional] timestamp for the last user login for this title
        Boxed<FDateTime> LastLogin;

        // [optional] source by which the user first joined the game, if known
        Boxed<UserOrigination> Origination;

        // [optional] Title player account entity for this user
        TSharedPtr<FEntityKey> TitlePlayerAccount;

        FUserTitleInfo() :
            FPlayFabBaseModel(),
            AvatarUrl(),
            Created(0),
            DisplayName(),
            FirstLogin(),
            isBanned(),
            LastLogin(),
            Origination(),
            TitlePlayerAccount(nullptr)
            {}

        FUserTitleInfo(const FUserTitleInfo& src) :
            FPlayFabBaseModel(),
            AvatarUrl(src.AvatarUrl),
            Created(src.Created),
            DisplayName(src.DisplayName),
            FirstLogin(src.FirstLogin),
            isBanned(src.isBanned),
            LastLogin(src.LastLogin),
            Origination(src.Origination),
            TitlePlayerAccount(src.TitlePlayerAccount.IsValid() ? MakeShareable(new FEntityKey(*src.TitlePlayerAccount)) : nullptr)
            {}

        FUserTitleInfo(const TSharedPtr<FJsonObject>& obj) : FUserTitleInfo()
        {
            readFromValue(obj);
        }

        ~FUserTitleInfo();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUserTwitchInfo : public FPlayFabBaseModel
    {
        // [optional] Twitch ID
        FString TwitchId;

        // [optional] Twitch Username
        FString TwitchUserName;

        FUserTwitchInfo() :
            FPlayFabBaseModel(),
            TwitchId(),
            TwitchUserName()
            {}

        FUserTwitchInfo(const FUserTwitchInfo& src) :
            FPlayFabBaseModel(),
            TwitchId(src.TwitchId),
            TwitchUserName(src.TwitchUserName)
            {}

        FUserTwitchInfo(const TSharedPtr<FJsonObject>& obj) : FUserTwitchInfo()
        {
            readFromValue(obj);
        }

        ~FUserTwitchInfo();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUserXboxInfo : public FPlayFabBaseModel
    {
        // [optional] XBox user ID
        FString XboxUserId;

        FUserXboxInfo() :
            FPlayFabBaseModel(),
            XboxUserId()
            {}

        FUserXboxInfo(const FUserXboxInfo& src) :
            FPlayFabBaseModel(),
            XboxUserId(src.XboxUserId)
            {}

        FUserXboxInfo(const TSharedPtr<FJsonObject>& obj) : FUserXboxInfo()
        {
            readFromValue(obj);
        }

        ~FUserXboxInfo();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUserAccountInfo : public FPlayFabBaseModel
    {
        // [optional] User Android device information, if an Android device has been linked
        TSharedPtr<FUserAndroidDeviceInfo> AndroidDeviceInfo;

        // Timestamp indicating when the user account was created
        FDateTime Created;

        // [optional] Custom ID information, if a custom ID has been assigned
        TSharedPtr<FUserCustomIdInfo> CustomIdInfo;

        // [optional] User Facebook information, if a Facebook account has been linked
        TSharedPtr<FUserFacebookInfo> FacebookInfo;

        // [optional] User Gamecenter information, if a Gamecenter account has been linked
        TSharedPtr<FUserGameCenterInfo> GameCenterInfo;

        // [optional] User Google account information, if a Google account has been linked
        TSharedPtr<FUserGoogleInfo> GoogleInfo;

        // [optional] User iOS device information, if an iOS device has been linked
        TSharedPtr<FUserIosDeviceInfo> IosDeviceInfo;

        // [optional] User Kongregate account information, if a Kongregate account has been linked
        TSharedPtr<FUserKongregateInfo> KongregateInfo;

        // [optional] Unique identifier for the user account
        FString PlayFabId;

        // [optional] Personal information for the user which is considered more sensitive
        TSharedPtr<FUserPrivateAccountInfo> PrivateInfo;

        // [optional] User PSN account information, if a PSN account has been linked
        TSharedPtr<FUserPsnInfo> PsnInfo;

        // [optional] User Steam information, if a Steam account has been linked
        TSharedPtr<FUserSteamInfo> SteamInfo;

        // [optional] Title-specific information for the user account
        TSharedPtr<FUserTitleInfo> TitleInfo;

        // [optional] User Twitch account information, if a Twitch account has been linked
        TSharedPtr<FUserTwitchInfo> TwitchInfo;

        // [optional] User account name in the PlayFab service
        FString Username;

        // [optional] User XBox account information, if a XBox account has been linked
        TSharedPtr<FUserXboxInfo> XboxInfo;

        FUserAccountInfo() :
            FPlayFabBaseModel(),
            AndroidDeviceInfo(nullptr),
            Created(0),
            CustomIdInfo(nullptr),
            FacebookInfo(nullptr),
            GameCenterInfo(nullptr),
            GoogleInfo(nullptr),
            IosDeviceInfo(nullptr),
            KongregateInfo(nullptr),
            PlayFabId(),
            PrivateInfo(nullptr),
            PsnInfo(nullptr),
            SteamInfo(nullptr),
            TitleInfo(nullptr),
            TwitchInfo(nullptr),
            Username(),
            XboxInfo(nullptr)
            {}

        FUserAccountInfo(const FUserAccountInfo& src) :
            FPlayFabBaseModel(),
            AndroidDeviceInfo(src.AndroidDeviceInfo.IsValid() ? MakeShareable(new FUserAndroidDeviceInfo(*src.AndroidDeviceInfo)) : nullptr),
            Created(src.Created),
            CustomIdInfo(src.CustomIdInfo.IsValid() ? MakeShareable(new FUserCustomIdInfo(*src.CustomIdInfo)) : nullptr),
            FacebookInfo(src.FacebookInfo.IsValid() ? MakeShareable(new FUserFacebookInfo(*src.FacebookInfo)) : nullptr),
            GameCenterInfo(src.GameCenterInfo.IsValid() ? MakeShareable(new FUserGameCenterInfo(*src.GameCenterInfo)) : nullptr),
            GoogleInfo(src.GoogleInfo.IsValid() ? MakeShareable(new FUserGoogleInfo(*src.GoogleInfo)) : nullptr),
            IosDeviceInfo(src.IosDeviceInfo.IsValid() ? MakeShareable(new FUserIosDeviceInfo(*src.IosDeviceInfo)) : nullptr),
            KongregateInfo(src.KongregateInfo.IsValid() ? MakeShareable(new FUserKongregateInfo(*src.KongregateInfo)) : nullptr),
            PlayFabId(src.PlayFabId),
            PrivateInfo(src.PrivateInfo.IsValid() ? MakeShareable(new FUserPrivateAccountInfo(*src.PrivateInfo)) : nullptr),
            PsnInfo(src.PsnInfo.IsValid() ? MakeShareable(new FUserPsnInfo(*src.PsnInfo)) : nullptr),
            SteamInfo(src.SteamInfo.IsValid() ? MakeShareable(new FUserSteamInfo(*src.SteamInfo)) : nullptr),
            TitleInfo(src.TitleInfo.IsValid() ? MakeShareable(new FUserTitleInfo(*src.TitleInfo)) : nullptr),
            TwitchInfo(src.TwitchInfo.IsValid() ? MakeShareable(new FUserTwitchInfo(*src.TwitchInfo)) : nullptr),
            Username(src.Username),
            XboxInfo(src.XboxInfo.IsValid() ? MakeShareable(new FUserXboxInfo(*src.XboxInfo)) : nullptr)
            {}

        FUserAccountInfo(const TSharedPtr<FJsonObject>& obj) : FUserAccountInfo()
        {
            readFromValue(obj);
        }

        ~FUserAccountInfo();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetAccountInfoResult : public FPlayFabBaseModel
    {
        // [optional] Account information for the local user.
        TSharedPtr<FUserAccountInfo> AccountInfo;

        FGetAccountInfoResult() :
            FPlayFabBaseModel(),
            AccountInfo(nullptr)
            {}

        FGetAccountInfoResult(const FGetAccountInfoResult& src) :
            FPlayFabBaseModel(),
            AccountInfo(src.AccountInfo.IsValid() ? MakeShareable(new FUserAccountInfo(*src.AccountInfo)) : nullptr)
            {}

        FGetAccountInfoResult(const TSharedPtr<FJsonObject>& obj) : FGetAccountInfoResult()
        {
            readFromValue(obj);
        }

        ~FGetAccountInfoResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetCatalogItemsRequest : public FPlayFabBaseModel
    {
        // [optional] Which catalog is being requested. If null, uses the default catalog.
        FString CatalogVersion;

        FGetCatalogItemsRequest() :
            FPlayFabBaseModel(),
            CatalogVersion()
            {}

        FGetCatalogItemsRequest(const FGetCatalogItemsRequest& src) :
            FPlayFabBaseModel(),
            CatalogVersion(src.CatalogVersion)
            {}

        FGetCatalogItemsRequest(const TSharedPtr<FJsonObject>& obj) : FGetCatalogItemsRequest()
        {
            readFromValue(obj);
        }

        ~FGetCatalogItemsRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetCatalogItemsResult : public FPlayFabBaseModel
    {
        // [optional] Array of items which can be purchased.
        TArray<FCatalogItem> Catalog;
        FGetCatalogItemsResult() :
            FPlayFabBaseModel(),
            Catalog()
            {}

        FGetCatalogItemsResult(const FGetCatalogItemsResult& src) :
            FPlayFabBaseModel(),
            Catalog(src.Catalog)
            {}

        FGetCatalogItemsResult(const TSharedPtr<FJsonObject>& obj) : FGetCatalogItemsResult()
        {
            readFromValue(obj);
        }

        ~FGetCatalogItemsResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetCharacterDataRequest : public FPlayFabBaseModel
    {
        // Unique PlayFab assigned ID for a specific character owned by a user
        FString CharacterId;

        /**
         * [optional] The version that currently exists according to the caller. The call will return the data for all of the keys if the
         * version in the system is greater than this.
         */
        Boxed<uint32> IfChangedFromDataVersion;

        // [optional] Specific keys to search for in the custom user data.
        TArray<FString> Keys;
        // [optional] Unique PlayFab identifier of the user to load data for. Optional, defaults to yourself if not set.
        FString PlayFabId;

        FGetCharacterDataRequest() :
            FPlayFabBaseModel(),
            CharacterId(),
            IfChangedFromDataVersion(),
            Keys(),
            PlayFabId()
            {}

        FGetCharacterDataRequest(const FGetCharacterDataRequest& src) :
            FPlayFabBaseModel(),
            CharacterId(src.CharacterId),
            IfChangedFromDataVersion(src.IfChangedFromDataVersion),
            Keys(src.Keys),
            PlayFabId(src.PlayFabId)
            {}

        FGetCharacterDataRequest(const TSharedPtr<FJsonObject>& obj) : FGetCharacterDataRequest()
        {
            readFromValue(obj);
        }

        ~FGetCharacterDataRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    enum UserDataPermission
    {
        UserDataPermissionPrivate,
        UserDataPermissionPublic
    };

    PLAYFAB_API void writeUserDataPermissionEnumJSON(UserDataPermission enumVal, JsonWriter& writer);
    PLAYFAB_API UserDataPermission readUserDataPermissionFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFAB_API UserDataPermission readUserDataPermissionFromValue(const FString& value);

    struct PLAYFAB_API FUserDataRecord : public FPlayFabBaseModel
    {
        // Timestamp for when this data was last updated.
        FDateTime LastUpdated;

        /**
         * [optional] Indicates whether this data can be read by all users (public) or only the user (private). This is used for GetUserData
         * requests being made by one player about another player.
         */
        Boxed<UserDataPermission> Permission;

        // [optional] Data stored for the specified user data key.
        FString Value;

        FUserDataRecord() :
            FPlayFabBaseModel(),
            LastUpdated(0),
            Permission(),
            Value()
            {}

        FUserDataRecord(const FUserDataRecord& src) :
            FPlayFabBaseModel(),
            LastUpdated(src.LastUpdated),
            Permission(src.Permission),
            Value(src.Value)
            {}

        FUserDataRecord(const TSharedPtr<FJsonObject>& obj) : FUserDataRecord()
        {
            readFromValue(obj);
        }

        ~FUserDataRecord();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetCharacterDataResult : public FPlayFabBaseModel
    {
        // [optional] Unique PlayFab assigned ID for a specific character owned by a user
        FString CharacterId;

        // [optional] User specific data for this title.
        TMap<FString, FUserDataRecord> Data;
        /**
         * Indicates the current version of the data that has been set. This is incremented with every set call for that type of
         * data (read-only, internal, etc). This version can be provided in Get calls to find updated data.
         */
        uint32 DataVersion;

        FGetCharacterDataResult() :
            FPlayFabBaseModel(),
            CharacterId(),
            Data(),
            DataVersion(0)
            {}

        FGetCharacterDataResult(const FGetCharacterDataResult& src) :
            FPlayFabBaseModel(),
            CharacterId(src.CharacterId),
            Data(src.Data),
            DataVersion(src.DataVersion)
            {}

        FGetCharacterDataResult(const TSharedPtr<FJsonObject>& obj) : FGetCharacterDataResult()
        {
            readFromValue(obj);
        }

        ~FGetCharacterDataResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetCharacterInventoryRequest : public FPlayFabBaseModel
    {
        // [optional] Used to limit results to only those from a specific catalog version.
        FString CatalogVersion;

        // Unique PlayFab assigned ID for a specific character owned by a user
        FString CharacterId;

        FGetCharacterInventoryRequest() :
            FPlayFabBaseModel(),
            CatalogVersion(),
            CharacterId()
            {}

        FGetCharacterInventoryRequest(const FGetCharacterInventoryRequest& src) :
            FPlayFabBaseModel(),
            CatalogVersion(src.CatalogVersion),
            CharacterId(src.CharacterId)
            {}

        FGetCharacterInventoryRequest(const TSharedPtr<FJsonObject>& obj) : FGetCharacterInventoryRequest()
        {
            readFromValue(obj);
        }

        ~FGetCharacterInventoryRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FVirtualCurrencyRechargeTime : public FPlayFabBaseModel
    {
        /**
         * Maximum value to which the regenerating currency will automatically increment. Note that it can exceed this value
         * through use of the AddUserVirtualCurrency API call. However, it will not regenerate automatically until it has fallen
         * below this value.
         */
        int32 RechargeMax;

        // Server timestamp in UTC indicating the next time the virtual currency will be incremented.
        FDateTime RechargeTime;

        // Time remaining (in seconds) before the next recharge increment of the virtual currency.
        int32 SecondsToRecharge;

        FVirtualCurrencyRechargeTime() :
            FPlayFabBaseModel(),
            RechargeMax(0),
            RechargeTime(0),
            SecondsToRecharge(0)
            {}

        FVirtualCurrencyRechargeTime(const FVirtualCurrencyRechargeTime& src) :
            FPlayFabBaseModel(),
            RechargeMax(src.RechargeMax),
            RechargeTime(src.RechargeTime),
            SecondsToRecharge(src.SecondsToRecharge)
            {}

        FVirtualCurrencyRechargeTime(const TSharedPtr<FJsonObject>& obj) : FVirtualCurrencyRechargeTime()
        {
            readFromValue(obj);
        }

        ~FVirtualCurrencyRechargeTime();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetCharacterInventoryResult : public FPlayFabBaseModel
    {
        // [optional] Unique identifier of the character for this inventory.
        FString CharacterId;

        // [optional] Array of inventory items belonging to the character.
        TArray<FItemInstance> Inventory;
        // [optional] Array of virtual currency balance(s) belonging to the character.
        TMap<FString, int32> VirtualCurrency;
        // [optional] Array of remaining times and timestamps for virtual currencies.
        TMap<FString, FVirtualCurrencyRechargeTime> VirtualCurrencyRechargeTimes;
        FGetCharacterInventoryResult() :
            FPlayFabBaseModel(),
            CharacterId(),
            Inventory(),
            VirtualCurrency(),
            VirtualCurrencyRechargeTimes()
            {}

        FGetCharacterInventoryResult(const FGetCharacterInventoryResult& src) :
            FPlayFabBaseModel(),
            CharacterId(src.CharacterId),
            Inventory(src.Inventory),
            VirtualCurrency(src.VirtualCurrency),
            VirtualCurrencyRechargeTimes(src.VirtualCurrencyRechargeTimes)
            {}

        FGetCharacterInventoryResult(const TSharedPtr<FJsonObject>& obj) : FGetCharacterInventoryResult()
        {
            readFromValue(obj);
        }

        ~FGetCharacterInventoryResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetCharacterLeaderboardRequest : public FPlayFabBaseModel
    {
        // [optional] Optional character type on which to filter the leaderboard entries.
        FString CharacterType;

        // [optional] Maximum number of entries to retrieve. Default 10, maximum 100.
        Boxed<int32> MaxResultsCount;

        // First entry in the leaderboard to be retrieved.
        int32 StartPosition;

        // Unique identifier for the title-specific statistic for the leaderboard.
        FString StatisticName;

        FGetCharacterLeaderboardRequest() :
            FPlayFabBaseModel(),
            CharacterType(),
            MaxResultsCount(),
            StartPosition(0),
            StatisticName()
            {}

        FGetCharacterLeaderboardRequest(const FGetCharacterLeaderboardRequest& src) :
            FPlayFabBaseModel(),
            CharacterType(src.CharacterType),
            MaxResultsCount(src.MaxResultsCount),
            StartPosition(src.StartPosition),
            StatisticName(src.StatisticName)
            {}

        FGetCharacterLeaderboardRequest(const TSharedPtr<FJsonObject>& obj) : FGetCharacterLeaderboardRequest()
        {
            readFromValue(obj);
        }

        ~FGetCharacterLeaderboardRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetCharacterLeaderboardResult : public FPlayFabBaseModel
    {
        // [optional] Ordered list of leaderboard entries.
        TArray<FCharacterLeaderboardEntry> Leaderboard;
        FGetCharacterLeaderboardResult() :
            FPlayFabBaseModel(),
            Leaderboard()
            {}

        FGetCharacterLeaderboardResult(const FGetCharacterLeaderboardResult& src) :
            FPlayFabBaseModel(),
            Leaderboard(src.Leaderboard)
            {}

        FGetCharacterLeaderboardResult(const TSharedPtr<FJsonObject>& obj) : FGetCharacterLeaderboardResult()
        {
            readFromValue(obj);
        }

        ~FGetCharacterLeaderboardResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetCharacterStatisticsRequest : public FPlayFabBaseModel
    {
        // Unique PlayFab assigned ID for a specific character owned by a user
        FString CharacterId;

        FGetCharacterStatisticsRequest() :
            FPlayFabBaseModel(),
            CharacterId()
            {}

        FGetCharacterStatisticsRequest(const FGetCharacterStatisticsRequest& src) :
            FPlayFabBaseModel(),
            CharacterId(src.CharacterId)
            {}

        FGetCharacterStatisticsRequest(const TSharedPtr<FJsonObject>& obj) : FGetCharacterStatisticsRequest()
        {
            readFromValue(obj);
        }

        ~FGetCharacterStatisticsRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetCharacterStatisticsResult : public FPlayFabBaseModel
    {
        // [optional] The requested character statistics.
        TMap<FString, int32> CharacterStatistics;
        FGetCharacterStatisticsResult() :
            FPlayFabBaseModel(),
            CharacterStatistics()
            {}

        FGetCharacterStatisticsResult(const FGetCharacterStatisticsResult& src) :
            FPlayFabBaseModel(),
            CharacterStatistics(src.CharacterStatistics)
            {}

        FGetCharacterStatisticsResult(const TSharedPtr<FJsonObject>& obj) : FGetCharacterStatisticsResult()
        {
            readFromValue(obj);
        }

        ~FGetCharacterStatisticsResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetContentDownloadUrlRequest : public FPlayFabBaseModel
    {
        // [optional] HTTP method to fetch item - GET or HEAD. Use HEAD when only fetching metadata. Default is GET.
        FString HttpMethod;

        // Key of the content item to fetch, usually formatted as a path, e.g. images/a.png
        FString Key;

        /**
         * [optional] True to download through CDN. CDN provides higher download bandwidth and lower latency. However, if you want the latest,
         * non-cached version of the content during development, set this to false. Default is true.
         */
        Boxed<bool> ThruCDN;

        FGetContentDownloadUrlRequest() :
            FPlayFabBaseModel(),
            HttpMethod(),
            Key(),
            ThruCDN()
            {}

        FGetContentDownloadUrlRequest(const FGetContentDownloadUrlRequest& src) :
            FPlayFabBaseModel(),
            HttpMethod(src.HttpMethod),
            Key(src.Key),
            ThruCDN(src.ThruCDN)
            {}

        FGetContentDownloadUrlRequest(const TSharedPtr<FJsonObject>& obj) : FGetContentDownloadUrlRequest()
        {
            readFromValue(obj);
        }

        ~FGetContentDownloadUrlRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetContentDownloadUrlResult : public FPlayFabBaseModel
    {
        // [optional] URL for downloading content via HTTP GET or HEAD method. The URL will expire in approximately one hour.
        FString URL;

        FGetContentDownloadUrlResult() :
            FPlayFabBaseModel(),
            URL()
            {}

        FGetContentDownloadUrlResult(const FGetContentDownloadUrlResult& src) :
            FPlayFabBaseModel(),
            URL(src.URL)
            {}

        FGetContentDownloadUrlResult(const TSharedPtr<FJsonObject>& obj) : FGetContentDownloadUrlResult()
        {
            readFromValue(obj);
        }

        ~FGetContentDownloadUrlResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FPlayerProfileViewConstraints : public FPlayFabBaseModel
    {
        // Whether to show player's avatar URL. Defaults to false
        bool ShowAvatarUrl;

        // Whether to show the banned until time. Defaults to false
        bool ShowBannedUntil;

        // Whether to show campaign attributions. Defaults to false
        bool ShowCampaignAttributions;

        // Whether to show contact email addresses. Defaults to false
        bool ShowContactEmailAddresses;

        // Whether to show the created date. Defaults to false
        bool ShowCreated;

        // Whether to show the display name. Defaults to false
        bool ShowDisplayName;

        // Whether to show the last login time. Defaults to false
        bool ShowLastLogin;

        // Whether to show the linked accounts. Defaults to false
        bool ShowLinkedAccounts;

        // Whether to show player's locations. Defaults to false
        bool ShowLocations;

        // Whether to show player's membership information. Defaults to false
        bool ShowMemberships;

        // Whether to show origination. Defaults to false
        bool ShowOrigination;

        // Whether to show push notification registrations. Defaults to false
        bool ShowPushNotificationRegistrations;

        // Reserved for future development
        bool ShowStatistics;

        // Whether to show tags. Defaults to false
        bool ShowTags;

        // Whether to show the total value to date in usd. Defaults to false
        bool ShowTotalValueToDateInUsd;

        // Whether to show the values to date. Defaults to false
        bool ShowValuesToDate;

        FPlayerProfileViewConstraints() :
            FPlayFabBaseModel(),
            ShowAvatarUrl(false),
            ShowBannedUntil(false),
            ShowCampaignAttributions(false),
            ShowContactEmailAddresses(false),
            ShowCreated(false),
            ShowDisplayName(false),
            ShowLastLogin(false),
            ShowLinkedAccounts(false),
            ShowLocations(false),
            ShowMemberships(false),
            ShowOrigination(false),
            ShowPushNotificationRegistrations(false),
            ShowStatistics(false),
            ShowTags(false),
            ShowTotalValueToDateInUsd(false),
            ShowValuesToDate(false)
            {}

        FPlayerProfileViewConstraints(const FPlayerProfileViewConstraints& src) :
            FPlayFabBaseModel(),
            ShowAvatarUrl(src.ShowAvatarUrl),
            ShowBannedUntil(src.ShowBannedUntil),
            ShowCampaignAttributions(src.ShowCampaignAttributions),
            ShowContactEmailAddresses(src.ShowContactEmailAddresses),
            ShowCreated(src.ShowCreated),
            ShowDisplayName(src.ShowDisplayName),
            ShowLastLogin(src.ShowLastLogin),
            ShowLinkedAccounts(src.ShowLinkedAccounts),
            ShowLocations(src.ShowLocations),
            ShowMemberships(src.ShowMemberships),
            ShowOrigination(src.ShowOrigination),
            ShowPushNotificationRegistrations(src.ShowPushNotificationRegistrations),
            ShowStatistics(src.ShowStatistics),
            ShowTags(src.ShowTags),
            ShowTotalValueToDateInUsd(src.ShowTotalValueToDateInUsd),
            ShowValuesToDate(src.ShowValuesToDate)
            {}

        FPlayerProfileViewConstraints(const TSharedPtr<FJsonObject>& obj) : FPlayerProfileViewConstraints()
        {
            readFromValue(obj);
        }

        ~FPlayerProfileViewConstraints();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetFriendLeaderboardAroundPlayerRequest : public FPlayFabBaseModel
    {
        // [optional] Indicates whether Facebook friends should be included in the response. Default is true.
        Boxed<bool> IncludeFacebookFriends;

        // [optional] Indicates whether Steam service friends should be included in the response. Default is true.
        Boxed<bool> IncludeSteamFriends;

        // [optional] Maximum number of entries to retrieve. Default 10, maximum 100.
        Boxed<int32> MaxResultsCount;

        // [optional] PlayFab unique identifier of the user to center the leaderboard around. If null will center on the logged in user.
        FString PlayFabId;

        /**
         * [optional] If non-null, this determines which properties of the resulting player profiles to return. For API calls from the client,
         * only the allowed client profile properties for the title may be requested. These allowed properties are configured in
         * the Game Manager "Client Profile Options" tab in the "Settings" section.
         */
        TSharedPtr<FPlayerProfileViewConstraints> ProfileConstraints;

        // Statistic used to rank players for this leaderboard.
        FString StatisticName;

        // [optional] If set to false, Version is considered null. If true, uses the specified Version
        Boxed<bool> UseSpecificVersion;

        // [optional] The version of the leaderboard to get.
        Boxed<int32> Version;

        FGetFriendLeaderboardAroundPlayerRequest() :
            FPlayFabBaseModel(),
            IncludeFacebookFriends(),
            IncludeSteamFriends(),
            MaxResultsCount(),
            PlayFabId(),
            ProfileConstraints(nullptr),
            StatisticName(),
            UseSpecificVersion(),
            Version()
            {}

        FGetFriendLeaderboardAroundPlayerRequest(const FGetFriendLeaderboardAroundPlayerRequest& src) :
            FPlayFabBaseModel(),
            IncludeFacebookFriends(src.IncludeFacebookFriends),
            IncludeSteamFriends(src.IncludeSteamFriends),
            MaxResultsCount(src.MaxResultsCount),
            PlayFabId(src.PlayFabId),
            ProfileConstraints(src.ProfileConstraints.IsValid() ? MakeShareable(new FPlayerProfileViewConstraints(*src.ProfileConstraints)) : nullptr),
            StatisticName(src.StatisticName),
            UseSpecificVersion(src.UseSpecificVersion),
            Version(src.Version)
            {}

        FGetFriendLeaderboardAroundPlayerRequest(const TSharedPtr<FJsonObject>& obj) : FGetFriendLeaderboardAroundPlayerRequest()
        {
            readFromValue(obj);
        }

        ~FGetFriendLeaderboardAroundPlayerRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FPlayerLeaderboardEntry : public FPlayFabBaseModel
    {
        // [optional] Title-specific display name of the user for this leaderboard entry.
        FString DisplayName;

        // [optional] PlayFab unique identifier of the user for this leaderboard entry.
        FString PlayFabId;

        // User's overall position in the leaderboard.
        int32 Position;

        // [optional] The profile of the user, if requested.
        TSharedPtr<FPlayerProfileModel> Profile;

        // Specific value of the user's statistic.
        int32 StatValue;

        FPlayerLeaderboardEntry() :
            FPlayFabBaseModel(),
            DisplayName(),
            PlayFabId(),
            Position(0),
            Profile(nullptr),
            StatValue(0)
            {}

        FPlayerLeaderboardEntry(const FPlayerLeaderboardEntry& src) :
            FPlayFabBaseModel(),
            DisplayName(src.DisplayName),
            PlayFabId(src.PlayFabId),
            Position(src.Position),
            Profile(src.Profile.IsValid() ? MakeShareable(new FPlayerProfileModel(*src.Profile)) : nullptr),
            StatValue(src.StatValue)
            {}

        FPlayerLeaderboardEntry(const TSharedPtr<FJsonObject>& obj) : FPlayerLeaderboardEntry()
        {
            readFromValue(obj);
        }

        ~FPlayerLeaderboardEntry();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetFriendLeaderboardAroundPlayerResult : public FPlayFabBaseModel
    {
        // [optional] Ordered listing of users and their positions in the requested leaderboard.
        TArray<FPlayerLeaderboardEntry> Leaderboard;
        // [optional] The time the next scheduled reset will occur. Null if the leaderboard does not reset on a schedule.
        Boxed<FDateTime> NextReset;

        // The version of the leaderboard returned.
        int32 Version;

        FGetFriendLeaderboardAroundPlayerResult() :
            FPlayFabBaseModel(),
            Leaderboard(),
            NextReset(),
            Version(0)
            {}

        FGetFriendLeaderboardAroundPlayerResult(const FGetFriendLeaderboardAroundPlayerResult& src) :
            FPlayFabBaseModel(),
            Leaderboard(src.Leaderboard),
            NextReset(src.NextReset),
            Version(src.Version)
            {}

        FGetFriendLeaderboardAroundPlayerResult(const TSharedPtr<FJsonObject>& obj) : FGetFriendLeaderboardAroundPlayerResult()
        {
            readFromValue(obj);
        }

        ~FGetFriendLeaderboardAroundPlayerResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetFriendLeaderboardRequest : public FPlayFabBaseModel
    {
        // [optional] Indicates whether Facebook friends should be included in the response. Default is true.
        Boxed<bool> IncludeFacebookFriends;

        // [optional] Indicates whether Steam service friends should be included in the response. Default is true.
        Boxed<bool> IncludeSteamFriends;

        // [optional] Maximum number of entries to retrieve. Default 10, maximum 100.
        Boxed<int32> MaxResultsCount;

        /**
         * [optional] If non-null, this determines which properties of the resulting player profiles to return. For API calls from the client,
         * only the allowed client profile properties for the title may be requested. These allowed properties are configured in
         * the Game Manager "Client Profile Options" tab in the "Settings" section.
         */
        TSharedPtr<FPlayerProfileViewConstraints> ProfileConstraints;

        // Position in the leaderboard to start this listing (defaults to the first entry).
        int32 StartPosition;

        // Statistic used to rank friends for this leaderboard.
        FString StatisticName;

        // [optional] If set to false, Version is considered null. If true, uses the specified Version
        Boxed<bool> UseSpecificVersion;

        // [optional] The version of the leaderboard to get.
        Boxed<int32> Version;

        FGetFriendLeaderboardRequest() :
            FPlayFabBaseModel(),
            IncludeFacebookFriends(),
            IncludeSteamFriends(),
            MaxResultsCount(),
            ProfileConstraints(nullptr),
            StartPosition(0),
            StatisticName(),
            UseSpecificVersion(),
            Version()
            {}

        FGetFriendLeaderboardRequest(const FGetFriendLeaderboardRequest& src) :
            FPlayFabBaseModel(),
            IncludeFacebookFriends(src.IncludeFacebookFriends),
            IncludeSteamFriends(src.IncludeSteamFriends),
            MaxResultsCount(src.MaxResultsCount),
            ProfileConstraints(src.ProfileConstraints.IsValid() ? MakeShareable(new FPlayerProfileViewConstraints(*src.ProfileConstraints)) : nullptr),
            StartPosition(src.StartPosition),
            StatisticName(src.StatisticName),
            UseSpecificVersion(src.UseSpecificVersion),
            Version(src.Version)
            {}

        FGetFriendLeaderboardRequest(const TSharedPtr<FJsonObject>& obj) : FGetFriendLeaderboardRequest()
        {
            readFromValue(obj);
        }

        ~FGetFriendLeaderboardRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetFriendsListRequest : public FPlayFabBaseModel
    {
        // [optional] Indicates whether Facebook friends should be included in the response. Default is true.
        Boxed<bool> IncludeFacebookFriends;

        // [optional] Indicates whether Steam service friends should be included in the response. Default is true.
        Boxed<bool> IncludeSteamFriends;

        /**
         * [optional] If non-null, this determines which properties of the resulting player profiles to return. For API calls from the client,
         * only the allowed client profile properties for the title may be requested. These allowed properties are configured in
         * the Game Manager "Client Profile Options" tab in the "Settings" section.
         */
        TSharedPtr<FPlayerProfileViewConstraints> ProfileConstraints;

        FGetFriendsListRequest() :
            FPlayFabBaseModel(),
            IncludeFacebookFriends(),
            IncludeSteamFriends(),
            ProfileConstraints(nullptr)
            {}

        FGetFriendsListRequest(const FGetFriendsListRequest& src) :
            FPlayFabBaseModel(),
            IncludeFacebookFriends(src.IncludeFacebookFriends),
            IncludeSteamFriends(src.IncludeSteamFriends),
            ProfileConstraints(src.ProfileConstraints.IsValid() ? MakeShareable(new FPlayerProfileViewConstraints(*src.ProfileConstraints)) : nullptr)
            {}

        FGetFriendsListRequest(const TSharedPtr<FJsonObject>& obj) : FGetFriendsListRequest()
        {
            readFromValue(obj);
        }

        ~FGetFriendsListRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetFriendsListResult : public FPlayFabBaseModel
    {
        // [optional] Array of friends found.
        TArray<FFriendInfo> Friends;
        FGetFriendsListResult() :
            FPlayFabBaseModel(),
            Friends()
            {}

        FGetFriendsListResult(const FGetFriendsListResult& src) :
            FPlayFabBaseModel(),
            Friends(src.Friends)
            {}

        FGetFriendsListResult(const TSharedPtr<FJsonObject>& obj) : FGetFriendsListResult()
        {
            readFromValue(obj);
        }

        ~FGetFriendsListResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetLeaderboardAroundCharacterRequest : public FPlayFabBaseModel
    {
        // Unique PlayFab assigned ID for a specific character on which to center the leaderboard.
        FString CharacterId;

        // [optional] Optional character type on which to filter the leaderboard entries.
        FString CharacterType;

        // [optional] Maximum number of entries to retrieve. Default 10, maximum 100.
        Boxed<int32> MaxResultsCount;

        // Unique identifier for the title-specific statistic for the leaderboard.
        FString StatisticName;

        FGetLeaderboardAroundCharacterRequest() :
            FPlayFabBaseModel(),
            CharacterId(),
            CharacterType(),
            MaxResultsCount(),
            StatisticName()
            {}

        FGetLeaderboardAroundCharacterRequest(const FGetLeaderboardAroundCharacterRequest& src) :
            FPlayFabBaseModel(),
            CharacterId(src.CharacterId),
            CharacterType(src.CharacterType),
            MaxResultsCount(src.MaxResultsCount),
            StatisticName(src.StatisticName)
            {}

        FGetLeaderboardAroundCharacterRequest(const TSharedPtr<FJsonObject>& obj) : FGetLeaderboardAroundCharacterRequest()
        {
            readFromValue(obj);
        }

        ~FGetLeaderboardAroundCharacterRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetLeaderboardAroundCharacterResult : public FPlayFabBaseModel
    {
        // [optional] Ordered list of leaderboard entries.
        TArray<FCharacterLeaderboardEntry> Leaderboard;
        FGetLeaderboardAroundCharacterResult() :
            FPlayFabBaseModel(),
            Leaderboard()
            {}

        FGetLeaderboardAroundCharacterResult(const FGetLeaderboardAroundCharacterResult& src) :
            FPlayFabBaseModel(),
            Leaderboard(src.Leaderboard)
            {}

        FGetLeaderboardAroundCharacterResult(const TSharedPtr<FJsonObject>& obj) : FGetLeaderboardAroundCharacterResult()
        {
            readFromValue(obj);
        }

        ~FGetLeaderboardAroundCharacterResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetLeaderboardAroundPlayerRequest : public FPlayFabBaseModel
    {
        // [optional] Maximum number of entries to retrieve. Default 10, maximum 100.
        Boxed<int32> MaxResultsCount;

        // [optional] PlayFab unique identifier of the user to center the leaderboard around. If null will center on the logged in user.
        FString PlayFabId;

        /**
         * [optional] If non-null, this determines which properties of the resulting player profiles to return. For API calls from the client,
         * only the allowed client profile properties for the title may be requested. These allowed properties are configured in
         * the Game Manager "Client Profile Options" tab in the "Settings" section.
         */
        TSharedPtr<FPlayerProfileViewConstraints> ProfileConstraints;

        // Statistic used to rank players for this leaderboard.
        FString StatisticName;

        // [optional] If set to false, Version is considered null. If true, uses the specified Version
        Boxed<bool> UseSpecificVersion;

        // [optional] The version of the leaderboard to get.
        Boxed<int32> Version;

        FGetLeaderboardAroundPlayerRequest() :
            FPlayFabBaseModel(),
            MaxResultsCount(),
            PlayFabId(),
            ProfileConstraints(nullptr),
            StatisticName(),
            UseSpecificVersion(),
            Version()
            {}

        FGetLeaderboardAroundPlayerRequest(const FGetLeaderboardAroundPlayerRequest& src) :
            FPlayFabBaseModel(),
            MaxResultsCount(src.MaxResultsCount),
            PlayFabId(src.PlayFabId),
            ProfileConstraints(src.ProfileConstraints.IsValid() ? MakeShareable(new FPlayerProfileViewConstraints(*src.ProfileConstraints)) : nullptr),
            StatisticName(src.StatisticName),
            UseSpecificVersion(src.UseSpecificVersion),
            Version(src.Version)
            {}

        FGetLeaderboardAroundPlayerRequest(const TSharedPtr<FJsonObject>& obj) : FGetLeaderboardAroundPlayerRequest()
        {
            readFromValue(obj);
        }

        ~FGetLeaderboardAroundPlayerRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetLeaderboardAroundPlayerResult : public FPlayFabBaseModel
    {
        // [optional] Ordered listing of users and their positions in the requested leaderboard.
        TArray<FPlayerLeaderboardEntry> Leaderboard;
        // [optional] The time the next scheduled reset will occur. Null if the leaderboard does not reset on a schedule.
        Boxed<FDateTime> NextReset;

        // The version of the leaderboard returned.
        int32 Version;

        FGetLeaderboardAroundPlayerResult() :
            FPlayFabBaseModel(),
            Leaderboard(),
            NextReset(),
            Version(0)
            {}

        FGetLeaderboardAroundPlayerResult(const FGetLeaderboardAroundPlayerResult& src) :
            FPlayFabBaseModel(),
            Leaderboard(src.Leaderboard),
            NextReset(src.NextReset),
            Version(src.Version)
            {}

        FGetLeaderboardAroundPlayerResult(const TSharedPtr<FJsonObject>& obj) : FGetLeaderboardAroundPlayerResult()
        {
            readFromValue(obj);
        }

        ~FGetLeaderboardAroundPlayerResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetLeaderboardForUsersCharactersRequest : public FPlayFabBaseModel
    {
        // Maximum number of entries to retrieve.
        int32 MaxResultsCount;

        // Unique identifier for the title-specific statistic for the leaderboard.
        FString StatisticName;

        FGetLeaderboardForUsersCharactersRequest() :
            FPlayFabBaseModel(),
            MaxResultsCount(0),
            StatisticName()
            {}

        FGetLeaderboardForUsersCharactersRequest(const FGetLeaderboardForUsersCharactersRequest& src) :
            FPlayFabBaseModel(),
            MaxResultsCount(src.MaxResultsCount),
            StatisticName(src.StatisticName)
            {}

        FGetLeaderboardForUsersCharactersRequest(const TSharedPtr<FJsonObject>& obj) : FGetLeaderboardForUsersCharactersRequest()
        {
            readFromValue(obj);
        }

        ~FGetLeaderboardForUsersCharactersRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetLeaderboardForUsersCharactersResult : public FPlayFabBaseModel
    {
        // [optional] Ordered list of leaderboard entries.
        TArray<FCharacterLeaderboardEntry> Leaderboard;
        FGetLeaderboardForUsersCharactersResult() :
            FPlayFabBaseModel(),
            Leaderboard()
            {}

        FGetLeaderboardForUsersCharactersResult(const FGetLeaderboardForUsersCharactersResult& src) :
            FPlayFabBaseModel(),
            Leaderboard(src.Leaderboard)
            {}

        FGetLeaderboardForUsersCharactersResult(const TSharedPtr<FJsonObject>& obj) : FGetLeaderboardForUsersCharactersResult()
        {
            readFromValue(obj);
        }

        ~FGetLeaderboardForUsersCharactersResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetLeaderboardRequest : public FPlayFabBaseModel
    {
        // [optional] Maximum number of entries to retrieve. Default 10, maximum 100.
        Boxed<int32> MaxResultsCount;

        /**
         * [optional] If non-null, this determines which properties of the resulting player profiles to return. For API calls from the client,
         * only the allowed client profile properties for the title may be requested. These allowed properties are configured in
         * the Game Manager "Client Profile Options" tab in the "Settings" section.
         */
        TSharedPtr<FPlayerProfileViewConstraints> ProfileConstraints;

        // Position in the leaderboard to start this listing (defaults to the first entry).
        int32 StartPosition;

        // Statistic used to rank players for this leaderboard.
        FString StatisticName;

        // [optional] If set to false, Version is considered null. If true, uses the specified Version
        Boxed<bool> UseSpecificVersion;

        // [optional] The version of the leaderboard to get.
        Boxed<int32> Version;

        FGetLeaderboardRequest() :
            FPlayFabBaseModel(),
            MaxResultsCount(),
            ProfileConstraints(nullptr),
            StartPosition(0),
            StatisticName(),
            UseSpecificVersion(),
            Version()
            {}

        FGetLeaderboardRequest(const FGetLeaderboardRequest& src) :
            FPlayFabBaseModel(),
            MaxResultsCount(src.MaxResultsCount),
            ProfileConstraints(src.ProfileConstraints.IsValid() ? MakeShareable(new FPlayerProfileViewConstraints(*src.ProfileConstraints)) : nullptr),
            StartPosition(src.StartPosition),
            StatisticName(src.StatisticName),
            UseSpecificVersion(src.UseSpecificVersion),
            Version(src.Version)
            {}

        FGetLeaderboardRequest(const TSharedPtr<FJsonObject>& obj) : FGetLeaderboardRequest()
        {
            readFromValue(obj);
        }

        ~FGetLeaderboardRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetLeaderboardResult : public FPlayFabBaseModel
    {
        // [optional] Ordered listing of users and their positions in the requested leaderboard.
        TArray<FPlayerLeaderboardEntry> Leaderboard;
        // [optional] The time the next scheduled reset will occur. Null if the leaderboard does not reset on a schedule.
        Boxed<FDateTime> NextReset;

        // The version of the leaderboard returned.
        int32 Version;

        FGetLeaderboardResult() :
            FPlayFabBaseModel(),
            Leaderboard(),
            NextReset(),
            Version(0)
            {}

        FGetLeaderboardResult(const FGetLeaderboardResult& src) :
            FPlayFabBaseModel(),
            Leaderboard(src.Leaderboard),
            NextReset(src.NextReset),
            Version(src.Version)
            {}

        FGetLeaderboardResult(const TSharedPtr<FJsonObject>& obj) : FGetLeaderboardResult()
        {
            readFromValue(obj);
        }

        ~FGetLeaderboardResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetPaymentTokenRequest : public FPlayFabBaseModel
    {
        // The name of service to provide the payment token. Allowed Values are: xsolla
        FString TokenProvider;

        FGetPaymentTokenRequest() :
            FPlayFabBaseModel(),
            TokenProvider()
            {}

        FGetPaymentTokenRequest(const FGetPaymentTokenRequest& src) :
            FPlayFabBaseModel(),
            TokenProvider(src.TokenProvider)
            {}

        FGetPaymentTokenRequest(const TSharedPtr<FJsonObject>& obj) : FGetPaymentTokenRequest()
        {
            readFromValue(obj);
        }

        ~FGetPaymentTokenRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetPaymentTokenResult : public FPlayFabBaseModel
    {
        // [optional] PlayFab's purchase order identifier.
        FString OrderId;

        // [optional] The token from provider.
        FString ProviderToken;

        FGetPaymentTokenResult() :
            FPlayFabBaseModel(),
            OrderId(),
            ProviderToken()
            {}

        FGetPaymentTokenResult(const FGetPaymentTokenResult& src) :
            FPlayFabBaseModel(),
            OrderId(src.OrderId),
            ProviderToken(src.ProviderToken)
            {}

        FGetPaymentTokenResult(const TSharedPtr<FJsonObject>& obj) : FGetPaymentTokenResult()
        {
            readFromValue(obj);
        }

        ~FGetPaymentTokenResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetPhotonAuthenticationTokenRequest : public FPlayFabBaseModel
    {
        // The Photon applicationId for the game you wish to log into.
        FString PhotonApplicationId;

        FGetPhotonAuthenticationTokenRequest() :
            FPlayFabBaseModel(),
            PhotonApplicationId()
            {}

        FGetPhotonAuthenticationTokenRequest(const FGetPhotonAuthenticationTokenRequest& src) :
            FPlayFabBaseModel(),
            PhotonApplicationId(src.PhotonApplicationId)
            {}

        FGetPhotonAuthenticationTokenRequest(const TSharedPtr<FJsonObject>& obj) : FGetPhotonAuthenticationTokenRequest()
        {
            readFromValue(obj);
        }

        ~FGetPhotonAuthenticationTokenRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetPhotonAuthenticationTokenResult : public FPlayFabBaseModel
    {
        // [optional] The Photon authentication token for this game-session.
        FString PhotonCustomAuthenticationToken;

        FGetPhotonAuthenticationTokenResult() :
            FPlayFabBaseModel(),
            PhotonCustomAuthenticationToken()
            {}

        FGetPhotonAuthenticationTokenResult(const FGetPhotonAuthenticationTokenResult& src) :
            FPlayFabBaseModel(),
            PhotonCustomAuthenticationToken(src.PhotonCustomAuthenticationToken)
            {}

        FGetPhotonAuthenticationTokenResult(const TSharedPtr<FJsonObject>& obj) : FGetPhotonAuthenticationTokenResult()
        {
            readFromValue(obj);
        }

        ~FGetPhotonAuthenticationTokenResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetPlayerCombinedInfoRequestParams : public FPlayFabBaseModel
    {
        // Whether to get character inventories. Defaults to false.
        bool GetCharacterInventories;

        // Whether to get the list of characters. Defaults to false.
        bool GetCharacterList;

        // Whether to get player profile. Defaults to false.
        bool GetPlayerProfile;

        // Whether to get player statistics. Defaults to false.
        bool GetPlayerStatistics;

        // Whether to get title data. Defaults to false.
        bool GetTitleData;

        // Whether to get the player's account Info. Defaults to false
        bool GetUserAccountInfo;

        // Whether to get the player's custom data. Defaults to false
        bool GetUserData;

        // Whether to get the player's inventory. Defaults to false
        bool GetUserInventory;

        // Whether to get the player's read only data. Defaults to false
        bool GetUserReadOnlyData;

        // Whether to get the player's virtual currency balances. Defaults to false
        bool GetUserVirtualCurrency;

        // [optional] Specific statistics to retrieve. Leave null to get all keys. Has no effect if GetPlayerStatistics is false
        TArray<FString> PlayerStatisticNames;
        // [optional] Specifies the properties to return from the player profile. Defaults to returning the player's display name.
        TSharedPtr<FPlayerProfileViewConstraints> ProfileConstraints;

        // [optional] Specific keys to search for in the custom data. Leave null to get all keys. Has no effect if GetTitleData is false
        TArray<FString> TitleDataKeys;
        // [optional] Specific keys to search for in the custom data. Leave null to get all keys. Has no effect if GetUserData is false
        TArray<FString> UserDataKeys;
        /**
         * [optional] Specific keys to search for in the custom data. Leave null to get all keys. Has no effect if GetUserReadOnlyData is
         * false
         */
        TArray<FString> UserReadOnlyDataKeys;
        FGetPlayerCombinedInfoRequestParams() :
            FPlayFabBaseModel(),
            GetCharacterInventories(false),
            GetCharacterList(false),
            GetPlayerProfile(false),
            GetPlayerStatistics(false),
            GetTitleData(false),
            GetUserAccountInfo(false),
            GetUserData(false),
            GetUserInventory(false),
            GetUserReadOnlyData(false),
            GetUserVirtualCurrency(false),
            PlayerStatisticNames(),
            ProfileConstraints(nullptr),
            TitleDataKeys(),
            UserDataKeys(),
            UserReadOnlyDataKeys()
            {}

        FGetPlayerCombinedInfoRequestParams(const FGetPlayerCombinedInfoRequestParams& src) :
            FPlayFabBaseModel(),
            GetCharacterInventories(src.GetCharacterInventories),
            GetCharacterList(src.GetCharacterList),
            GetPlayerProfile(src.GetPlayerProfile),
            GetPlayerStatistics(src.GetPlayerStatistics),
            GetTitleData(src.GetTitleData),
            GetUserAccountInfo(src.GetUserAccountInfo),
            GetUserData(src.GetUserData),
            GetUserInventory(src.GetUserInventory),
            GetUserReadOnlyData(src.GetUserReadOnlyData),
            GetUserVirtualCurrency(src.GetUserVirtualCurrency),
            PlayerStatisticNames(src.PlayerStatisticNames),
            ProfileConstraints(src.ProfileConstraints.IsValid() ? MakeShareable(new FPlayerProfileViewConstraints(*src.ProfileConstraints)) : nullptr),
            TitleDataKeys(src.TitleDataKeys),
            UserDataKeys(src.UserDataKeys),
            UserReadOnlyDataKeys(src.UserReadOnlyDataKeys)
            {}

        FGetPlayerCombinedInfoRequestParams(const TSharedPtr<FJsonObject>& obj) : FGetPlayerCombinedInfoRequestParams()
        {
            readFromValue(obj);
        }

        ~FGetPlayerCombinedInfoRequestParams();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetPlayerCombinedInfoRequest : public FPlayFabBaseModel
    {
        // Flags for which pieces of info to return for the user.
        FGetPlayerCombinedInfoRequestParams InfoRequestParameters;

        // [optional] PlayFabId of the user whose data will be returned. If not filled included, we return the data for the calling player.
        FString PlayFabId;

        FGetPlayerCombinedInfoRequest() :
            FPlayFabBaseModel(),
            InfoRequestParameters(),
            PlayFabId()
            {}

        FGetPlayerCombinedInfoRequest(const FGetPlayerCombinedInfoRequest& src) :
            FPlayFabBaseModel(),
            InfoRequestParameters(src.InfoRequestParameters),
            PlayFabId(src.PlayFabId)
            {}

        FGetPlayerCombinedInfoRequest(const TSharedPtr<FJsonObject>& obj) : FGetPlayerCombinedInfoRequest()
        {
            readFromValue(obj);
        }

        ~FGetPlayerCombinedInfoRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FStatisticValue : public FPlayFabBaseModel
    {
        // [optional] unique name of the statistic
        FString StatisticName;

        // statistic value for the player
        int32 Value;

        // for updates to an existing statistic value for a player, the version of the statistic when it was loaded
        uint32 Version;

        FStatisticValue() :
            FPlayFabBaseModel(),
            StatisticName(),
            Value(0),
            Version(0)
            {}

        FStatisticValue(const FStatisticValue& src) :
            FPlayFabBaseModel(),
            StatisticName(src.StatisticName),
            Value(src.Value),
            Version(src.Version)
            {}

        FStatisticValue(const TSharedPtr<FJsonObject>& obj) : FStatisticValue()
        {
            readFromValue(obj);
        }

        ~FStatisticValue();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetPlayerCombinedInfoResultPayload : public FPlayFabBaseModel
    {
        // [optional] Account information for the user. This is always retrieved.
        TSharedPtr<FUserAccountInfo> AccountInfo;

        // [optional] Inventories for each character for the user.
        TArray<FCharacterInventory> CharacterInventories;
        // [optional] List of characters for the user.
        TArray<FCharacterResult> CharacterList;
        /**
         * [optional] The profile of the players. This profile is not guaranteed to be up-to-date. For a new player, this profile will not
         * exist.
         */
        TSharedPtr<FPlayerProfileModel> PlayerProfile;

        // [optional] List of statistics for this player.
        TArray<FStatisticValue> PlayerStatistics;
        // [optional] Title data for this title.
        TMap<FString, FString> TitleData;
        // [optional] User specific custom data.
        TMap<FString, FUserDataRecord> UserData;
        // The version of the UserData that was returned.
        uint32 UserDataVersion;

        // [optional] Array of inventory items in the user's current inventory.
        TArray<FItemInstance> UserInventory;
        // [optional] User specific read-only data.
        TMap<FString, FUserDataRecord> UserReadOnlyData;
        // The version of the Read-Only UserData that was returned.
        uint32 UserReadOnlyDataVersion;

        // [optional] Dictionary of virtual currency balance(s) belonging to the user.
        TMap<FString, int32> UserVirtualCurrency;
        // [optional] Dictionary of remaining times and timestamps for virtual currencies.
        TMap<FString, FVirtualCurrencyRechargeTime> UserVirtualCurrencyRechargeTimes;
        FGetPlayerCombinedInfoResultPayload() :
            FPlayFabBaseModel(),
            AccountInfo(nullptr),
            CharacterInventories(),
            CharacterList(),
            PlayerProfile(nullptr),
            PlayerStatistics(),
            TitleData(),
            UserData(),
            UserDataVersion(0),
            UserInventory(),
            UserReadOnlyData(),
            UserReadOnlyDataVersion(0),
            UserVirtualCurrency(),
            UserVirtualCurrencyRechargeTimes()
            {}

        FGetPlayerCombinedInfoResultPayload(const FGetPlayerCombinedInfoResultPayload& src) :
            FPlayFabBaseModel(),
            AccountInfo(src.AccountInfo.IsValid() ? MakeShareable(new FUserAccountInfo(*src.AccountInfo)) : nullptr),
            CharacterInventories(src.CharacterInventories),
            CharacterList(src.CharacterList),
            PlayerProfile(src.PlayerProfile.IsValid() ? MakeShareable(new FPlayerProfileModel(*src.PlayerProfile)) : nullptr),
            PlayerStatistics(src.PlayerStatistics),
            TitleData(src.TitleData),
            UserData(src.UserData),
            UserDataVersion(src.UserDataVersion),
            UserInventory(src.UserInventory),
            UserReadOnlyData(src.UserReadOnlyData),
            UserReadOnlyDataVersion(src.UserReadOnlyDataVersion),
            UserVirtualCurrency(src.UserVirtualCurrency),
            UserVirtualCurrencyRechargeTimes(src.UserVirtualCurrencyRechargeTimes)
            {}

        FGetPlayerCombinedInfoResultPayload(const TSharedPtr<FJsonObject>& obj) : FGetPlayerCombinedInfoResultPayload()
        {
            readFromValue(obj);
        }

        ~FGetPlayerCombinedInfoResultPayload();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetPlayerCombinedInfoResult : public FPlayFabBaseModel
    {
        // [optional] Results for requested info.
        TSharedPtr<FGetPlayerCombinedInfoResultPayload> InfoResultPayload;

        // [optional] Unique PlayFab assigned ID of the user on whom the operation will be performed.
        FString PlayFabId;

        FGetPlayerCombinedInfoResult() :
            FPlayFabBaseModel(),
            InfoResultPayload(nullptr),
            PlayFabId()
            {}

        FGetPlayerCombinedInfoResult(const FGetPlayerCombinedInfoResult& src) :
            FPlayFabBaseModel(),
            InfoResultPayload(src.InfoResultPayload.IsValid() ? MakeShareable(new FGetPlayerCombinedInfoResultPayload(*src.InfoResultPayload)) : nullptr),
            PlayFabId(src.PlayFabId)
            {}

        FGetPlayerCombinedInfoResult(const TSharedPtr<FJsonObject>& obj) : FGetPlayerCombinedInfoResult()
        {
            readFromValue(obj);
        }

        ~FGetPlayerCombinedInfoResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetPlayerProfileRequest : public FPlayFabBaseModel
    {
        // Unique PlayFab assigned ID of the user on whom the operation will be performed.
        FString PlayFabId;

        /**
         * [optional] If non-null, this determines which properties of the resulting player profiles to return. For API calls from the client,
         * only the allowed client profile properties for the title may be requested. These allowed properties are configured in
         * the Game Manager "Client Profile Options" tab in the "Settings" section.
         */
        TSharedPtr<FPlayerProfileViewConstraints> ProfileConstraints;

        FGetPlayerProfileRequest() :
            FPlayFabBaseModel(),
            PlayFabId(),
            ProfileConstraints(nullptr)
            {}

        FGetPlayerProfileRequest(const FGetPlayerProfileRequest& src) :
            FPlayFabBaseModel(),
            PlayFabId(src.PlayFabId),
            ProfileConstraints(src.ProfileConstraints.IsValid() ? MakeShareable(new FPlayerProfileViewConstraints(*src.ProfileConstraints)) : nullptr)
            {}

        FGetPlayerProfileRequest(const TSharedPtr<FJsonObject>& obj) : FGetPlayerProfileRequest()
        {
            readFromValue(obj);
        }

        ~FGetPlayerProfileRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetPlayerProfileResult : public FPlayFabBaseModel
    {
        /**
         * [optional] The profile of the player. This profile is not guaranteed to be up-to-date. For a new player, this profile will not
         * exist.
         */
        TSharedPtr<FPlayerProfileModel> PlayerProfile;

        FGetPlayerProfileResult() :
            FPlayFabBaseModel(),
            PlayerProfile(nullptr)
            {}

        FGetPlayerProfileResult(const FGetPlayerProfileResult& src) :
            FPlayFabBaseModel(),
            PlayerProfile(src.PlayerProfile.IsValid() ? MakeShareable(new FPlayerProfileModel(*src.PlayerProfile)) : nullptr)
            {}

        FGetPlayerProfileResult(const TSharedPtr<FJsonObject>& obj) : FGetPlayerProfileResult()
        {
            readFromValue(obj);
        }

        ~FGetPlayerProfileResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetPlayerSegmentsRequest : public FPlayFabBaseModel
    {
        FGetPlayerSegmentsRequest() :
            FPlayFabBaseModel()
            {}

        FGetPlayerSegmentsRequest(const FGetPlayerSegmentsRequest& src) :
            FPlayFabBaseModel()
            {}

        FGetPlayerSegmentsRequest(const TSharedPtr<FJsonObject>& obj) : FGetPlayerSegmentsRequest()
        {
            readFromValue(obj);
        }

        ~FGetPlayerSegmentsRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetSegmentResult : public FPlayFabBaseModel
    {
        // [optional] Identifier of the segments AB Test, if it is attached to one.
        FString ABTestParent;

        // Unique identifier for this segment.
        FString Id;

        // [optional] Segment name.
        FString Name;

        FGetSegmentResult() :
            FPlayFabBaseModel(),
            ABTestParent(),
            Id(),
            Name()
            {}

        FGetSegmentResult(const FGetSegmentResult& src) :
            FPlayFabBaseModel(),
            ABTestParent(src.ABTestParent),
            Id(src.Id),
            Name(src.Name)
            {}

        FGetSegmentResult(const TSharedPtr<FJsonObject>& obj) : FGetSegmentResult()
        {
            readFromValue(obj);
        }

        ~FGetSegmentResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetPlayerSegmentsResult : public FPlayFabBaseModel
    {
        // [optional] Array of segments the requested player currently belongs to.
        TArray<FGetSegmentResult> Segments;
        FGetPlayerSegmentsResult() :
            FPlayFabBaseModel(),
            Segments()
            {}

        FGetPlayerSegmentsResult(const FGetPlayerSegmentsResult& src) :
            FPlayFabBaseModel(),
            Segments(src.Segments)
            {}

        FGetPlayerSegmentsResult(const TSharedPtr<FJsonObject>& obj) : FGetPlayerSegmentsResult()
        {
            readFromValue(obj);
        }

        ~FGetPlayerSegmentsResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FStatisticNameVersion : public FPlayFabBaseModel
    {
        // unique name of the statistic
        FString StatisticName;

        // the version of the statistic to be returned
        uint32 Version;

        FStatisticNameVersion() :
            FPlayFabBaseModel(),
            StatisticName(),
            Version(0)
            {}

        FStatisticNameVersion(const FStatisticNameVersion& src) :
            FPlayFabBaseModel(),
            StatisticName(src.StatisticName),
            Version(src.Version)
            {}

        FStatisticNameVersion(const TSharedPtr<FJsonObject>& obj) : FStatisticNameVersion()
        {
            readFromValue(obj);
        }

        ~FStatisticNameVersion();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetPlayerStatisticsRequest : public FPlayFabBaseModel
    {
        // [optional] statistics to return (current version will be returned for each)
        TArray<FString> StatisticNames;
        /**
         * [optional] statistics to return, if StatisticNames is not set (only statistics which have a version matching that provided will be
         * returned)
         */
        TArray<FStatisticNameVersion> StatisticNameVersions;
        FGetPlayerStatisticsRequest() :
            FPlayFabBaseModel(),
            StatisticNames(),
            StatisticNameVersions()
            {}

        FGetPlayerStatisticsRequest(const FGetPlayerStatisticsRequest& src) :
            FPlayFabBaseModel(),
            StatisticNames(src.StatisticNames),
            StatisticNameVersions(src.StatisticNameVersions)
            {}

        FGetPlayerStatisticsRequest(const TSharedPtr<FJsonObject>& obj) : FGetPlayerStatisticsRequest()
        {
            readFromValue(obj);
        }

        ~FGetPlayerStatisticsRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetPlayerStatisticsResult : public FPlayFabBaseModel
    {
        // [optional] User statistics for the requested user.
        TArray<FStatisticValue> Statistics;
        FGetPlayerStatisticsResult() :
            FPlayFabBaseModel(),
            Statistics()
            {}

        FGetPlayerStatisticsResult(const FGetPlayerStatisticsResult& src) :
            FPlayFabBaseModel(),
            Statistics(src.Statistics)
            {}

        FGetPlayerStatisticsResult(const TSharedPtr<FJsonObject>& obj) : FGetPlayerStatisticsResult()
        {
            readFromValue(obj);
        }

        ~FGetPlayerStatisticsResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetPlayerStatisticVersionsRequest : public FPlayFabBaseModel
    {
        // [optional] unique name of the statistic
        FString StatisticName;

        FGetPlayerStatisticVersionsRequest() :
            FPlayFabBaseModel(),
            StatisticName()
            {}

        FGetPlayerStatisticVersionsRequest(const FGetPlayerStatisticVersionsRequest& src) :
            FPlayFabBaseModel(),
            StatisticName(src.StatisticName)
            {}

        FGetPlayerStatisticVersionsRequest(const TSharedPtr<FJsonObject>& obj) : FGetPlayerStatisticVersionsRequest()
        {
            readFromValue(obj);
        }

        ~FGetPlayerStatisticVersionsRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FPlayerStatisticVersion : public FPlayFabBaseModel
    {
        // time when the statistic version became active
        FDateTime ActivationTime;

        // [optional] time when the statistic version became inactive due to statistic version incrementing
        Boxed<FDateTime> DeactivationTime;

        // [optional] time at which the statistic version was scheduled to become active, based on the configured ResetInterval
        Boxed<FDateTime> ScheduledActivationTime;

        // [optional] time at which the statistic version was scheduled to become inactive, based on the configured ResetInterval
        Boxed<FDateTime> ScheduledDeactivationTime;

        // [optional] name of the statistic when the version became active
        FString StatisticName;

        // version of the statistic
        uint32 Version;

        FPlayerStatisticVersion() :
            FPlayFabBaseModel(),
            ActivationTime(0),
            DeactivationTime(),
            ScheduledActivationTime(),
            ScheduledDeactivationTime(),
            StatisticName(),
            Version(0)
            {}

        FPlayerStatisticVersion(const FPlayerStatisticVersion& src) :
            FPlayFabBaseModel(),
            ActivationTime(src.ActivationTime),
            DeactivationTime(src.DeactivationTime),
            ScheduledActivationTime(src.ScheduledActivationTime),
            ScheduledDeactivationTime(src.ScheduledDeactivationTime),
            StatisticName(src.StatisticName),
            Version(src.Version)
            {}

        FPlayerStatisticVersion(const TSharedPtr<FJsonObject>& obj) : FPlayerStatisticVersion()
        {
            readFromValue(obj);
        }

        ~FPlayerStatisticVersion();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetPlayerStatisticVersionsResult : public FPlayFabBaseModel
    {
        // [optional] version change history of the statistic
        TArray<FPlayerStatisticVersion> StatisticVersions;
        FGetPlayerStatisticVersionsResult() :
            FPlayFabBaseModel(),
            StatisticVersions()
            {}

        FGetPlayerStatisticVersionsResult(const FGetPlayerStatisticVersionsResult& src) :
            FPlayFabBaseModel(),
            StatisticVersions(src.StatisticVersions)
            {}

        FGetPlayerStatisticVersionsResult(const TSharedPtr<FJsonObject>& obj) : FGetPlayerStatisticVersionsResult()
        {
            readFromValue(obj);
        }

        ~FGetPlayerStatisticVersionsResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetPlayerTagsRequest : public FPlayFabBaseModel
    {
        // [optional] Optional namespace to filter results by
        FString Namespace;

        // Unique PlayFab assigned ID of the user on whom the operation will be performed.
        FString PlayFabId;

        FGetPlayerTagsRequest() :
            FPlayFabBaseModel(),
            Namespace(),
            PlayFabId()
            {}

        FGetPlayerTagsRequest(const FGetPlayerTagsRequest& src) :
            FPlayFabBaseModel(),
            Namespace(src.Namespace),
            PlayFabId(src.PlayFabId)
            {}

        FGetPlayerTagsRequest(const TSharedPtr<FJsonObject>& obj) : FGetPlayerTagsRequest()
        {
            readFromValue(obj);
        }

        ~FGetPlayerTagsRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetPlayerTagsResult : public FPlayFabBaseModel
    {
        // Unique PlayFab assigned ID of the user on whom the operation will be performed.
        FString PlayFabId;

        // Canonical tags (including namespace and tag's name) for the requested user
        TArray<FString> Tags;
        FGetPlayerTagsResult() :
            FPlayFabBaseModel(),
            PlayFabId(),
            Tags()
            {}

        FGetPlayerTagsResult(const FGetPlayerTagsResult& src) :
            FPlayFabBaseModel(),
            PlayFabId(src.PlayFabId),
            Tags(src.Tags)
            {}

        FGetPlayerTagsResult(const TSharedPtr<FJsonObject>& obj) : FGetPlayerTagsResult()
        {
            readFromValue(obj);
        }

        ~FGetPlayerTagsResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetPlayerTradesRequest : public FPlayFabBaseModel
    {
        // [optional] Returns only trades with the given status. If null, returns all trades.
        Boxed<TradeStatus> StatusFilter;

        FGetPlayerTradesRequest() :
            FPlayFabBaseModel(),
            StatusFilter()
            {}

        FGetPlayerTradesRequest(const FGetPlayerTradesRequest& src) :
            FPlayFabBaseModel(),
            StatusFilter(src.StatusFilter)
            {}

        FGetPlayerTradesRequest(const TSharedPtr<FJsonObject>& obj) : FGetPlayerTradesRequest()
        {
            readFromValue(obj);
        }

        ~FGetPlayerTradesRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetPlayerTradesResponse : public FPlayFabBaseModel
    {
        // [optional] History of trades which this player has accepted.
        TArray<FTradeInfo> AcceptedTrades;
        // [optional] The trades for this player which are currently available to be accepted.
        TArray<FTradeInfo> OpenedTrades;
        FGetPlayerTradesResponse() :
            FPlayFabBaseModel(),
            AcceptedTrades(),
            OpenedTrades()
            {}

        FGetPlayerTradesResponse(const FGetPlayerTradesResponse& src) :
            FPlayFabBaseModel(),
            AcceptedTrades(src.AcceptedTrades),
            OpenedTrades(src.OpenedTrades)
            {}

        FGetPlayerTradesResponse(const TSharedPtr<FJsonObject>& obj) : FGetPlayerTradesResponse()
        {
            readFromValue(obj);
        }

        ~FGetPlayerTradesResponse();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetPlayFabIDsFromFacebookIDsRequest : public FPlayFabBaseModel
    {
        // Array of unique Facebook identifiers for which the title needs to get PlayFab identifiers.
        TArray<FString> FacebookIDs;
        FGetPlayFabIDsFromFacebookIDsRequest() :
            FPlayFabBaseModel(),
            FacebookIDs()
            {}

        FGetPlayFabIDsFromFacebookIDsRequest(const FGetPlayFabIDsFromFacebookIDsRequest& src) :
            FPlayFabBaseModel(),
            FacebookIDs(src.FacebookIDs)
            {}

        FGetPlayFabIDsFromFacebookIDsRequest(const TSharedPtr<FJsonObject>& obj) : FGetPlayFabIDsFromFacebookIDsRequest()
        {
            readFromValue(obj);
        }

        ~FGetPlayFabIDsFromFacebookIDsRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetPlayFabIDsFromFacebookIDsResult : public FPlayFabBaseModel
    {
        // [optional] Mapping of Facebook identifiers to PlayFab identifiers.
        TArray<FFacebookPlayFabIdPair> Data;
        FGetPlayFabIDsFromFacebookIDsResult() :
            FPlayFabBaseModel(),
            Data()
            {}

        FGetPlayFabIDsFromFacebookIDsResult(const FGetPlayFabIDsFromFacebookIDsResult& src) :
            FPlayFabBaseModel(),
            Data(src.Data)
            {}

        FGetPlayFabIDsFromFacebookIDsResult(const TSharedPtr<FJsonObject>& obj) : FGetPlayFabIDsFromFacebookIDsResult()
        {
            readFromValue(obj);
        }

        ~FGetPlayFabIDsFromFacebookIDsResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetPlayFabIDsFromGameCenterIDsRequest : public FPlayFabBaseModel
    {
        // Array of unique Game Center identifiers (the Player Identifier) for which the title needs to get PlayFab identifiers.
        TArray<FString> GameCenterIDs;
        FGetPlayFabIDsFromGameCenterIDsRequest() :
            FPlayFabBaseModel(),
            GameCenterIDs()
            {}

        FGetPlayFabIDsFromGameCenterIDsRequest(const FGetPlayFabIDsFromGameCenterIDsRequest& src) :
            FPlayFabBaseModel(),
            GameCenterIDs(src.GameCenterIDs)
            {}

        FGetPlayFabIDsFromGameCenterIDsRequest(const TSharedPtr<FJsonObject>& obj) : FGetPlayFabIDsFromGameCenterIDsRequest()
        {
            readFromValue(obj);
        }

        ~FGetPlayFabIDsFromGameCenterIDsRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetPlayFabIDsFromGameCenterIDsResult : public FPlayFabBaseModel
    {
        // [optional] Mapping of Game Center identifiers to PlayFab identifiers.
        TArray<FGameCenterPlayFabIdPair> Data;
        FGetPlayFabIDsFromGameCenterIDsResult() :
            FPlayFabBaseModel(),
            Data()
            {}

        FGetPlayFabIDsFromGameCenterIDsResult(const FGetPlayFabIDsFromGameCenterIDsResult& src) :
            FPlayFabBaseModel(),
            Data(src.Data)
            {}

        FGetPlayFabIDsFromGameCenterIDsResult(const TSharedPtr<FJsonObject>& obj) : FGetPlayFabIDsFromGameCenterIDsResult()
        {
            readFromValue(obj);
        }

        ~FGetPlayFabIDsFromGameCenterIDsResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetPlayFabIDsFromGenericIDsRequest : public FPlayFabBaseModel
    {
        /**
         * Array of unique generic service identifiers for which the title needs to get PlayFab identifiers. Currently limited to a
         * maximum of 10 in a single request.
         */
        TArray<FGenericServiceId> GenericIDs;
        FGetPlayFabIDsFromGenericIDsRequest() :
            FPlayFabBaseModel(),
            GenericIDs()
            {}

        FGetPlayFabIDsFromGenericIDsRequest(const FGetPlayFabIDsFromGenericIDsRequest& src) :
            FPlayFabBaseModel(),
            GenericIDs(src.GenericIDs)
            {}

        FGetPlayFabIDsFromGenericIDsRequest(const TSharedPtr<FJsonObject>& obj) : FGetPlayFabIDsFromGenericIDsRequest()
        {
            readFromValue(obj);
        }

        ~FGetPlayFabIDsFromGenericIDsRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetPlayFabIDsFromGenericIDsResult : public FPlayFabBaseModel
    {
        // [optional] Mapping of generic service identifiers to PlayFab identifiers.
        TArray<FGenericPlayFabIdPair> Data;
        FGetPlayFabIDsFromGenericIDsResult() :
            FPlayFabBaseModel(),
            Data()
            {}

        FGetPlayFabIDsFromGenericIDsResult(const FGetPlayFabIDsFromGenericIDsResult& src) :
            FPlayFabBaseModel(),
            Data(src.Data)
            {}

        FGetPlayFabIDsFromGenericIDsResult(const TSharedPtr<FJsonObject>& obj) : FGetPlayFabIDsFromGenericIDsResult()
        {
            readFromValue(obj);
        }

        ~FGetPlayFabIDsFromGenericIDsResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetPlayFabIDsFromGoogleIDsRequest : public FPlayFabBaseModel
    {
        // Array of unique Google identifiers (Google+ user IDs) for which the title needs to get PlayFab identifiers.
        TArray<FString> GoogleIDs;
        FGetPlayFabIDsFromGoogleIDsRequest() :
            FPlayFabBaseModel(),
            GoogleIDs()
            {}

        FGetPlayFabIDsFromGoogleIDsRequest(const FGetPlayFabIDsFromGoogleIDsRequest& src) :
            FPlayFabBaseModel(),
            GoogleIDs(src.GoogleIDs)
            {}

        FGetPlayFabIDsFromGoogleIDsRequest(const TSharedPtr<FJsonObject>& obj) : FGetPlayFabIDsFromGoogleIDsRequest()
        {
            readFromValue(obj);
        }

        ~FGetPlayFabIDsFromGoogleIDsRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGooglePlayFabIdPair : public FPlayFabBaseModel
    {
        // [optional] Unique Google identifier for a user.
        FString GoogleId;

        // [optional] Unique PlayFab identifier for a user, or null if no PlayFab account is linked to the Google identifier.
        FString PlayFabId;

        FGooglePlayFabIdPair() :
            FPlayFabBaseModel(),
            GoogleId(),
            PlayFabId()
            {}

        FGooglePlayFabIdPair(const FGooglePlayFabIdPair& src) :
            FPlayFabBaseModel(),
            GoogleId(src.GoogleId),
            PlayFabId(src.PlayFabId)
            {}

        FGooglePlayFabIdPair(const TSharedPtr<FJsonObject>& obj) : FGooglePlayFabIdPair()
        {
            readFromValue(obj);
        }

        ~FGooglePlayFabIdPair();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetPlayFabIDsFromGoogleIDsResult : public FPlayFabBaseModel
    {
        // [optional] Mapping of Google identifiers to PlayFab identifiers.
        TArray<FGooglePlayFabIdPair> Data;
        FGetPlayFabIDsFromGoogleIDsResult() :
            FPlayFabBaseModel(),
            Data()
            {}

        FGetPlayFabIDsFromGoogleIDsResult(const FGetPlayFabIDsFromGoogleIDsResult& src) :
            FPlayFabBaseModel(),
            Data(src.Data)
            {}

        FGetPlayFabIDsFromGoogleIDsResult(const TSharedPtr<FJsonObject>& obj) : FGetPlayFabIDsFromGoogleIDsResult()
        {
            readFromValue(obj);
        }

        ~FGetPlayFabIDsFromGoogleIDsResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetPlayFabIDsFromKongregateIDsRequest : public FPlayFabBaseModel
    {
        // Array of unique Kongregate identifiers (Kongregate's user_id) for which the title needs to get PlayFab identifiers.
        TArray<FString> KongregateIDs;
        FGetPlayFabIDsFromKongregateIDsRequest() :
            FPlayFabBaseModel(),
            KongregateIDs()
            {}

        FGetPlayFabIDsFromKongregateIDsRequest(const FGetPlayFabIDsFromKongregateIDsRequest& src) :
            FPlayFabBaseModel(),
            KongregateIDs(src.KongregateIDs)
            {}

        FGetPlayFabIDsFromKongregateIDsRequest(const TSharedPtr<FJsonObject>& obj) : FGetPlayFabIDsFromKongregateIDsRequest()
        {
            readFromValue(obj);
        }

        ~FGetPlayFabIDsFromKongregateIDsRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FKongregatePlayFabIdPair : public FPlayFabBaseModel
    {
        // [optional] Unique Kongregate identifier for a user.
        FString KongregateId;

        // [optional] Unique PlayFab identifier for a user, or null if no PlayFab account is linked to the Kongregate identifier.
        FString PlayFabId;

        FKongregatePlayFabIdPair() :
            FPlayFabBaseModel(),
            KongregateId(),
            PlayFabId()
            {}

        FKongregatePlayFabIdPair(const FKongregatePlayFabIdPair& src) :
            FPlayFabBaseModel(),
            KongregateId(src.KongregateId),
            PlayFabId(src.PlayFabId)
            {}

        FKongregatePlayFabIdPair(const TSharedPtr<FJsonObject>& obj) : FKongregatePlayFabIdPair()
        {
            readFromValue(obj);
        }

        ~FKongregatePlayFabIdPair();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetPlayFabIDsFromKongregateIDsResult : public FPlayFabBaseModel
    {
        // [optional] Mapping of Kongregate identifiers to PlayFab identifiers.
        TArray<FKongregatePlayFabIdPair> Data;
        FGetPlayFabIDsFromKongregateIDsResult() :
            FPlayFabBaseModel(),
            Data()
            {}

        FGetPlayFabIDsFromKongregateIDsResult(const FGetPlayFabIDsFromKongregateIDsResult& src) :
            FPlayFabBaseModel(),
            Data(src.Data)
            {}

        FGetPlayFabIDsFromKongregateIDsResult(const TSharedPtr<FJsonObject>& obj) : FGetPlayFabIDsFromKongregateIDsResult()
        {
            readFromValue(obj);
        }

        ~FGetPlayFabIDsFromKongregateIDsResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetPlayFabIDsFromSteamIDsRequest : public FPlayFabBaseModel
    {
        // [optional] Array of unique Steam identifiers (Steam profile IDs) for which the title needs to get PlayFab identifiers.
        TArray<FString> SteamStringIDs;
        FGetPlayFabIDsFromSteamIDsRequest() :
            FPlayFabBaseModel(),
            SteamStringIDs()
            {}

        FGetPlayFabIDsFromSteamIDsRequest(const FGetPlayFabIDsFromSteamIDsRequest& src) :
            FPlayFabBaseModel(),
            SteamStringIDs(src.SteamStringIDs)
            {}

        FGetPlayFabIDsFromSteamIDsRequest(const TSharedPtr<FJsonObject>& obj) : FGetPlayFabIDsFromSteamIDsRequest()
        {
            readFromValue(obj);
        }

        ~FGetPlayFabIDsFromSteamIDsRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FSteamPlayFabIdPair : public FPlayFabBaseModel
    {
        // [optional] Unique PlayFab identifier for a user, or null if no PlayFab account is linked to the Steam identifier.
        FString PlayFabId;

        // [optional] Unique Steam identifier for a user.
        FString SteamStringId;

        FSteamPlayFabIdPair() :
            FPlayFabBaseModel(),
            PlayFabId(),
            SteamStringId()
            {}

        FSteamPlayFabIdPair(const FSteamPlayFabIdPair& src) :
            FPlayFabBaseModel(),
            PlayFabId(src.PlayFabId),
            SteamStringId(src.SteamStringId)
            {}

        FSteamPlayFabIdPair(const TSharedPtr<FJsonObject>& obj) : FSteamPlayFabIdPair()
        {
            readFromValue(obj);
        }

        ~FSteamPlayFabIdPair();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetPlayFabIDsFromSteamIDsResult : public FPlayFabBaseModel
    {
        // [optional] Mapping of Steam identifiers to PlayFab identifiers.
        TArray<FSteamPlayFabIdPair> Data;
        FGetPlayFabIDsFromSteamIDsResult() :
            FPlayFabBaseModel(),
            Data()
            {}

        FGetPlayFabIDsFromSteamIDsResult(const FGetPlayFabIDsFromSteamIDsResult& src) :
            FPlayFabBaseModel(),
            Data(src.Data)
            {}

        FGetPlayFabIDsFromSteamIDsResult(const TSharedPtr<FJsonObject>& obj) : FGetPlayFabIDsFromSteamIDsResult()
        {
            readFromValue(obj);
        }

        ~FGetPlayFabIDsFromSteamIDsResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetPlayFabIDsFromTwitchIDsRequest : public FPlayFabBaseModel
    {
        // Array of unique Twitch identifiers (Twitch's _id) for which the title needs to get PlayFab identifiers.
        TArray<FString> TwitchIds;
        FGetPlayFabIDsFromTwitchIDsRequest() :
            FPlayFabBaseModel(),
            TwitchIds()
            {}

        FGetPlayFabIDsFromTwitchIDsRequest(const FGetPlayFabIDsFromTwitchIDsRequest& src) :
            FPlayFabBaseModel(),
            TwitchIds(src.TwitchIds)
            {}

        FGetPlayFabIDsFromTwitchIDsRequest(const TSharedPtr<FJsonObject>& obj) : FGetPlayFabIDsFromTwitchIDsRequest()
        {
            readFromValue(obj);
        }

        ~FGetPlayFabIDsFromTwitchIDsRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FTwitchPlayFabIdPair : public FPlayFabBaseModel
    {
        // [optional] Unique PlayFab identifier for a user, or null if no PlayFab account is linked to the Twitch identifier.
        FString PlayFabId;

        // [optional] Unique Twitch identifier for a user.
        FString TwitchId;

        FTwitchPlayFabIdPair() :
            FPlayFabBaseModel(),
            PlayFabId(),
            TwitchId()
            {}

        FTwitchPlayFabIdPair(const FTwitchPlayFabIdPair& src) :
            FPlayFabBaseModel(),
            PlayFabId(src.PlayFabId),
            TwitchId(src.TwitchId)
            {}

        FTwitchPlayFabIdPair(const TSharedPtr<FJsonObject>& obj) : FTwitchPlayFabIdPair()
        {
            readFromValue(obj);
        }

        ~FTwitchPlayFabIdPair();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetPlayFabIDsFromTwitchIDsResult : public FPlayFabBaseModel
    {
        // [optional] Mapping of Twitch identifiers to PlayFab identifiers.
        TArray<FTwitchPlayFabIdPair> Data;
        FGetPlayFabIDsFromTwitchIDsResult() :
            FPlayFabBaseModel(),
            Data()
            {}

        FGetPlayFabIDsFromTwitchIDsResult(const FGetPlayFabIDsFromTwitchIDsResult& src) :
            FPlayFabBaseModel(),
            Data(src.Data)
            {}

        FGetPlayFabIDsFromTwitchIDsResult(const TSharedPtr<FJsonObject>& obj) : FGetPlayFabIDsFromTwitchIDsResult()
        {
            readFromValue(obj);
        }

        ~FGetPlayFabIDsFromTwitchIDsResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetPublisherDataRequest : public FPlayFabBaseModel
    {
        // array of keys to get back data from the Publisher data blob, set by the admin tools
        TArray<FString> Keys;
        FGetPublisherDataRequest() :
            FPlayFabBaseModel(),
            Keys()
            {}

        FGetPublisherDataRequest(const FGetPublisherDataRequest& src) :
            FPlayFabBaseModel(),
            Keys(src.Keys)
            {}

        FGetPublisherDataRequest(const TSharedPtr<FJsonObject>& obj) : FGetPublisherDataRequest()
        {
            readFromValue(obj);
        }

        ~FGetPublisherDataRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetPublisherDataResult : public FPlayFabBaseModel
    {
        // [optional] a dictionary object of key / value pairs
        TMap<FString, FString> Data;
        FGetPublisherDataResult() :
            FPlayFabBaseModel(),
            Data()
            {}

        FGetPublisherDataResult(const FGetPublisherDataResult& src) :
            FPlayFabBaseModel(),
            Data(src.Data)
            {}

        FGetPublisherDataResult(const TSharedPtr<FJsonObject>& obj) : FGetPublisherDataResult()
        {
            readFromValue(obj);
        }

        ~FGetPublisherDataResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetPurchaseRequest : public FPlayFabBaseModel
    {
        // Purchase order identifier.
        FString OrderId;

        FGetPurchaseRequest() :
            FPlayFabBaseModel(),
            OrderId()
            {}

        FGetPurchaseRequest(const FGetPurchaseRequest& src) :
            FPlayFabBaseModel(),
            OrderId(src.OrderId)
            {}

        FGetPurchaseRequest(const TSharedPtr<FJsonObject>& obj) : FGetPurchaseRequest()
        {
            readFromValue(obj);
        }

        ~FGetPurchaseRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetPurchaseResult : public FPlayFabBaseModel
    {
        // [optional] Purchase order identifier.
        FString OrderId;

        // [optional] Payment provider used for transaction (If not VC)
        FString PaymentProvider;

        // Date and time of the purchase.
        FDateTime PurchaseDate;

        // [optional] Provider transaction ID (If not VC)
        FString TransactionId;

        // [optional] PlayFab transaction status
        FString TransactionStatus;

        FGetPurchaseResult() :
            FPlayFabBaseModel(),
            OrderId(),
            PaymentProvider(),
            PurchaseDate(0),
            TransactionId(),
            TransactionStatus()
            {}

        FGetPurchaseResult(const FGetPurchaseResult& src) :
            FPlayFabBaseModel(),
            OrderId(src.OrderId),
            PaymentProvider(src.PaymentProvider),
            PurchaseDate(src.PurchaseDate),
            TransactionId(src.TransactionId),
            TransactionStatus(src.TransactionStatus)
            {}

        FGetPurchaseResult(const TSharedPtr<FJsonObject>& obj) : FGetPurchaseResult()
        {
            readFromValue(obj);
        }

        ~FGetPurchaseResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetSharedGroupDataRequest : public FPlayFabBaseModel
    {
        // [optional] If true, return the list of all members of the shared group.
        Boxed<bool> GetMembers;

        /**
         * [optional] Specific keys to retrieve from the shared group (if not specified, all keys will be returned, while an empty array
         * indicates that no keys should be returned).
         */
        TArray<FString> Keys;
        // Unique identifier for the shared group.
        FString SharedGroupId;

        FGetSharedGroupDataRequest() :
            FPlayFabBaseModel(),
            GetMembers(),
            Keys(),
            SharedGroupId()
            {}

        FGetSharedGroupDataRequest(const FGetSharedGroupDataRequest& src) :
            FPlayFabBaseModel(),
            GetMembers(src.GetMembers),
            Keys(src.Keys),
            SharedGroupId(src.SharedGroupId)
            {}

        FGetSharedGroupDataRequest(const TSharedPtr<FJsonObject>& obj) : FGetSharedGroupDataRequest()
        {
            readFromValue(obj);
        }

        ~FGetSharedGroupDataRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FSharedGroupDataRecord : public FPlayFabBaseModel
    {
        // Timestamp for when this data was last updated.
        FDateTime LastUpdated;

        // [optional] Unique PlayFab identifier of the user to last update this value.
        FString LastUpdatedBy;

        // [optional] Indicates whether this data can be read by all users (public) or only members of the group (private).
        Boxed<UserDataPermission> Permission;

        // [optional] Data stored for the specified group data key.
        FString Value;

        FSharedGroupDataRecord() :
            FPlayFabBaseModel(),
            LastUpdated(0),
            LastUpdatedBy(),
            Permission(),
            Value()
            {}

        FSharedGroupDataRecord(const FSharedGroupDataRecord& src) :
            FPlayFabBaseModel(),
            LastUpdated(src.LastUpdated),
            LastUpdatedBy(src.LastUpdatedBy),
            Permission(src.Permission),
            Value(src.Value)
            {}

        FSharedGroupDataRecord(const TSharedPtr<FJsonObject>& obj) : FSharedGroupDataRecord()
        {
            readFromValue(obj);
        }

        ~FSharedGroupDataRecord();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetSharedGroupDataResult : public FPlayFabBaseModel
    {
        // [optional] Data for the requested keys.
        TMap<FString, FSharedGroupDataRecord> Data;
        // [optional] List of PlayFabId identifiers for the members of this group, if requested.
        TArray<FString> Members;
        FGetSharedGroupDataResult() :
            FPlayFabBaseModel(),
            Data(),
            Members()
            {}

        FGetSharedGroupDataResult(const FGetSharedGroupDataResult& src) :
            FPlayFabBaseModel(),
            Data(src.Data),
            Members(src.Members)
            {}

        FGetSharedGroupDataResult(const TSharedPtr<FJsonObject>& obj) : FGetSharedGroupDataResult()
        {
            readFromValue(obj);
        }

        ~FGetSharedGroupDataResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetStoreItemsRequest : public FPlayFabBaseModel
    {
        // [optional] catalog version to store items from. Use default catalog version if null
        FString CatalogVersion;

        // Unqiue identifier for the store which is being requested.
        FString StoreId;

        FGetStoreItemsRequest() :
            FPlayFabBaseModel(),
            CatalogVersion(),
            StoreId()
            {}

        FGetStoreItemsRequest(const FGetStoreItemsRequest& src) :
            FPlayFabBaseModel(),
            CatalogVersion(src.CatalogVersion),
            StoreId(src.StoreId)
            {}

        FGetStoreItemsRequest(const TSharedPtr<FJsonObject>& obj) : FGetStoreItemsRequest()
        {
            readFromValue(obj);
        }

        ~FGetStoreItemsRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FStoreMarketingModel : public FPlayFabBaseModel
    {
        // [optional] Tagline for a store.
        FString Description;

        // [optional] Display name of a store as it will appear to users.
        FString DisplayName;

        // [optional] Custom data about a store.
        FJsonKeeper Metadata;

        FStoreMarketingModel() :
            FPlayFabBaseModel(),
            Description(),
            DisplayName(),
            Metadata()
            {}

        FStoreMarketingModel(const FStoreMarketingModel& src) :
            FPlayFabBaseModel(),
            Description(src.Description),
            DisplayName(src.DisplayName),
            Metadata(src.Metadata)
            {}

        FStoreMarketingModel(const TSharedPtr<FJsonObject>& obj) : FStoreMarketingModel()
        {
            readFromValue(obj);
        }

        ~FStoreMarketingModel();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    enum SourceType
    {
        SourceTypeAdmin,
        SourceTypeBackEnd,
        SourceTypeGameClient,
        SourceTypeGameServer,
        SourceTypePartner
    };

    PLAYFAB_API void writeSourceTypeEnumJSON(SourceType enumVal, JsonWriter& writer);
    PLAYFAB_API SourceType readSourceTypeFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFAB_API SourceType readSourceTypeFromValue(const FString& value);

    struct PLAYFAB_API FStoreItem : public FPlayFabBaseModel
    {
        // [optional] Store specific custom data. The data only exists as part of this store; it is not transferred to item instances
        FJsonKeeper CustomData;

        // [optional] Intended display position for this item. Note that 0 is the first position
        Boxed<uint32> DisplayPosition;

        /**
         * Unique identifier of the item as it exists in the catalog - note that this must exactly match the ItemId from the
         * catalog
         */
        FString ItemId;

        // [optional] Override prices for this item for specific currencies
        TMap<FString, uint32> RealCurrencyPrices;
        // [optional] Override prices for this item in virtual currencies and "RM" (the base Real Money purchase price, in USD pennies)
        TMap<FString, uint32> VirtualCurrencyPrices;
        FStoreItem() :
            FPlayFabBaseModel(),
            CustomData(),
            DisplayPosition(),
            ItemId(),
            RealCurrencyPrices(),
            VirtualCurrencyPrices()
            {}

        FStoreItem(const FStoreItem& src) :
            FPlayFabBaseModel(),
            CustomData(src.CustomData),
            DisplayPosition(src.DisplayPosition),
            ItemId(src.ItemId),
            RealCurrencyPrices(src.RealCurrencyPrices),
            VirtualCurrencyPrices(src.VirtualCurrencyPrices)
            {}

        FStoreItem(const TSharedPtr<FJsonObject>& obj) : FStoreItem()
        {
            readFromValue(obj);
        }

        ~FStoreItem();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetStoreItemsResult : public FPlayFabBaseModel
    {
        // [optional] The base catalog that this store is a part of.
        FString CatalogVersion;

        // [optional] Additional data about the store.
        TSharedPtr<FStoreMarketingModel> MarketingData;

        // [optional] How the store was last updated (Admin or a third party).
        Boxed<SourceType> Source;

        // [optional] Array of items which can be purchased from this store.
        TArray<FStoreItem> Store;
        // [optional] The ID of this store.
        FString StoreId;

        FGetStoreItemsResult() :
            FPlayFabBaseModel(),
            CatalogVersion(),
            MarketingData(nullptr),
            Source(),
            Store(),
            StoreId()
            {}

        FGetStoreItemsResult(const FGetStoreItemsResult& src) :
            FPlayFabBaseModel(),
            CatalogVersion(src.CatalogVersion),
            MarketingData(src.MarketingData.IsValid() ? MakeShareable(new FStoreMarketingModel(*src.MarketingData)) : nullptr),
            Source(src.Source),
            Store(src.Store),
            StoreId(src.StoreId)
            {}

        FGetStoreItemsResult(const TSharedPtr<FJsonObject>& obj) : FGetStoreItemsResult()
        {
            readFromValue(obj);
        }

        ~FGetStoreItemsResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetTimeRequest : public FPlayFabBaseModel
    {
        FGetTimeRequest() :
            FPlayFabBaseModel()
            {}

        FGetTimeRequest(const FGetTimeRequest& src) :
            FPlayFabBaseModel()
            {}

        FGetTimeRequest(const TSharedPtr<FJsonObject>& obj) : FGetTimeRequest()
        {
            readFromValue(obj);
        }

        ~FGetTimeRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetTimeResult : public FPlayFabBaseModel
    {
        // Current server time when the request was received, in UTC
        FDateTime Time;

        FGetTimeResult() :
            FPlayFabBaseModel(),
            Time(0)
            {}

        FGetTimeResult(const FGetTimeResult& src) :
            FPlayFabBaseModel(),
            Time(src.Time)
            {}

        FGetTimeResult(const TSharedPtr<FJsonObject>& obj) : FGetTimeResult()
        {
            readFromValue(obj);
        }

        ~FGetTimeResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetTitleDataRequest : public FPlayFabBaseModel
    {
        // [optional] Specific keys to search for in the title data (leave null to get all keys)
        TArray<FString> Keys;
        FGetTitleDataRequest() :
            FPlayFabBaseModel(),
            Keys()
            {}

        FGetTitleDataRequest(const FGetTitleDataRequest& src) :
            FPlayFabBaseModel(),
            Keys(src.Keys)
            {}

        FGetTitleDataRequest(const TSharedPtr<FJsonObject>& obj) : FGetTitleDataRequest()
        {
            readFromValue(obj);
        }

        ~FGetTitleDataRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetTitleDataResult : public FPlayFabBaseModel
    {
        // [optional] a dictionary object of key / value pairs
        TMap<FString, FString> Data;
        FGetTitleDataResult() :
            FPlayFabBaseModel(),
            Data()
            {}

        FGetTitleDataResult(const FGetTitleDataResult& src) :
            FPlayFabBaseModel(),
            Data(src.Data)
            {}

        FGetTitleDataResult(const TSharedPtr<FJsonObject>& obj) : FGetTitleDataResult()
        {
            readFromValue(obj);
        }

        ~FGetTitleDataResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetTitleNewsRequest : public FPlayFabBaseModel
    {
        // [optional] Limits the results to the last n entries. Defaults to 10 if not set.
        Boxed<int32> Count;

        FGetTitleNewsRequest() :
            FPlayFabBaseModel(),
            Count()
            {}

        FGetTitleNewsRequest(const FGetTitleNewsRequest& src) :
            FPlayFabBaseModel(),
            Count(src.Count)
            {}

        FGetTitleNewsRequest(const TSharedPtr<FJsonObject>& obj) : FGetTitleNewsRequest()
        {
            readFromValue(obj);
        }

        ~FGetTitleNewsRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FTitleNewsItem : public FPlayFabBaseModel
    {
        // [optional] News item text.
        FString Body;

        // [optional] Unique identifier of news item.
        FString NewsId;

        // Date and time when the news items was posted.
        FDateTime Timestamp;

        // [optional] Title of the news item.
        FString Title;

        FTitleNewsItem() :
            FPlayFabBaseModel(),
            Body(),
            NewsId(),
            Timestamp(0),
            Title()
            {}

        FTitleNewsItem(const FTitleNewsItem& src) :
            FPlayFabBaseModel(),
            Body(src.Body),
            NewsId(src.NewsId),
            Timestamp(src.Timestamp),
            Title(src.Title)
            {}

        FTitleNewsItem(const TSharedPtr<FJsonObject>& obj) : FTitleNewsItem()
        {
            readFromValue(obj);
        }

        ~FTitleNewsItem();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetTitleNewsResult : public FPlayFabBaseModel
    {
        // [optional] Array of news items.
        TArray<FTitleNewsItem> News;
        FGetTitleNewsResult() :
            FPlayFabBaseModel(),
            News()
            {}

        FGetTitleNewsResult(const FGetTitleNewsResult& src) :
            FPlayFabBaseModel(),
            News(src.News)
            {}

        FGetTitleNewsResult(const TSharedPtr<FJsonObject>& obj) : FGetTitleNewsResult()
        {
            readFromValue(obj);
        }

        ~FGetTitleNewsResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetTitlePublicKeyRequest : public FPlayFabBaseModel
    {
        /**
         * Unique identifier for the title, found in the Settings > Game Properties section of the PlayFab developer site when a
         * title has been selected.
         */
        FString TitleId;

        // The shared secret key for this title
        FString TitleSharedSecret;

        FGetTitlePublicKeyRequest() :
            FPlayFabBaseModel(),
            TitleId(),
            TitleSharedSecret()
            {}

        FGetTitlePublicKeyRequest(const FGetTitlePublicKeyRequest& src) :
            FPlayFabBaseModel(),
            TitleId(src.TitleId),
            TitleSharedSecret(src.TitleSharedSecret)
            {}

        FGetTitlePublicKeyRequest(const TSharedPtr<FJsonObject>& obj) : FGetTitlePublicKeyRequest()
        {
            readFromValue(obj);
        }

        ~FGetTitlePublicKeyRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetTitlePublicKeyResult : public FPlayFabBaseModel
    {
        // [optional] Base64 encoded RSA CSP byte array blob containing the title's public RSA key
        FString RSAPublicKey;

        FGetTitlePublicKeyResult() :
            FPlayFabBaseModel(),
            RSAPublicKey()
            {}

        FGetTitlePublicKeyResult(const FGetTitlePublicKeyResult& src) :
            FPlayFabBaseModel(),
            RSAPublicKey(src.RSAPublicKey)
            {}

        FGetTitlePublicKeyResult(const TSharedPtr<FJsonObject>& obj) : FGetTitlePublicKeyResult()
        {
            readFromValue(obj);
        }

        ~FGetTitlePublicKeyResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetTradeStatusRequest : public FPlayFabBaseModel
    {
        // Player who opened trade.
        FString OfferingPlayerId;

        // Trade identifier as returned by OpenTradeOffer.
        FString TradeId;

        FGetTradeStatusRequest() :
            FPlayFabBaseModel(),
            OfferingPlayerId(),
            TradeId()
            {}

        FGetTradeStatusRequest(const FGetTradeStatusRequest& src) :
            FPlayFabBaseModel(),
            OfferingPlayerId(src.OfferingPlayerId),
            TradeId(src.TradeId)
            {}

        FGetTradeStatusRequest(const TSharedPtr<FJsonObject>& obj) : FGetTradeStatusRequest()
        {
            readFromValue(obj);
        }

        ~FGetTradeStatusRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetTradeStatusResponse : public FPlayFabBaseModel
    {
        // [optional] Information about the requested trade.
        TSharedPtr<FTradeInfo> Trade;

        FGetTradeStatusResponse() :
            FPlayFabBaseModel(),
            Trade(nullptr)
            {}

        FGetTradeStatusResponse(const FGetTradeStatusResponse& src) :
            FPlayFabBaseModel(),
            Trade(src.Trade.IsValid() ? MakeShareable(new FTradeInfo(*src.Trade)) : nullptr)
            {}

        FGetTradeStatusResponse(const TSharedPtr<FJsonObject>& obj) : FGetTradeStatusResponse()
        {
            readFromValue(obj);
        }

        ~FGetTradeStatusResponse();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetUserDataRequest : public FPlayFabBaseModel
    {
        /**
         * [optional] The version that currently exists according to the caller. The call will return the data for all of the keys if the
         * version in the system is greater than this.
         */
        Boxed<uint32> IfChangedFromDataVersion;

        // [optional] List of unique keys to load from.
        TArray<FString> Keys;
        /**
         * [optional] Unique PlayFab identifier of the user to load data for. Optional, defaults to yourself if not set. When specified to a
         * PlayFab id of another player, then this will only return public keys for that account.
         */
        FString PlayFabId;

        FGetUserDataRequest() :
            FPlayFabBaseModel(),
            IfChangedFromDataVersion(),
            Keys(),
            PlayFabId()
            {}

        FGetUserDataRequest(const FGetUserDataRequest& src) :
            FPlayFabBaseModel(),
            IfChangedFromDataVersion(src.IfChangedFromDataVersion),
            Keys(src.Keys),
            PlayFabId(src.PlayFabId)
            {}

        FGetUserDataRequest(const TSharedPtr<FJsonObject>& obj) : FGetUserDataRequest()
        {
            readFromValue(obj);
        }

        ~FGetUserDataRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetUserDataResult : public FPlayFabBaseModel
    {
        // [optional] User specific data for this title.
        TMap<FString, FUserDataRecord> Data;
        /**
         * Indicates the current version of the data that has been set. This is incremented with every set call for that type of
         * data (read-only, internal, etc). This version can be provided in Get calls to find updated data.
         */
        uint32 DataVersion;

        FGetUserDataResult() :
            FPlayFabBaseModel(),
            Data(),
            DataVersion(0)
            {}

        FGetUserDataResult(const FGetUserDataResult& src) :
            FPlayFabBaseModel(),
            Data(src.Data),
            DataVersion(src.DataVersion)
            {}

        FGetUserDataResult(const TSharedPtr<FJsonObject>& obj) : FGetUserDataResult()
        {
            readFromValue(obj);
        }

        ~FGetUserDataResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetUserInventoryRequest : public FPlayFabBaseModel
    {
        FGetUserInventoryRequest() :
            FPlayFabBaseModel()
            {}

        FGetUserInventoryRequest(const FGetUserInventoryRequest& src) :
            FPlayFabBaseModel()
            {}

        FGetUserInventoryRequest(const TSharedPtr<FJsonObject>& obj) : FGetUserInventoryRequest()
        {
            readFromValue(obj);
        }

        ~FGetUserInventoryRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetUserInventoryResult : public FPlayFabBaseModel
    {
        // [optional] Array of inventory items belonging to the user.
        TArray<FItemInstance> Inventory;
        // [optional] Array of virtual currency balance(s) belonging to the user.
        TMap<FString, int32> VirtualCurrency;
        // [optional] Array of remaining times and timestamps for virtual currencies.
        TMap<FString, FVirtualCurrencyRechargeTime> VirtualCurrencyRechargeTimes;
        FGetUserInventoryResult() :
            FPlayFabBaseModel(),
            Inventory(),
            VirtualCurrency(),
            VirtualCurrencyRechargeTimes()
            {}

        FGetUserInventoryResult(const FGetUserInventoryResult& src) :
            FPlayFabBaseModel(),
            Inventory(src.Inventory),
            VirtualCurrency(src.VirtualCurrency),
            VirtualCurrencyRechargeTimes(src.VirtualCurrencyRechargeTimes)
            {}

        FGetUserInventoryResult(const TSharedPtr<FJsonObject>& obj) : FGetUserInventoryResult()
        {
            readFromValue(obj);
        }

        ~FGetUserInventoryResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetWindowsHelloChallengeRequest : public FPlayFabBaseModel
    {
        // SHA256 hash of the PublicKey generated by Windows Hello.
        FString PublicKeyHint;

        /**
         * Unique identifier for the title, found in the Settings > Game Properties section of the PlayFab developer site when a
         * title has been selected.
         */
        FString TitleId;

        FGetWindowsHelloChallengeRequest() :
            FPlayFabBaseModel(),
            PublicKeyHint(),
            TitleId()
            {}

        FGetWindowsHelloChallengeRequest(const FGetWindowsHelloChallengeRequest& src) :
            FPlayFabBaseModel(),
            PublicKeyHint(src.PublicKeyHint),
            TitleId(src.TitleId)
            {}

        FGetWindowsHelloChallengeRequest(const TSharedPtr<FJsonObject>& obj) : FGetWindowsHelloChallengeRequest()
        {
            readFromValue(obj);
        }

        ~FGetWindowsHelloChallengeRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGetWindowsHelloChallengeResponse : public FPlayFabBaseModel
    {
        // [optional] Server generated challenge to be signed by the user.
        FString Challenge;

        FGetWindowsHelloChallengeResponse() :
            FPlayFabBaseModel(),
            Challenge()
            {}

        FGetWindowsHelloChallengeResponse(const FGetWindowsHelloChallengeResponse& src) :
            FPlayFabBaseModel(),
            Challenge(src.Challenge)
            {}

        FGetWindowsHelloChallengeResponse(const TSharedPtr<FJsonObject>& obj) : FGetWindowsHelloChallengeResponse()
        {
            readFromValue(obj);
        }

        ~FGetWindowsHelloChallengeResponse();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGrantCharacterToUserRequest : public FPlayFabBaseModel
    {
        // [optional] Catalog version from which items are to be granted.
        FString CatalogVersion;

        // Non-unique display name of the character being granted (1-20 characters in length).
        FString CharacterName;

        /**
         * Catalog item identifier of the item in the user's inventory that corresponds to the character in the catalog to be
         * created.
         */
        FString ItemId;

        FGrantCharacterToUserRequest() :
            FPlayFabBaseModel(),
            CatalogVersion(),
            CharacterName(),
            ItemId()
            {}

        FGrantCharacterToUserRequest(const FGrantCharacterToUserRequest& src) :
            FPlayFabBaseModel(),
            CatalogVersion(src.CatalogVersion),
            CharacterName(src.CharacterName),
            ItemId(src.ItemId)
            {}

        FGrantCharacterToUserRequest(const TSharedPtr<FJsonObject>& obj) : FGrantCharacterToUserRequest()
        {
            readFromValue(obj);
        }

        ~FGrantCharacterToUserRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FGrantCharacterToUserResult : public FPlayFabBaseModel
    {
        // [optional] Unique identifier tagged to this character.
        FString CharacterId;

        // [optional] Type of character that was created.
        FString CharacterType;

        // Indicates whether this character was created successfully.
        bool Result;

        FGrantCharacterToUserResult() :
            FPlayFabBaseModel(),
            CharacterId(),
            CharacterType(),
            Result(false)
            {}

        FGrantCharacterToUserResult(const FGrantCharacterToUserResult& src) :
            FPlayFabBaseModel(),
            CharacterId(src.CharacterId),
            CharacterType(src.CharacterType),
            Result(src.Result)
            {}

        FGrantCharacterToUserResult(const TSharedPtr<FJsonObject>& obj) : FGrantCharacterToUserResult()
        {
            readFromValue(obj);
        }

        ~FGrantCharacterToUserResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FItemPurchaseRequest : public FPlayFabBaseModel
    {
        // [optional] Title-specific text concerning this purchase.
        FString Annotation;

        // Unique ItemId of the item to purchase.
        FString ItemId;

        // How many of this item to purchase.
        uint32 Quantity;

        // [optional] Items to be upgraded as a result of this purchase (upgraded items are hidden, as they are "replaced" by the new items).
        TArray<FString> UpgradeFromItems;
        FItemPurchaseRequest() :
            FPlayFabBaseModel(),
            Annotation(),
            ItemId(),
            Quantity(0),
            UpgradeFromItems()
            {}

        FItemPurchaseRequest(const FItemPurchaseRequest& src) :
            FPlayFabBaseModel(),
            Annotation(src.Annotation),
            ItemId(src.ItemId),
            Quantity(src.Quantity),
            UpgradeFromItems(src.UpgradeFromItems)
            {}

        FItemPurchaseRequest(const TSharedPtr<FJsonObject>& obj) : FItemPurchaseRequest()
        {
            readFromValue(obj);
        }

        ~FItemPurchaseRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FLinkAndroidDeviceIDRequest : public FPlayFabBaseModel
    {
        // [optional] Specific model of the user's device.
        FString AndroidDevice;

        // Android device identifier for the user's device.
        FString AndroidDeviceId;

        // [optional] If another user is already linked to the device, unlink the other user and re-link.
        Boxed<bool> ForceLink;

        // [optional] Specific Operating System version for the user's device.
        FString OS;

        FLinkAndroidDeviceIDRequest() :
            FPlayFabBaseModel(),
            AndroidDevice(),
            AndroidDeviceId(),
            ForceLink(),
            OS()
            {}

        FLinkAndroidDeviceIDRequest(const FLinkAndroidDeviceIDRequest& src) :
            FPlayFabBaseModel(),
            AndroidDevice(src.AndroidDevice),
            AndroidDeviceId(src.AndroidDeviceId),
            ForceLink(src.ForceLink),
            OS(src.OS)
            {}

        FLinkAndroidDeviceIDRequest(const TSharedPtr<FJsonObject>& obj) : FLinkAndroidDeviceIDRequest()
        {
            readFromValue(obj);
        }

        ~FLinkAndroidDeviceIDRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FLinkAndroidDeviceIDResult : public FPlayFabBaseModel
    {
        FLinkAndroidDeviceIDResult() :
            FPlayFabBaseModel()
            {}

        FLinkAndroidDeviceIDResult(const FLinkAndroidDeviceIDResult& src) :
            FPlayFabBaseModel()
            {}

        FLinkAndroidDeviceIDResult(const TSharedPtr<FJsonObject>& obj) : FLinkAndroidDeviceIDResult()
        {
            readFromValue(obj);
        }

        ~FLinkAndroidDeviceIDResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FLinkCustomIDRequest : public FPlayFabBaseModel
    {
        // Custom unique identifier for the user, generated by the title.
        FString CustomId;

        // [optional] If another user is already linked to the custom ID, unlink the other user and re-link.
        Boxed<bool> ForceLink;

        FLinkCustomIDRequest() :
            FPlayFabBaseModel(),
            CustomId(),
            ForceLink()
            {}

        FLinkCustomIDRequest(const FLinkCustomIDRequest& src) :
            FPlayFabBaseModel(),
            CustomId(src.CustomId),
            ForceLink(src.ForceLink)
            {}

        FLinkCustomIDRequest(const TSharedPtr<FJsonObject>& obj) : FLinkCustomIDRequest()
        {
            readFromValue(obj);
        }

        ~FLinkCustomIDRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FLinkCustomIDResult : public FPlayFabBaseModel
    {
        FLinkCustomIDResult() :
            FPlayFabBaseModel()
            {}

        FLinkCustomIDResult(const FLinkCustomIDResult& src) :
            FPlayFabBaseModel()
            {}

        FLinkCustomIDResult(const TSharedPtr<FJsonObject>& obj) : FLinkCustomIDResult()
        {
            readFromValue(obj);
        }

        ~FLinkCustomIDResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FLinkFacebookAccountRequest : public FPlayFabBaseModel
    {
        // Unique identifier from Facebook for the user.
        FString AccessToken;

        // [optional] If another user is already linked to the account, unlink the other user and re-link.
        Boxed<bool> ForceLink;

        FLinkFacebookAccountRequest() :
            FPlayFabBaseModel(),
            AccessToken(),
            ForceLink()
            {}

        FLinkFacebookAccountRequest(const FLinkFacebookAccountRequest& src) :
            FPlayFabBaseModel(),
            AccessToken(src.AccessToken),
            ForceLink(src.ForceLink)
            {}

        FLinkFacebookAccountRequest(const TSharedPtr<FJsonObject>& obj) : FLinkFacebookAccountRequest()
        {
            readFromValue(obj);
        }

        ~FLinkFacebookAccountRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FLinkFacebookAccountResult : public FPlayFabBaseModel
    {
        FLinkFacebookAccountResult() :
            FPlayFabBaseModel()
            {}

        FLinkFacebookAccountResult(const FLinkFacebookAccountResult& src) :
            FPlayFabBaseModel()
            {}

        FLinkFacebookAccountResult(const TSharedPtr<FJsonObject>& obj) : FLinkFacebookAccountResult()
        {
            readFromValue(obj);
        }

        ~FLinkFacebookAccountResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FLinkGameCenterAccountRequest : public FPlayFabBaseModel
    {
        // [optional] If another user is already linked to the account, unlink the other user and re-link.
        Boxed<bool> ForceLink;

        // Game Center identifier for the player account to be linked.
        FString GameCenterId;

        FLinkGameCenterAccountRequest() :
            FPlayFabBaseModel(),
            ForceLink(),
            GameCenterId()
            {}

        FLinkGameCenterAccountRequest(const FLinkGameCenterAccountRequest& src) :
            FPlayFabBaseModel(),
            ForceLink(src.ForceLink),
            GameCenterId(src.GameCenterId)
            {}

        FLinkGameCenterAccountRequest(const TSharedPtr<FJsonObject>& obj) : FLinkGameCenterAccountRequest()
        {
            readFromValue(obj);
        }

        ~FLinkGameCenterAccountRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FLinkGameCenterAccountResult : public FPlayFabBaseModel
    {
        FLinkGameCenterAccountResult() :
            FPlayFabBaseModel()
            {}

        FLinkGameCenterAccountResult(const FLinkGameCenterAccountResult& src) :
            FPlayFabBaseModel()
            {}

        FLinkGameCenterAccountResult(const TSharedPtr<FJsonObject>& obj) : FLinkGameCenterAccountResult()
        {
            readFromValue(obj);
        }

        ~FLinkGameCenterAccountResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FLinkGoogleAccountRequest : public FPlayFabBaseModel
    {
        // [optional] If another user is already linked to the account, unlink the other user and re-link.
        Boxed<bool> ForceLink;

        /**
         * [optional] Server authentication code obtained on the client by calling getServerAuthCode()
         * (https://developers.google.com/identity/sign-in/android/offline-access) from Google Play for the user.
         */
        FString ServerAuthCode;

        FLinkGoogleAccountRequest() :
            FPlayFabBaseModel(),
            ForceLink(),
            ServerAuthCode()
            {}

        FLinkGoogleAccountRequest(const FLinkGoogleAccountRequest& src) :
            FPlayFabBaseModel(),
            ForceLink(src.ForceLink),
            ServerAuthCode(src.ServerAuthCode)
            {}

        FLinkGoogleAccountRequest(const TSharedPtr<FJsonObject>& obj) : FLinkGoogleAccountRequest()
        {
            readFromValue(obj);
        }

        ~FLinkGoogleAccountRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FLinkGoogleAccountResult : public FPlayFabBaseModel
    {
        FLinkGoogleAccountResult() :
            FPlayFabBaseModel()
            {}

        FLinkGoogleAccountResult(const FLinkGoogleAccountResult& src) :
            FPlayFabBaseModel()
            {}

        FLinkGoogleAccountResult(const TSharedPtr<FJsonObject>& obj) : FLinkGoogleAccountResult()
        {
            readFromValue(obj);
        }

        ~FLinkGoogleAccountResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FLinkIOSDeviceIDRequest : public FPlayFabBaseModel
    {
        // Vendor-specific iOS identifier for the user's device.
        FString DeviceId;

        // [optional] Specific model of the user's device.
        FString DeviceModel;

        // [optional] If another user is already linked to the device, unlink the other user and re-link.
        Boxed<bool> ForceLink;

        // [optional] Specific Operating System version for the user's device.
        FString OS;

        FLinkIOSDeviceIDRequest() :
            FPlayFabBaseModel(),
            DeviceId(),
            DeviceModel(),
            ForceLink(),
            OS()
            {}

        FLinkIOSDeviceIDRequest(const FLinkIOSDeviceIDRequest& src) :
            FPlayFabBaseModel(),
            DeviceId(src.DeviceId),
            DeviceModel(src.DeviceModel),
            ForceLink(src.ForceLink),
            OS(src.OS)
            {}

        FLinkIOSDeviceIDRequest(const TSharedPtr<FJsonObject>& obj) : FLinkIOSDeviceIDRequest()
        {
            readFromValue(obj);
        }

        ~FLinkIOSDeviceIDRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FLinkIOSDeviceIDResult : public FPlayFabBaseModel
    {
        FLinkIOSDeviceIDResult() :
            FPlayFabBaseModel()
            {}

        FLinkIOSDeviceIDResult(const FLinkIOSDeviceIDResult& src) :
            FPlayFabBaseModel()
            {}

        FLinkIOSDeviceIDResult(const TSharedPtr<FJsonObject>& obj) : FLinkIOSDeviceIDResult()
        {
            readFromValue(obj);
        }

        ~FLinkIOSDeviceIDResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FLinkKongregateAccountRequest : public FPlayFabBaseModel
    {
        // Valid session auth ticket issued by Kongregate
        FString AuthTicket;

        // [optional] If another user is already linked to the account, unlink the other user and re-link.
        Boxed<bool> ForceLink;

        // Numeric user ID assigned by Kongregate
        FString KongregateId;

        FLinkKongregateAccountRequest() :
            FPlayFabBaseModel(),
            AuthTicket(),
            ForceLink(),
            KongregateId()
            {}

        FLinkKongregateAccountRequest(const FLinkKongregateAccountRequest& src) :
            FPlayFabBaseModel(),
            AuthTicket(src.AuthTicket),
            ForceLink(src.ForceLink),
            KongregateId(src.KongregateId)
            {}

        FLinkKongregateAccountRequest(const TSharedPtr<FJsonObject>& obj) : FLinkKongregateAccountRequest()
        {
            readFromValue(obj);
        }

        ~FLinkKongregateAccountRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FLinkKongregateAccountResult : public FPlayFabBaseModel
    {
        FLinkKongregateAccountResult() :
            FPlayFabBaseModel()
            {}

        FLinkKongregateAccountResult(const FLinkKongregateAccountResult& src) :
            FPlayFabBaseModel()
            {}

        FLinkKongregateAccountResult(const TSharedPtr<FJsonObject>& obj) : FLinkKongregateAccountResult()
        {
            readFromValue(obj);
        }

        ~FLinkKongregateAccountResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FLinkSteamAccountRequest : public FPlayFabBaseModel
    {
        // [optional] If another user is already linked to the account, unlink the other user and re-link.
        Boxed<bool> ForceLink;

        /**
         * Authentication token for the user, returned as a byte array from Steam, and converted to a string (for example, the byte
         * 0x08 should become "08").
         */
        FString SteamTicket;

        FLinkSteamAccountRequest() :
            FPlayFabBaseModel(),
            ForceLink(),
            SteamTicket()
            {}

        FLinkSteamAccountRequest(const FLinkSteamAccountRequest& src) :
            FPlayFabBaseModel(),
            ForceLink(src.ForceLink),
            SteamTicket(src.SteamTicket)
            {}

        FLinkSteamAccountRequest(const TSharedPtr<FJsonObject>& obj) : FLinkSteamAccountRequest()
        {
            readFromValue(obj);
        }

        ~FLinkSteamAccountRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FLinkSteamAccountResult : public FPlayFabBaseModel
    {
        FLinkSteamAccountResult() :
            FPlayFabBaseModel()
            {}

        FLinkSteamAccountResult(const FLinkSteamAccountResult& src) :
            FPlayFabBaseModel()
            {}

        FLinkSteamAccountResult(const TSharedPtr<FJsonObject>& obj) : FLinkSteamAccountResult()
        {
            readFromValue(obj);
        }

        ~FLinkSteamAccountResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FLinkTwitchAccountRequest : public FPlayFabBaseModel
    {
        // Valid token issued by Twitch
        FString AccessToken;

        // [optional] If another user is already linked to the account, unlink the other user and re-link.
        Boxed<bool> ForceLink;

        FLinkTwitchAccountRequest() :
            FPlayFabBaseModel(),
            AccessToken(),
            ForceLink()
            {}

        FLinkTwitchAccountRequest(const FLinkTwitchAccountRequest& src) :
            FPlayFabBaseModel(),
            AccessToken(src.AccessToken),
            ForceLink(src.ForceLink)
            {}

        FLinkTwitchAccountRequest(const TSharedPtr<FJsonObject>& obj) : FLinkTwitchAccountRequest()
        {
            readFromValue(obj);
        }

        ~FLinkTwitchAccountRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FLinkTwitchAccountResult : public FPlayFabBaseModel
    {
        FLinkTwitchAccountResult() :
            FPlayFabBaseModel()
            {}

        FLinkTwitchAccountResult(const FLinkTwitchAccountResult& src) :
            FPlayFabBaseModel()
            {}

        FLinkTwitchAccountResult(const TSharedPtr<FJsonObject>& obj) : FLinkTwitchAccountResult()
        {
            readFromValue(obj);
        }

        ~FLinkTwitchAccountResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FLinkWindowsHelloAccountRequest : public FPlayFabBaseModel
    {
        // [optional] Device name.
        FString DeviceName;

        // [optional] If another user is already linked to the account, unlink the other user and re-link.
        Boxed<bool> ForceLink;

        // PublicKey generated by Windows Hello.
        FString PublicKey;

        // Player's user named used by Windows Hello.
        FString UserName;

        FLinkWindowsHelloAccountRequest() :
            FPlayFabBaseModel(),
            DeviceName(),
            ForceLink(),
            PublicKey(),
            UserName()
            {}

        FLinkWindowsHelloAccountRequest(const FLinkWindowsHelloAccountRequest& src) :
            FPlayFabBaseModel(),
            DeviceName(src.DeviceName),
            ForceLink(src.ForceLink),
            PublicKey(src.PublicKey),
            UserName(src.UserName)
            {}

        FLinkWindowsHelloAccountRequest(const TSharedPtr<FJsonObject>& obj) : FLinkWindowsHelloAccountRequest()
        {
            readFromValue(obj);
        }

        ~FLinkWindowsHelloAccountRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FLinkWindowsHelloAccountResponse : public FPlayFabBaseModel
    {
        FLinkWindowsHelloAccountResponse() :
            FPlayFabBaseModel()
            {}

        FLinkWindowsHelloAccountResponse(const FLinkWindowsHelloAccountResponse& src) :
            FPlayFabBaseModel()
            {}

        FLinkWindowsHelloAccountResponse(const TSharedPtr<FJsonObject>& obj) : FLinkWindowsHelloAccountResponse()
        {
            readFromValue(obj);
        }

        ~FLinkWindowsHelloAccountResponse();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FListUsersCharactersRequest : public FPlayFabBaseModel
    {
        // [optional] Unique PlayFab assigned ID of the user on whom the operation will be performed.
        FString PlayFabId;

        FListUsersCharactersRequest() :
            FPlayFabBaseModel(),
            PlayFabId()
            {}

        FListUsersCharactersRequest(const FListUsersCharactersRequest& src) :
            FPlayFabBaseModel(),
            PlayFabId(src.PlayFabId)
            {}

        FListUsersCharactersRequest(const TSharedPtr<FJsonObject>& obj) : FListUsersCharactersRequest()
        {
            readFromValue(obj);
        }

        ~FListUsersCharactersRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FListUsersCharactersResult : public FPlayFabBaseModel
    {
        // [optional] The requested list of characters.
        TArray<FCharacterResult> Characters;
        FListUsersCharactersResult() :
            FPlayFabBaseModel(),
            Characters()
            {}

        FListUsersCharactersResult(const FListUsersCharactersResult& src) :
            FPlayFabBaseModel(),
            Characters(src.Characters)
            {}

        FListUsersCharactersResult(const TSharedPtr<FJsonObject>& obj) : FListUsersCharactersResult()
        {
            readFromValue(obj);
        }

        ~FListUsersCharactersResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUserSettings : public FPlayFabBaseModel
    {
        // Boolean for whether this player is eligible for gathering device info.
        bool GatherDeviceInfo;

        // Boolean for whether this player is eligible for ad tracking.
        bool NeedsAttribution;

        FUserSettings() :
            FPlayFabBaseModel(),
            GatherDeviceInfo(false),
            NeedsAttribution(false)
            {}

        FUserSettings(const FUserSettings& src) :
            FPlayFabBaseModel(),
            GatherDeviceInfo(src.GatherDeviceInfo),
            NeedsAttribution(src.NeedsAttribution)
            {}

        FUserSettings(const TSharedPtr<FJsonObject>& obj) : FUserSettings()
        {
            readFromValue(obj);
        }

        ~FUserSettings();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FLoginResult : public FPlayFabBaseModel
    {
        /**
         * [optional] If LoginTitlePlayerAccountEntity flag is set on the login request the title_player_account will also be logged in and
         * returned.
         */
        TSharedPtr<FEntityTokenResponse> EntityToken;

        // [optional] Results for requested info.
        TSharedPtr<FGetPlayerCombinedInfoResultPayload> InfoResultPayload;

        // [optional] The time of this user's previous login. If there was no previous login, then it's DateTime.MinValue
        Boxed<FDateTime> LastLoginTime;

        // True if the account was newly created on this login.
        bool NewlyCreated;

        // [optional] Player's unique PlayFabId.
        FString PlayFabId;

        // [optional] Unique token authorizing the user and game at the server level, for the current session.
        FString SessionTicket;

        // [optional] Settings specific to this user.
        TSharedPtr<FUserSettings> SettingsForUser;

        FLoginResult() :
            FPlayFabBaseModel(),
            EntityToken(nullptr),
            InfoResultPayload(nullptr),
            LastLoginTime(),
            NewlyCreated(false),
            PlayFabId(),
            SessionTicket(),
            SettingsForUser(nullptr)
            {}

        FLoginResult(const FLoginResult& src) :
            FPlayFabBaseModel(),
            EntityToken(src.EntityToken.IsValid() ? MakeShareable(new FEntityTokenResponse(*src.EntityToken)) : nullptr),
            InfoResultPayload(src.InfoResultPayload.IsValid() ? MakeShareable(new FGetPlayerCombinedInfoResultPayload(*src.InfoResultPayload)) : nullptr),
            LastLoginTime(src.LastLoginTime),
            NewlyCreated(src.NewlyCreated),
            PlayFabId(src.PlayFabId),
            SessionTicket(src.SessionTicket),
            SettingsForUser(src.SettingsForUser.IsValid() ? MakeShareable(new FUserSettings(*src.SettingsForUser)) : nullptr)
            {}

        FLoginResult(const TSharedPtr<FJsonObject>& obj) : FLoginResult()
        {
            readFromValue(obj);
        }

        ~FLoginResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FLoginWithAndroidDeviceIDRequest : public FPlayFabBaseModel
    {
        // [optional] Specific model of the user's device.
        FString AndroidDevice;

        // [optional] Android device identifier for the user's device.
        FString AndroidDeviceId;

        // [optional] Automatically create a PlayFab account if one is not currently linked to this ID.
        Boxed<bool> CreateAccount;

        // [optional] Base64 encoded body that is encrypted with the Title's public RSA key (Enterprise Only).
        FString EncryptedRequest;

        // [optional] Flags for which pieces of info to return for the user.
        TSharedPtr<FGetPlayerCombinedInfoRequestParams> InfoRequestParameters;

        // [optional] Flag to automatically login the player's title_player_account and return the associated entity token.
        Boxed<bool> LoginTitlePlayerAccountEntity;

        // [optional] Specific Operating System version for the user's device.
        FString OS;

        // [optional] Player secret that is used to verify API request signatures (Enterprise Only).
        FString PlayerSecret;

        /**
         * Unique identifier for the title, found in the Settings > Game Properties section of the PlayFab developer site when a
         * title has been selected.
         */
        FString TitleId;

        FLoginWithAndroidDeviceIDRequest() :
            FPlayFabBaseModel(),
            AndroidDevice(),
            AndroidDeviceId(),
            CreateAccount(),
            EncryptedRequest(),
            InfoRequestParameters(nullptr),
            LoginTitlePlayerAccountEntity(),
            OS(),
            PlayerSecret(),
            TitleId()
            {}

        FLoginWithAndroidDeviceIDRequest(const FLoginWithAndroidDeviceIDRequest& src) :
            FPlayFabBaseModel(),
            AndroidDevice(src.AndroidDevice),
            AndroidDeviceId(src.AndroidDeviceId),
            CreateAccount(src.CreateAccount),
            EncryptedRequest(src.EncryptedRequest),
            InfoRequestParameters(src.InfoRequestParameters.IsValid() ? MakeShareable(new FGetPlayerCombinedInfoRequestParams(*src.InfoRequestParameters)) : nullptr),
            LoginTitlePlayerAccountEntity(src.LoginTitlePlayerAccountEntity),
            OS(src.OS),
            PlayerSecret(src.PlayerSecret),
            TitleId(src.TitleId)
            {}

        FLoginWithAndroidDeviceIDRequest(const TSharedPtr<FJsonObject>& obj) : FLoginWithAndroidDeviceIDRequest()
        {
            readFromValue(obj);
        }

        ~FLoginWithAndroidDeviceIDRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FLoginWithCustomIDRequest : public FPlayFabBaseModel
    {
        // [optional] Automatically create a PlayFab account if one is not currently linked to this ID.
        Boxed<bool> CreateAccount;

        // [optional] Custom unique identifier for the user, generated by the title.
        FString CustomId;

        // [optional] Base64 encoded body that is encrypted with the Title's public RSA key (Enterprise Only).
        FString EncryptedRequest;

        // [optional] Flags for which pieces of info to return for the user.
        TSharedPtr<FGetPlayerCombinedInfoRequestParams> InfoRequestParameters;

        // [optional] Flag to automatically login the player's title_player_account and return the associated entity token.
        Boxed<bool> LoginTitlePlayerAccountEntity;

        // [optional] Player secret that is used to verify API request signatures (Enterprise Only).
        FString PlayerSecret;

        /**
         * Unique identifier for the title, found in the Settings > Game Properties section of the PlayFab developer site when a
         * title has been selected.
         */
        FString TitleId;

        FLoginWithCustomIDRequest() :
            FPlayFabBaseModel(),
            CreateAccount(),
            CustomId(),
            EncryptedRequest(),
            InfoRequestParameters(nullptr),
            LoginTitlePlayerAccountEntity(),
            PlayerSecret(),
            TitleId()
            {}

        FLoginWithCustomIDRequest(const FLoginWithCustomIDRequest& src) :
            FPlayFabBaseModel(),
            CreateAccount(src.CreateAccount),
            CustomId(src.CustomId),
            EncryptedRequest(src.EncryptedRequest),
            InfoRequestParameters(src.InfoRequestParameters.IsValid() ? MakeShareable(new FGetPlayerCombinedInfoRequestParams(*src.InfoRequestParameters)) : nullptr),
            LoginTitlePlayerAccountEntity(src.LoginTitlePlayerAccountEntity),
            PlayerSecret(src.PlayerSecret),
            TitleId(src.TitleId)
            {}

        FLoginWithCustomIDRequest(const TSharedPtr<FJsonObject>& obj) : FLoginWithCustomIDRequest()
        {
            readFromValue(obj);
        }

        ~FLoginWithCustomIDRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FLoginWithEmailAddressRequest : public FPlayFabBaseModel
    {
        // Email address for the account.
        FString Email;

        // [optional] Flags for which pieces of info to return for the user.
        TSharedPtr<FGetPlayerCombinedInfoRequestParams> InfoRequestParameters;

        // [optional] Flag to automatically login the player's title_player_account and return the associated entity token.
        Boxed<bool> LoginTitlePlayerAccountEntity;

        // Password for the PlayFab account (6-100 characters)
        FString Password;

        /**
         * Unique identifier for the title, found in the Settings > Game Properties section of the PlayFab developer site when a
         * title has been selected.
         */
        FString TitleId;

        FLoginWithEmailAddressRequest() :
            FPlayFabBaseModel(),
            Email(),
            InfoRequestParameters(nullptr),
            LoginTitlePlayerAccountEntity(),
            Password(),
            TitleId()
            {}

        FLoginWithEmailAddressRequest(const FLoginWithEmailAddressRequest& src) :
            FPlayFabBaseModel(),
            Email(src.Email),
            InfoRequestParameters(src.InfoRequestParameters.IsValid() ? MakeShareable(new FGetPlayerCombinedInfoRequestParams(*src.InfoRequestParameters)) : nullptr),
            LoginTitlePlayerAccountEntity(src.LoginTitlePlayerAccountEntity),
            Password(src.Password),
            TitleId(src.TitleId)
            {}

        FLoginWithEmailAddressRequest(const TSharedPtr<FJsonObject>& obj) : FLoginWithEmailAddressRequest()
        {
            readFromValue(obj);
        }

        ~FLoginWithEmailAddressRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FLoginWithFacebookRequest : public FPlayFabBaseModel
    {
        // Unique identifier from Facebook for the user.
        FString AccessToken;

        // [optional] Automatically create a PlayFab account if one is not currently linked to this ID.
        Boxed<bool> CreateAccount;

        // [optional] Base64 encoded body that is encrypted with the Title's public RSA key (Enterprise Only).
        FString EncryptedRequest;

        // [optional] Flags for which pieces of info to return for the user.
        TSharedPtr<FGetPlayerCombinedInfoRequestParams> InfoRequestParameters;

        // [optional] Flag to automatically login the player's title_player_account and return the associated entity token.
        Boxed<bool> LoginTitlePlayerAccountEntity;

        // [optional] Player secret that is used to verify API request signatures (Enterprise Only).
        FString PlayerSecret;

        /**
         * Unique identifier for the title, found in the Settings > Game Properties section of the PlayFab developer site when a
         * title has been selected.
         */
        FString TitleId;

        FLoginWithFacebookRequest() :
            FPlayFabBaseModel(),
            AccessToken(),
            CreateAccount(),
            EncryptedRequest(),
            InfoRequestParameters(nullptr),
            LoginTitlePlayerAccountEntity(),
            PlayerSecret(),
            TitleId()
            {}

        FLoginWithFacebookRequest(const FLoginWithFacebookRequest& src) :
            FPlayFabBaseModel(),
            AccessToken(src.AccessToken),
            CreateAccount(src.CreateAccount),
            EncryptedRequest(src.EncryptedRequest),
            InfoRequestParameters(src.InfoRequestParameters.IsValid() ? MakeShareable(new FGetPlayerCombinedInfoRequestParams(*src.InfoRequestParameters)) : nullptr),
            LoginTitlePlayerAccountEntity(src.LoginTitlePlayerAccountEntity),
            PlayerSecret(src.PlayerSecret),
            TitleId(src.TitleId)
            {}

        FLoginWithFacebookRequest(const TSharedPtr<FJsonObject>& obj) : FLoginWithFacebookRequest()
        {
            readFromValue(obj);
        }

        ~FLoginWithFacebookRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FLoginWithGameCenterRequest : public FPlayFabBaseModel
    {
        // [optional] Automatically create a PlayFab account if one is not currently linked to this ID.
        Boxed<bool> CreateAccount;

        // [optional] Base64 encoded body that is encrypted with the Title's public RSA key (Enterprise Only).
        FString EncryptedRequest;

        // [optional] Flags for which pieces of info to return for the user.
        TSharedPtr<FGetPlayerCombinedInfoRequestParams> InfoRequestParameters;

        // [optional] Flag to automatically login the player's title_player_account and return the associated entity token.
        Boxed<bool> LoginTitlePlayerAccountEntity;

        // [optional] Unique Game Center player id.
        FString PlayerId;

        // [optional] Player secret that is used to verify API request signatures (Enterprise Only).
        FString PlayerSecret;

        /**
         * Unique identifier for the title, found in the Settings > Game Properties section of the PlayFab developer site when a
         * title has been selected.
         */
        FString TitleId;

        FLoginWithGameCenterRequest() :
            FPlayFabBaseModel(),
            CreateAccount(),
            EncryptedRequest(),
            InfoRequestParameters(nullptr),
            LoginTitlePlayerAccountEntity(),
            PlayerId(),
            PlayerSecret(),
            TitleId()
            {}

        FLoginWithGameCenterRequest(const FLoginWithGameCenterRequest& src) :
            FPlayFabBaseModel(),
            CreateAccount(src.CreateAccount),
            EncryptedRequest(src.EncryptedRequest),
            InfoRequestParameters(src.InfoRequestParameters.IsValid() ? MakeShareable(new FGetPlayerCombinedInfoRequestParams(*src.InfoRequestParameters)) : nullptr),
            LoginTitlePlayerAccountEntity(src.LoginTitlePlayerAccountEntity),
            PlayerId(src.PlayerId),
            PlayerSecret(src.PlayerSecret),
            TitleId(src.TitleId)
            {}

        FLoginWithGameCenterRequest(const TSharedPtr<FJsonObject>& obj) : FLoginWithGameCenterRequest()
        {
            readFromValue(obj);
        }

        ~FLoginWithGameCenterRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FLoginWithGoogleAccountRequest : public FPlayFabBaseModel
    {
        // [optional] Automatically create a PlayFab account if one is not currently linked to this ID.
        Boxed<bool> CreateAccount;

        // [optional] Base64 encoded body that is encrypted with the Title's public RSA key (Enterprise Only).
        FString EncryptedRequest;

        // [optional] Flags for which pieces of info to return for the user.
        TSharedPtr<FGetPlayerCombinedInfoRequestParams> InfoRequestParameters;

        // [optional] Flag to automatically login the player's title_player_account and return the associated entity token.
        Boxed<bool> LoginTitlePlayerAccountEntity;

        // [optional] Player secret that is used to verify API request signatures (Enterprise Only).
        FString PlayerSecret;

        /**
         * [optional] OAuth 2.0 server authentication code obtained on the client by calling the getServerAuthCode()
         * (https://developers.google.com/identity/sign-in/android/offline-access) Google client API.
         */
        FString ServerAuthCode;

        /**
         * Unique identifier for the title, found in the Settings > Game Properties section of the PlayFab developer site when a
         * title has been selected.
         */
        FString TitleId;

        FLoginWithGoogleAccountRequest() :
            FPlayFabBaseModel(),
            CreateAccount(),
            EncryptedRequest(),
            InfoRequestParameters(nullptr),
            LoginTitlePlayerAccountEntity(),
            PlayerSecret(),
            ServerAuthCode(),
            TitleId()
            {}

        FLoginWithGoogleAccountRequest(const FLoginWithGoogleAccountRequest& src) :
            FPlayFabBaseModel(),
            CreateAccount(src.CreateAccount),
            EncryptedRequest(src.EncryptedRequest),
            InfoRequestParameters(src.InfoRequestParameters.IsValid() ? MakeShareable(new FGetPlayerCombinedInfoRequestParams(*src.InfoRequestParameters)) : nullptr),
            LoginTitlePlayerAccountEntity(src.LoginTitlePlayerAccountEntity),
            PlayerSecret(src.PlayerSecret),
            ServerAuthCode(src.ServerAuthCode),
            TitleId(src.TitleId)
            {}

        FLoginWithGoogleAccountRequest(const TSharedPtr<FJsonObject>& obj) : FLoginWithGoogleAccountRequest()
        {
            readFromValue(obj);
        }

        ~FLoginWithGoogleAccountRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FLoginWithIOSDeviceIDRequest : public FPlayFabBaseModel
    {
        // [optional] Automatically create a PlayFab account if one is not currently linked to this ID.
        Boxed<bool> CreateAccount;

        // [optional] Vendor-specific iOS identifier for the user's device.
        FString DeviceId;

        // [optional] Specific model of the user's device.
        FString DeviceModel;

        // [optional] Base64 encoded body that is encrypted with the Title's public RSA key (Enterprise Only).
        FString EncryptedRequest;

        // [optional] Flags for which pieces of info to return for the user.
        TSharedPtr<FGetPlayerCombinedInfoRequestParams> InfoRequestParameters;

        // [optional] Flag to automatically login the player's title_player_account and return the associated entity token.
        Boxed<bool> LoginTitlePlayerAccountEntity;

        // [optional] Specific Operating System version for the user's device.
        FString OS;

        // [optional] Player secret that is used to verify API request signatures (Enterprise Only).
        FString PlayerSecret;

        /**
         * Unique identifier for the title, found in the Settings > Game Properties section of the PlayFab developer site when a
         * title has been selected.
         */
        FString TitleId;

        FLoginWithIOSDeviceIDRequest() :
            FPlayFabBaseModel(),
            CreateAccount(),
            DeviceId(),
            DeviceModel(),
            EncryptedRequest(),
            InfoRequestParameters(nullptr),
            LoginTitlePlayerAccountEntity(),
            OS(),
            PlayerSecret(),
            TitleId()
            {}

        FLoginWithIOSDeviceIDRequest(const FLoginWithIOSDeviceIDRequest& src) :
            FPlayFabBaseModel(),
            CreateAccount(src.CreateAccount),
            DeviceId(src.DeviceId),
            DeviceModel(src.DeviceModel),
            EncryptedRequest(src.EncryptedRequest),
            InfoRequestParameters(src.InfoRequestParameters.IsValid() ? MakeShareable(new FGetPlayerCombinedInfoRequestParams(*src.InfoRequestParameters)) : nullptr),
            LoginTitlePlayerAccountEntity(src.LoginTitlePlayerAccountEntity),
            OS(src.OS),
            PlayerSecret(src.PlayerSecret),
            TitleId(src.TitleId)
            {}

        FLoginWithIOSDeviceIDRequest(const TSharedPtr<FJsonObject>& obj) : FLoginWithIOSDeviceIDRequest()
        {
            readFromValue(obj);
        }

        ~FLoginWithIOSDeviceIDRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FLoginWithKongregateRequest : public FPlayFabBaseModel
    {
        // [optional] Token issued by Kongregate's client API for the user.
        FString AuthTicket;

        // [optional] Automatically create a PlayFab account if one is not currently linked to this ID.
        Boxed<bool> CreateAccount;

        // [optional] Base64 encoded body that is encrypted with the Title's public RSA key (Enterprise Only).
        FString EncryptedRequest;

        // [optional] Flags for which pieces of info to return for the user.
        TSharedPtr<FGetPlayerCombinedInfoRequestParams> InfoRequestParameters;

        // [optional] Numeric user ID assigned by Kongregate
        FString KongregateId;

        // [optional] Flag to automatically login the player's title_player_account and return the associated entity token.
        Boxed<bool> LoginTitlePlayerAccountEntity;

        // [optional] Player secret that is used to verify API request signatures (Enterprise Only).
        FString PlayerSecret;

        /**
         * Unique identifier for the title, found in the Settings > Game Properties section of the PlayFab developer site when a
         * title has been selected.
         */
        FString TitleId;

        FLoginWithKongregateRequest() :
            FPlayFabBaseModel(),
            AuthTicket(),
            CreateAccount(),
            EncryptedRequest(),
            InfoRequestParameters(nullptr),
            KongregateId(),
            LoginTitlePlayerAccountEntity(),
            PlayerSecret(),
            TitleId()
            {}

        FLoginWithKongregateRequest(const FLoginWithKongregateRequest& src) :
            FPlayFabBaseModel(),
            AuthTicket(src.AuthTicket),
            CreateAccount(src.CreateAccount),
            EncryptedRequest(src.EncryptedRequest),
            InfoRequestParameters(src.InfoRequestParameters.IsValid() ? MakeShareable(new FGetPlayerCombinedInfoRequestParams(*src.InfoRequestParameters)) : nullptr),
            KongregateId(src.KongregateId),
            LoginTitlePlayerAccountEntity(src.LoginTitlePlayerAccountEntity),
            PlayerSecret(src.PlayerSecret),
            TitleId(src.TitleId)
            {}

        FLoginWithKongregateRequest(const TSharedPtr<FJsonObject>& obj) : FLoginWithKongregateRequest()
        {
            readFromValue(obj);
        }

        ~FLoginWithKongregateRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FLoginWithPlayFabRequest : public FPlayFabBaseModel
    {
        // [optional] Flags for which pieces of info to return for the user.
        TSharedPtr<FGetPlayerCombinedInfoRequestParams> InfoRequestParameters;

        // [optional] Flag to automatically login the player's title_player_account and return the associated entity token.
        Boxed<bool> LoginTitlePlayerAccountEntity;

        // Password for the PlayFab account (6-100 characters)
        FString Password;

        /**
         * Unique identifier for the title, found in the Settings > Game Properties section of the PlayFab developer site when a
         * title has been selected.
         */
        FString TitleId;

        // PlayFab username for the account.
        FString Username;

        FLoginWithPlayFabRequest() :
            FPlayFabBaseModel(),
            InfoRequestParameters(nullptr),
            LoginTitlePlayerAccountEntity(),
            Password(),
            TitleId(),
            Username()
            {}

        FLoginWithPlayFabRequest(const FLoginWithPlayFabRequest& src) :
            FPlayFabBaseModel(),
            InfoRequestParameters(src.InfoRequestParameters.IsValid() ? MakeShareable(new FGetPlayerCombinedInfoRequestParams(*src.InfoRequestParameters)) : nullptr),
            LoginTitlePlayerAccountEntity(src.LoginTitlePlayerAccountEntity),
            Password(src.Password),
            TitleId(src.TitleId),
            Username(src.Username)
            {}

        FLoginWithPlayFabRequest(const TSharedPtr<FJsonObject>& obj) : FLoginWithPlayFabRequest()
        {
            readFromValue(obj);
        }

        ~FLoginWithPlayFabRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FLoginWithSteamRequest : public FPlayFabBaseModel
    {
        // [optional] Automatically create a PlayFab account if one is not currently linked to this ID.
        Boxed<bool> CreateAccount;

        // [optional] Base64 encoded body that is encrypted with the Title's public RSA key (Enterprise Only).
        FString EncryptedRequest;

        // [optional] Flags for which pieces of info to return for the user.
        TSharedPtr<FGetPlayerCombinedInfoRequestParams> InfoRequestParameters;

        // [optional] Flag to automatically login the player's title_player_account and return the associated entity token.
        Boxed<bool> LoginTitlePlayerAccountEntity;

        // [optional] Player secret that is used to verify API request signatures (Enterprise Only).
        FString PlayerSecret;

        /**
         * [optional] Authentication token for the user, returned as a byte array from Steam, and converted to a string (for example, the byte
         * 0x08 should become "08").
         */
        FString SteamTicket;

        /**
         * Unique identifier for the title, found in the Settings > Game Properties section of the PlayFab developer site when a
         * title has been selected.
         */
        FString TitleId;

        FLoginWithSteamRequest() :
            FPlayFabBaseModel(),
            CreateAccount(),
            EncryptedRequest(),
            InfoRequestParameters(nullptr),
            LoginTitlePlayerAccountEntity(),
            PlayerSecret(),
            SteamTicket(),
            TitleId()
            {}

        FLoginWithSteamRequest(const FLoginWithSteamRequest& src) :
            FPlayFabBaseModel(),
            CreateAccount(src.CreateAccount),
            EncryptedRequest(src.EncryptedRequest),
            InfoRequestParameters(src.InfoRequestParameters.IsValid() ? MakeShareable(new FGetPlayerCombinedInfoRequestParams(*src.InfoRequestParameters)) : nullptr),
            LoginTitlePlayerAccountEntity(src.LoginTitlePlayerAccountEntity),
            PlayerSecret(src.PlayerSecret),
            SteamTicket(src.SteamTicket),
            TitleId(src.TitleId)
            {}

        FLoginWithSteamRequest(const TSharedPtr<FJsonObject>& obj) : FLoginWithSteamRequest()
        {
            readFromValue(obj);
        }

        ~FLoginWithSteamRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FLoginWithTwitchRequest : public FPlayFabBaseModel
    {
        // [optional] Token issued by Twitch's API for the user.
        FString AccessToken;

        // [optional] Automatically create a PlayFab account if one is not currently linked to this ID.
        Boxed<bool> CreateAccount;

        // [optional] Base64 encoded body that is encrypted with the Title's public RSA key (Enterprise Only).
        FString EncryptedRequest;

        // [optional] Flags for which pieces of info to return for the user.
        TSharedPtr<FGetPlayerCombinedInfoRequestParams> InfoRequestParameters;

        // [optional] Flag to automatically login the player's title_player_account and return the associated entity token.
        Boxed<bool> LoginTitlePlayerAccountEntity;

        // [optional] Player secret that is used to verify API request signatures (Enterprise Only).
        FString PlayerSecret;

        /**
         * Unique identifier for the title, found in the Settings > Game Properties section of the PlayFab developer site when a
         * title has been selected.
         */
        FString TitleId;

        FLoginWithTwitchRequest() :
            FPlayFabBaseModel(),
            AccessToken(),
            CreateAccount(),
            EncryptedRequest(),
            InfoRequestParameters(nullptr),
            LoginTitlePlayerAccountEntity(),
            PlayerSecret(),
            TitleId()
            {}

        FLoginWithTwitchRequest(const FLoginWithTwitchRequest& src) :
            FPlayFabBaseModel(),
            AccessToken(src.AccessToken),
            CreateAccount(src.CreateAccount),
            EncryptedRequest(src.EncryptedRequest),
            InfoRequestParameters(src.InfoRequestParameters.IsValid() ? MakeShareable(new FGetPlayerCombinedInfoRequestParams(*src.InfoRequestParameters)) : nullptr),
            LoginTitlePlayerAccountEntity(src.LoginTitlePlayerAccountEntity),
            PlayerSecret(src.PlayerSecret),
            TitleId(src.TitleId)
            {}

        FLoginWithTwitchRequest(const TSharedPtr<FJsonObject>& obj) : FLoginWithTwitchRequest()
        {
            readFromValue(obj);
        }

        ~FLoginWithTwitchRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FLoginWithWindowsHelloRequest : public FPlayFabBaseModel
    {
        // The signed response from the user for the Challenge.
        FString ChallengeSignature;

        // [optional] Flags for which pieces of info to return for the user.
        TSharedPtr<FGetPlayerCombinedInfoRequestParams> InfoRequestParameters;

        // [optional] Flag to automatically login the player's title_player_account and return the associated entity token.
        Boxed<bool> LoginTitlePlayerAccountEntity;

        // SHA256 hash of the PublicKey generated by Windows Hello.
        FString PublicKeyHint;

        /**
         * Unique identifier for the title, found in the Settings > Game Properties section of the PlayFab developer site when a
         * title has been selected.
         */
        FString TitleId;

        FLoginWithWindowsHelloRequest() :
            FPlayFabBaseModel(),
            ChallengeSignature(),
            InfoRequestParameters(nullptr),
            LoginTitlePlayerAccountEntity(),
            PublicKeyHint(),
            TitleId()
            {}

        FLoginWithWindowsHelloRequest(const FLoginWithWindowsHelloRequest& src) :
            FPlayFabBaseModel(),
            ChallengeSignature(src.ChallengeSignature),
            InfoRequestParameters(src.InfoRequestParameters.IsValid() ? MakeShareable(new FGetPlayerCombinedInfoRequestParams(*src.InfoRequestParameters)) : nullptr),
            LoginTitlePlayerAccountEntity(src.LoginTitlePlayerAccountEntity),
            PublicKeyHint(src.PublicKeyHint),
            TitleId(src.TitleId)
            {}

        FLoginWithWindowsHelloRequest(const TSharedPtr<FJsonObject>& obj) : FLoginWithWindowsHelloRequest()
        {
            readFromValue(obj);
        }

        ~FLoginWithWindowsHelloRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FMatchmakeRequest : public FPlayFabBaseModel
    {
        // [optional] Build version to match against. [Note: Required if LobbyId is not specified]
        FString BuildVersion;

        // [optional] Character to use for stats based matching. Leave null to use account stats.
        FString CharacterId;

        // [optional] Game mode to match make against. [Note: Required if LobbyId is not specified]
        FString GameMode;

        // [optional] Lobby identifier to match make against. This is used to select a specific Game Server Instance.
        FString LobbyId;

        // [optional] Region to match make against. [Note: Required if LobbyId is not specified]
        Boxed<Region> pfRegion;

        // [optional] Start a game session if one with an open slot is not found. Defaults to true.
        Boxed<bool> StartNewIfNoneFound;

        // [optional] Player statistic to use in finding a match. May be null for no stat-based matching.
        FString StatisticName;

        // [optional] Filter to include and/or exclude Game Server Instances associated with certain Tags
        TSharedPtr<FCollectionFilter> TagFilter;

        FMatchmakeRequest() :
            FPlayFabBaseModel(),
            BuildVersion(),
            CharacterId(),
            GameMode(),
            LobbyId(),
            pfRegion(),
            StartNewIfNoneFound(),
            StatisticName(),
            TagFilter(nullptr)
            {}

        FMatchmakeRequest(const FMatchmakeRequest& src) :
            FPlayFabBaseModel(),
            BuildVersion(src.BuildVersion),
            CharacterId(src.CharacterId),
            GameMode(src.GameMode),
            LobbyId(src.LobbyId),
            pfRegion(src.pfRegion),
            StartNewIfNoneFound(src.StartNewIfNoneFound),
            StatisticName(src.StatisticName),
            TagFilter(src.TagFilter.IsValid() ? MakeShareable(new FCollectionFilter(*src.TagFilter)) : nullptr)
            {}

        FMatchmakeRequest(const TSharedPtr<FJsonObject>& obj) : FMatchmakeRequest()
        {
            readFromValue(obj);
        }

        ~FMatchmakeRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    enum MatchmakeStatus
    {
        MatchmakeStatusComplete,
        MatchmakeStatusWaiting,
        MatchmakeStatusGameNotFound,
        MatchmakeStatusNoAvailableSlots,
        MatchmakeStatusSessionClosed
    };

    PLAYFAB_API void writeMatchmakeStatusEnumJSON(MatchmakeStatus enumVal, JsonWriter& writer);
    PLAYFAB_API MatchmakeStatus readMatchmakeStatusFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFAB_API MatchmakeStatus readMatchmakeStatusFromValue(const FString& value);

    struct PLAYFAB_API FMatchmakeResult : public FPlayFabBaseModel
    {
        // [optional] timestamp for when the server will expire, if applicable
        FString Expires;

        // [optional] unique lobby identifier of the server matched
        FString LobbyID;

        // [optional] time in milliseconds the application is configured to wait on matchmaking results
        Boxed<int32> PollWaitTimeMS;

        // [optional] IPV4 address of the server
        FString ServerHostname;

        // [optional] IPV6 address of the server
        FString ServerIPV6Address;

        // [optional] port number to use for non-http communications with the server
        Boxed<int32> ServerPort;

        // [optional] result of match making process
        Boxed<MatchmakeStatus> Status;

        // [optional] server authorization ticket (used by RedeemMatchmakerTicket to validate user insertion into the game)
        FString Ticket;

        FMatchmakeResult() :
            FPlayFabBaseModel(),
            Expires(),
            LobbyID(),
            PollWaitTimeMS(),
            ServerHostname(),
            ServerIPV6Address(),
            ServerPort(),
            Status(),
            Ticket()
            {}

        FMatchmakeResult(const FMatchmakeResult& src) :
            FPlayFabBaseModel(),
            Expires(src.Expires),
            LobbyID(src.LobbyID),
            PollWaitTimeMS(src.PollWaitTimeMS),
            ServerHostname(src.ServerHostname),
            ServerIPV6Address(src.ServerIPV6Address),
            ServerPort(src.ServerPort),
            Status(src.Status),
            Ticket(src.Ticket)
            {}

        FMatchmakeResult(const TSharedPtr<FJsonObject>& obj) : FMatchmakeResult()
        {
            readFromValue(obj);
        }

        ~FMatchmakeResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FModifyUserVirtualCurrencyResult : public FPlayFabBaseModel
    {
        // Balance of the virtual currency after modification.
        int32 Balance;

        /**
         * Amount added or subtracted from the user's virtual currency. Maximum VC balance is Int32 (2,147,483,647). Any increase
         * over this value will be discarded.
         */
        int32 BalanceChange;

        // [optional] User currency was subtracted from.
        FString PlayFabId;

        // [optional] Name of the virtual currency which was modified.
        FString VirtualCurrency;

        FModifyUserVirtualCurrencyResult() :
            FPlayFabBaseModel(),
            Balance(0),
            BalanceChange(0),
            PlayFabId(),
            VirtualCurrency()
            {}

        FModifyUserVirtualCurrencyResult(const FModifyUserVirtualCurrencyResult& src) :
            FPlayFabBaseModel(),
            Balance(src.Balance),
            BalanceChange(src.BalanceChange),
            PlayFabId(src.PlayFabId),
            VirtualCurrency(src.VirtualCurrency)
            {}

        FModifyUserVirtualCurrencyResult(const TSharedPtr<FJsonObject>& obj) : FModifyUserVirtualCurrencyResult()
        {
            readFromValue(obj);
        }

        ~FModifyUserVirtualCurrencyResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FNameIdentifier : public FPlayFabBaseModel
    {
        // [optional] undefined
        FString Id;

        // [optional] undefined
        FString Name;

        FNameIdentifier() :
            FPlayFabBaseModel(),
            Id(),
            Name()
            {}

        FNameIdentifier(const FNameIdentifier& src) :
            FPlayFabBaseModel(),
            Id(src.Id),
            Name(src.Name)
            {}

        FNameIdentifier(const TSharedPtr<FJsonObject>& obj) : FNameIdentifier()
        {
            readFromValue(obj);
        }

        ~FNameIdentifier();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FOpenTradeRequest : public FPlayFabBaseModel
    {
        /**
         * [optional] Players who are allowed to accept the trade. If null, the trade may be accepted by any player. If empty, the trade may
         * not be accepted by any player.
         */
        TArray<FString> AllowedPlayerIds;
        // [optional] Player inventory items offered for trade. If not set, the trade is effectively a gift request
        TArray<FString> OfferedInventoryInstanceIds;
        // [optional] Catalog items accepted for the trade. If not set, the trade is effectively a gift.
        TArray<FString> RequestedCatalogItemIds;
        FOpenTradeRequest() :
            FPlayFabBaseModel(),
            AllowedPlayerIds(),
            OfferedInventoryInstanceIds(),
            RequestedCatalogItemIds()
            {}

        FOpenTradeRequest(const FOpenTradeRequest& src) :
            FPlayFabBaseModel(),
            AllowedPlayerIds(src.AllowedPlayerIds),
            OfferedInventoryInstanceIds(src.OfferedInventoryInstanceIds),
            RequestedCatalogItemIds(src.RequestedCatalogItemIds)
            {}

        FOpenTradeRequest(const TSharedPtr<FJsonObject>& obj) : FOpenTradeRequest()
        {
            readFromValue(obj);
        }

        ~FOpenTradeRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FOpenTradeResponse : public FPlayFabBaseModel
    {
        // [optional] The information about the trade that was just opened.
        TSharedPtr<FTradeInfo> Trade;

        FOpenTradeResponse() :
            FPlayFabBaseModel(),
            Trade(nullptr)
            {}

        FOpenTradeResponse(const FOpenTradeResponse& src) :
            FPlayFabBaseModel(),
            Trade(src.Trade.IsValid() ? MakeShareable(new FTradeInfo(*src.Trade)) : nullptr)
            {}

        FOpenTradeResponse(const TSharedPtr<FJsonObject>& obj) : FOpenTradeResponse()
        {
            readFromValue(obj);
        }

        ~FOpenTradeResponse();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FPayForPurchaseRequest : public FPlayFabBaseModel
    {
        // Currency to use to fund the purchase.
        FString Currency;

        // Purchase order identifier returned from StartPurchase.
        FString OrderId;

        // Payment provider to use to fund the purchase.
        FString ProviderName;

        // [optional] Payment provider transaction identifier. Required for Facebook Payments.
        FString ProviderTransactionId;

        FPayForPurchaseRequest() :
            FPlayFabBaseModel(),
            Currency(),
            OrderId(),
            ProviderName(),
            ProviderTransactionId()
            {}

        FPayForPurchaseRequest(const FPayForPurchaseRequest& src) :
            FPlayFabBaseModel(),
            Currency(src.Currency),
            OrderId(src.OrderId),
            ProviderName(src.ProviderName),
            ProviderTransactionId(src.ProviderTransactionId)
            {}

        FPayForPurchaseRequest(const TSharedPtr<FJsonObject>& obj) : FPayForPurchaseRequest()
        {
            readFromValue(obj);
        }

        ~FPayForPurchaseRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    enum TransactionStatus
    {
        TransactionStatusCreateCart,
        TransactionStatusInit,
        TransactionStatusApproved,
        TransactionStatusSucceeded,
        TransactionStatusFailedByProvider,
        TransactionStatusDisputePending,
        TransactionStatusRefundPending,
        TransactionStatusRefunded,
        TransactionStatusRefundFailed,
        TransactionStatusChargedBack,
        TransactionStatusFailedByUber,
        TransactionStatusFailedByPlayFab,
        TransactionStatusRevoked,
        TransactionStatusTradePending,
        TransactionStatusTraded,
        TransactionStatusUpgraded,
        TransactionStatusStackPending,
        TransactionStatusStacked,
        TransactionStatusOther,
        TransactionStatusFailed
    };

    PLAYFAB_API void writeTransactionStatusEnumJSON(TransactionStatus enumVal, JsonWriter& writer);
    PLAYFAB_API TransactionStatus readTransactionStatusFromValue(const TSharedPtr<FJsonValue>& value);
    PLAYFAB_API TransactionStatus readTransactionStatusFromValue(const FString& value);

    struct PLAYFAB_API FPayForPurchaseResult : public FPlayFabBaseModel
    {
        // Local credit applied to the transaction (provider specific).
        uint32 CreditApplied;

        // [optional] Purchase order identifier.
        FString OrderId;

        // [optional] Provider used for the transaction.
        FString ProviderData;

        // [optional] A token generated by the provider to authenticate the request (provider-specific).
        FString ProviderToken;

        // [optional] URL to the purchase provider page that details the purchase.
        FString PurchaseConfirmationPageURL;

        // [optional] Currency for the transaction, may be a virtual currency or real money.
        FString PurchaseCurrency;

        // Cost of the transaction.
        uint32 PurchasePrice;

        // [optional] Status of the transaction.
        Boxed<TransactionStatus> Status;

        // [optional] Virtual currencies granted by the transaction, if any.
        TMap<FString, int32> VCAmount;
        // [optional] Current virtual currency balances for the user.
        TMap<FString, int32> VirtualCurrency;
        FPayForPurchaseResult() :
            FPlayFabBaseModel(),
            CreditApplied(0),
            OrderId(),
            ProviderData(),
            ProviderToken(),
            PurchaseConfirmationPageURL(),
            PurchaseCurrency(),
            PurchasePrice(0),
            Status(),
            VCAmount(),
            VirtualCurrency()
            {}

        FPayForPurchaseResult(const FPayForPurchaseResult& src) :
            FPlayFabBaseModel(),
            CreditApplied(src.CreditApplied),
            OrderId(src.OrderId),
            ProviderData(src.ProviderData),
            ProviderToken(src.ProviderToken),
            PurchaseConfirmationPageURL(src.PurchaseConfirmationPageURL),
            PurchaseCurrency(src.PurchaseCurrency),
            PurchasePrice(src.PurchasePrice),
            Status(src.Status),
            VCAmount(src.VCAmount),
            VirtualCurrency(src.VirtualCurrency)
            {}

        FPayForPurchaseResult(const TSharedPtr<FJsonObject>& obj) : FPayForPurchaseResult()
        {
            readFromValue(obj);
        }

        ~FPayForPurchaseResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FPaymentOption : public FPlayFabBaseModel
    {
        // [optional] Specific currency to use to fund the purchase.
        FString Currency;

        // Amount of the specified currency needed for the purchase.
        uint32 Price;

        // [optional] Name of the purchase provider for this option.
        FString ProviderName;

        // Amount of existing credit the user has with the provider.
        uint32 StoreCredit;

        FPaymentOption() :
            FPlayFabBaseModel(),
            Currency(),
            Price(0),
            ProviderName(),
            StoreCredit(0)
            {}

        FPaymentOption(const FPaymentOption& src) :
            FPlayFabBaseModel(),
            Currency(src.Currency),
            Price(src.Price),
            ProviderName(src.ProviderName),
            StoreCredit(src.StoreCredit)
            {}

        FPaymentOption(const TSharedPtr<FJsonObject>& obj) : FPaymentOption()
        {
            readFromValue(obj);
        }

        ~FPaymentOption();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FPurchaseItemRequest : public FPlayFabBaseModel
    {
        // [optional] Catalog version for the items to be purchased (defaults to most recent version.
        FString CatalogVersion;

        // [optional] Unique PlayFab assigned ID for a specific character owned by a user
        FString CharacterId;

        // Unique identifier of the item to purchase.
        FString ItemId;

        // Price the client expects to pay for the item (in case a new catalog or store was uploaded, with new prices).
        int32 Price;

        // [optional] Store to buy this item through. If not set, prices default to those in the catalog.
        FString StoreId;

        // Virtual currency to use to purchase the item.
        FString VirtualCurrency;

        FPurchaseItemRequest() :
            FPlayFabBaseModel(),
            CatalogVersion(),
            CharacterId(),
            ItemId(),
            Price(0),
            StoreId(),
            VirtualCurrency()
            {}

        FPurchaseItemRequest(const FPurchaseItemRequest& src) :
            FPlayFabBaseModel(),
            CatalogVersion(src.CatalogVersion),
            CharacterId(src.CharacterId),
            ItemId(src.ItemId),
            Price(src.Price),
            StoreId(src.StoreId),
            VirtualCurrency(src.VirtualCurrency)
            {}

        FPurchaseItemRequest(const TSharedPtr<FJsonObject>& obj) : FPurchaseItemRequest()
        {
            readFromValue(obj);
        }

        ~FPurchaseItemRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FPurchaseItemResult : public FPlayFabBaseModel
    {
        // [optional] Details for the items purchased.
        TArray<FItemInstance> Items;
        FPurchaseItemResult() :
            FPlayFabBaseModel(),
            Items()
            {}

        FPurchaseItemResult(const FPurchaseItemResult& src) :
            FPlayFabBaseModel(),
            Items(src.Items)
            {}

        FPurchaseItemResult(const TSharedPtr<FJsonObject>& obj) : FPurchaseItemResult()
        {
            readFromValue(obj);
        }

        ~FPurchaseItemResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FRedeemCouponRequest : public FPlayFabBaseModel
    {
        // [optional] Catalog version of the coupon. If null, uses the default catalog
        FString CatalogVersion;

        // [optional] Optional identifier for the Character that should receive the item. If null, item is added to the player
        FString CharacterId;

        // Generated coupon code to redeem.
        FString CouponCode;

        FRedeemCouponRequest() :
            FPlayFabBaseModel(),
            CatalogVersion(),
            CharacterId(),
            CouponCode()
            {}

        FRedeemCouponRequest(const FRedeemCouponRequest& src) :
            FPlayFabBaseModel(),
            CatalogVersion(src.CatalogVersion),
            CharacterId(src.CharacterId),
            CouponCode(src.CouponCode)
            {}

        FRedeemCouponRequest(const TSharedPtr<FJsonObject>& obj) : FRedeemCouponRequest()
        {
            readFromValue(obj);
        }

        ~FRedeemCouponRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FRedeemCouponResult : public FPlayFabBaseModel
    {
        // [optional] Items granted to the player as a result of redeeming the coupon.
        TArray<FItemInstance> GrantedItems;
        FRedeemCouponResult() :
            FPlayFabBaseModel(),
            GrantedItems()
            {}

        FRedeemCouponResult(const FRedeemCouponResult& src) :
            FPlayFabBaseModel(),
            GrantedItems(src.GrantedItems)
            {}

        FRedeemCouponResult(const TSharedPtr<FJsonObject>& obj) : FRedeemCouponResult()
        {
            readFromValue(obj);
        }

        ~FRedeemCouponResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FRegisterForIOSPushNotificationRequest : public FPlayFabBaseModel
    {
        // [optional] Message to display when confirming push notification.
        FString ConfirmationMessage;

        // Unique token generated by the Apple Push Notification service when the title registered to receive push notifications.
        FString DeviceToken;

        // [optional] If true, send a test push message immediately after sucessful registration. Defaults to false.
        Boxed<bool> SendPushNotificationConfirmation;

        FRegisterForIOSPushNotificationRequest() :
            FPlayFabBaseModel(),
            ConfirmationMessage(),
            DeviceToken(),
            SendPushNotificationConfirmation()
            {}

        FRegisterForIOSPushNotificationRequest(const FRegisterForIOSPushNotificationRequest& src) :
            FPlayFabBaseModel(),
            ConfirmationMessage(src.ConfirmationMessage),
            DeviceToken(src.DeviceToken),
            SendPushNotificationConfirmation(src.SendPushNotificationConfirmation)
            {}

        FRegisterForIOSPushNotificationRequest(const TSharedPtr<FJsonObject>& obj) : FRegisterForIOSPushNotificationRequest()
        {
            readFromValue(obj);
        }

        ~FRegisterForIOSPushNotificationRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FRegisterForIOSPushNotificationResult : public FPlayFabBaseModel
    {
        FRegisterForIOSPushNotificationResult() :
            FPlayFabBaseModel()
            {}

        FRegisterForIOSPushNotificationResult(const FRegisterForIOSPushNotificationResult& src) :
            FPlayFabBaseModel()
            {}

        FRegisterForIOSPushNotificationResult(const TSharedPtr<FJsonObject>& obj) : FRegisterForIOSPushNotificationResult()
        {
            readFromValue(obj);
        }

        ~FRegisterForIOSPushNotificationResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FRegisterPlayFabUserRequest : public FPlayFabBaseModel
    {
        // [optional] An optional parameter for setting the display name for this title (3-25 characters).
        FString DisplayName;

        // [optional] User email address attached to their account
        FString Email;

        // [optional] Base64 encoded body that is encrypted with the Title's public RSA key (Enterprise Only).
        FString EncryptedRequest;

        // [optional] Flags for which pieces of info to return for the user.
        TSharedPtr<FGetPlayerCombinedInfoRequestParams> InfoRequestParameters;

        // [optional] Flag to automatically login the player's title_player_account and return the associated entity token.
        Boxed<bool> LoginTitlePlayerAccountEntity;

        // [optional] Password for the PlayFab account (6-100 characters)
        FString Password;

        // [optional] Player secret that is used to verify API request signatures (Enterprise Only).
        FString PlayerSecret;

        /**
         * [optional] An optional parameter that specifies whether both the username and email parameters are required. If true, both
         * parameters are required; if false, the user must supply either the username or email parameter. The default value is
         * true.
         */
        Boxed<bool> RequireBothUsernameAndEmail;

        /**
         * Unique identifier for the title, found in the Settings > Game Properties section of the PlayFab developer site when a
         * title has been selected.
         */
        FString TitleId;

        // [optional] PlayFab username for the account (3-20 characters)
        FString Username;

        FRegisterPlayFabUserRequest() :
            FPlayFabBaseModel(),
            DisplayName(),
            Email(),
            EncryptedRequest(),
            InfoRequestParameters(nullptr),
            LoginTitlePlayerAccountEntity(),
            Password(),
            PlayerSecret(),
            RequireBothUsernameAndEmail(),
            TitleId(),
            Username()
            {}

        FRegisterPlayFabUserRequest(const FRegisterPlayFabUserRequest& src) :
            FPlayFabBaseModel(),
            DisplayName(src.DisplayName),
            Email(src.Email),
            EncryptedRequest(src.EncryptedRequest),
            InfoRequestParameters(src.InfoRequestParameters.IsValid() ? MakeShareable(new FGetPlayerCombinedInfoRequestParams(*src.InfoRequestParameters)) : nullptr),
            LoginTitlePlayerAccountEntity(src.LoginTitlePlayerAccountEntity),
            Password(src.Password),
            PlayerSecret(src.PlayerSecret),
            RequireBothUsernameAndEmail(src.RequireBothUsernameAndEmail),
            TitleId(src.TitleId),
            Username(src.Username)
            {}

        FRegisterPlayFabUserRequest(const TSharedPtr<FJsonObject>& obj) : FRegisterPlayFabUserRequest()
        {
            readFromValue(obj);
        }

        ~FRegisterPlayFabUserRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FRegisterPlayFabUserResult : public FPlayFabBaseModel
    {
        /**
         * [optional] If LoginTitlePlayerAccountEntity flag is set on the login request the title_player_account will also be logged in and
         * returned.
         */
        TSharedPtr<FEntityTokenResponse> EntityToken;

        // [optional] PlayFab unique identifier for this newly created account.
        FString PlayFabId;

        // [optional] Unique token identifying the user and game at the server level, for the current session.
        FString SessionTicket;

        // [optional] Settings specific to this user.
        TSharedPtr<FUserSettings> SettingsForUser;

        // [optional] PlayFab unique user name.
        FString Username;

        FRegisterPlayFabUserResult() :
            FPlayFabBaseModel(),
            EntityToken(nullptr),
            PlayFabId(),
            SessionTicket(),
            SettingsForUser(nullptr),
            Username()
            {}

        FRegisterPlayFabUserResult(const FRegisterPlayFabUserResult& src) :
            FPlayFabBaseModel(),
            EntityToken(src.EntityToken.IsValid() ? MakeShareable(new FEntityTokenResponse(*src.EntityToken)) : nullptr),
            PlayFabId(src.PlayFabId),
            SessionTicket(src.SessionTicket),
            SettingsForUser(src.SettingsForUser.IsValid() ? MakeShareable(new FUserSettings(*src.SettingsForUser)) : nullptr),
            Username(src.Username)
            {}

        FRegisterPlayFabUserResult(const TSharedPtr<FJsonObject>& obj) : FRegisterPlayFabUserResult()
        {
            readFromValue(obj);
        }

        ~FRegisterPlayFabUserResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FRegisterWithWindowsHelloRequest : public FPlayFabBaseModel
    {
        // [optional] Device name.
        FString DeviceName;

        // [optional] Base64 encoded body that is encrypted with the Title's public RSA key (Enterprise Only).
        FString EncryptedRequest;

        // [optional] Flags for which pieces of info to return for the user.
        TSharedPtr<FGetPlayerCombinedInfoRequestParams> InfoRequestParameters;

        // [optional] Flag to automatically login the player's title_player_account and return the associated entity token.
        Boxed<bool> LoginTitlePlayerAccountEntity;

        // [optional] Player secret that is used to verify API request signatures (Enterprise Only).
        FString PlayerSecret;

        // [optional] PublicKey generated by Windows Hello.
        FString PublicKey;

        /**
         * Unique identifier for the title, found in the Settings > Game Properties section of the PlayFab developer site when a
         * title has been selected.
         */
        FString TitleId;

        // [optional] Player's user name used by Windows Hello.
        FString UserName;

        FRegisterWithWindowsHelloRequest() :
            FPlayFabBaseModel(),
            DeviceName(),
            EncryptedRequest(),
            InfoRequestParameters(nullptr),
            LoginTitlePlayerAccountEntity(),
            PlayerSecret(),
            PublicKey(),
            TitleId(),
            UserName()
            {}

        FRegisterWithWindowsHelloRequest(const FRegisterWithWindowsHelloRequest& src) :
            FPlayFabBaseModel(),
            DeviceName(src.DeviceName),
            EncryptedRequest(src.EncryptedRequest),
            InfoRequestParameters(src.InfoRequestParameters.IsValid() ? MakeShareable(new FGetPlayerCombinedInfoRequestParams(*src.InfoRequestParameters)) : nullptr),
            LoginTitlePlayerAccountEntity(src.LoginTitlePlayerAccountEntity),
            PlayerSecret(src.PlayerSecret),
            PublicKey(src.PublicKey),
            TitleId(src.TitleId),
            UserName(src.UserName)
            {}

        FRegisterWithWindowsHelloRequest(const TSharedPtr<FJsonObject>& obj) : FRegisterWithWindowsHelloRequest()
        {
            readFromValue(obj);
        }

        ~FRegisterWithWindowsHelloRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FRemoveContactEmailRequest : public FPlayFabBaseModel
    {
        FRemoveContactEmailRequest() :
            FPlayFabBaseModel()
            {}

        FRemoveContactEmailRequest(const FRemoveContactEmailRequest& src) :
            FPlayFabBaseModel()
            {}

        FRemoveContactEmailRequest(const TSharedPtr<FJsonObject>& obj) : FRemoveContactEmailRequest()
        {
            readFromValue(obj);
        }

        ~FRemoveContactEmailRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FRemoveContactEmailResult : public FPlayFabBaseModel
    {
        FRemoveContactEmailResult() :
            FPlayFabBaseModel()
            {}

        FRemoveContactEmailResult(const FRemoveContactEmailResult& src) :
            FPlayFabBaseModel()
            {}

        FRemoveContactEmailResult(const TSharedPtr<FJsonObject>& obj) : FRemoveContactEmailResult()
        {
            readFromValue(obj);
        }

        ~FRemoveContactEmailResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FRemoveFriendRequest : public FPlayFabBaseModel
    {
        // PlayFab identifier of the friend account which is to be removed.
        FString FriendPlayFabId;

        FRemoveFriendRequest() :
            FPlayFabBaseModel(),
            FriendPlayFabId()
            {}

        FRemoveFriendRequest(const FRemoveFriendRequest& src) :
            FPlayFabBaseModel(),
            FriendPlayFabId(src.FriendPlayFabId)
            {}

        FRemoveFriendRequest(const TSharedPtr<FJsonObject>& obj) : FRemoveFriendRequest()
        {
            readFromValue(obj);
        }

        ~FRemoveFriendRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FRemoveFriendResult : public FPlayFabBaseModel
    {
        FRemoveFriendResult() :
            FPlayFabBaseModel()
            {}

        FRemoveFriendResult(const FRemoveFriendResult& src) :
            FPlayFabBaseModel()
            {}

        FRemoveFriendResult(const TSharedPtr<FJsonObject>& obj) : FRemoveFriendResult()
        {
            readFromValue(obj);
        }

        ~FRemoveFriendResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FRemoveGenericIDRequest : public FPlayFabBaseModel
    {
        // Generic service identifier to be removed from the player.
        FGenericServiceId GenericId;

        FRemoveGenericIDRequest() :
            FPlayFabBaseModel(),
            GenericId()
            {}

        FRemoveGenericIDRequest(const FRemoveGenericIDRequest& src) :
            FPlayFabBaseModel(),
            GenericId(src.GenericId)
            {}

        FRemoveGenericIDRequest(const TSharedPtr<FJsonObject>& obj) : FRemoveGenericIDRequest()
        {
            readFromValue(obj);
        }

        ~FRemoveGenericIDRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FRemoveGenericIDResult : public FPlayFabBaseModel
    {
        FRemoveGenericIDResult() :
            FPlayFabBaseModel()
            {}

        FRemoveGenericIDResult(const FRemoveGenericIDResult& src) :
            FPlayFabBaseModel()
            {}

        FRemoveGenericIDResult(const TSharedPtr<FJsonObject>& obj) : FRemoveGenericIDResult()
        {
            readFromValue(obj);
        }

        ~FRemoveGenericIDResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FRemoveSharedGroupMembersRequest : public FPlayFabBaseModel
    {
        // An array of unique PlayFab assigned ID of the user on whom the operation will be performed.
        TArray<FString> PlayFabIds;
        // Unique identifier for the shared group.
        FString SharedGroupId;

        FRemoveSharedGroupMembersRequest() :
            FPlayFabBaseModel(),
            PlayFabIds(),
            SharedGroupId()
            {}

        FRemoveSharedGroupMembersRequest(const FRemoveSharedGroupMembersRequest& src) :
            FPlayFabBaseModel(),
            PlayFabIds(src.PlayFabIds),
            SharedGroupId(src.SharedGroupId)
            {}

        FRemoveSharedGroupMembersRequest(const TSharedPtr<FJsonObject>& obj) : FRemoveSharedGroupMembersRequest()
        {
            readFromValue(obj);
        }

        ~FRemoveSharedGroupMembersRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FRemoveSharedGroupMembersResult : public FPlayFabBaseModel
    {
        FRemoveSharedGroupMembersResult() :
            FPlayFabBaseModel()
            {}

        FRemoveSharedGroupMembersResult(const FRemoveSharedGroupMembersResult& src) :
            FPlayFabBaseModel()
            {}

        FRemoveSharedGroupMembersResult(const TSharedPtr<FJsonObject>& obj) : FRemoveSharedGroupMembersResult()
        {
            readFromValue(obj);
        }

        ~FRemoveSharedGroupMembersResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FReportPlayerClientRequest : public FPlayFabBaseModel
    {
        // [optional] Optional additional comment by reporting player.
        FString Comment;

        // Unique PlayFab identifier of the reported player.
        FString ReporteeId;

        FReportPlayerClientRequest() :
            FPlayFabBaseModel(),
            Comment(),
            ReporteeId()
            {}

        FReportPlayerClientRequest(const FReportPlayerClientRequest& src) :
            FPlayFabBaseModel(),
            Comment(src.Comment),
            ReporteeId(src.ReporteeId)
            {}

        FReportPlayerClientRequest(const TSharedPtr<FJsonObject>& obj) : FReportPlayerClientRequest()
        {
            readFromValue(obj);
        }

        ~FReportPlayerClientRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FReportPlayerClientResult : public FPlayFabBaseModel
    {
        // The number of remaining reports which may be filed today.
        int32 SubmissionsRemaining;

        FReportPlayerClientResult() :
            FPlayFabBaseModel(),
            SubmissionsRemaining(0)
            {}

        FReportPlayerClientResult(const FReportPlayerClientResult& src) :
            FPlayFabBaseModel(),
            SubmissionsRemaining(src.SubmissionsRemaining)
            {}

        FReportPlayerClientResult(const TSharedPtr<FJsonObject>& obj) : FReportPlayerClientResult()
        {
            readFromValue(obj);
        }

        ~FReportPlayerClientResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FRestoreIOSPurchasesRequest : public FPlayFabBaseModel
    {
        // Base64 encoded receipt data, passed back by the App Store as a result of a successful purchase.
        FString ReceiptData;

        FRestoreIOSPurchasesRequest() :
            FPlayFabBaseModel(),
            ReceiptData()
            {}

        FRestoreIOSPurchasesRequest(const FRestoreIOSPurchasesRequest& src) :
            FPlayFabBaseModel(),
            ReceiptData(src.ReceiptData)
            {}

        FRestoreIOSPurchasesRequest(const TSharedPtr<FJsonObject>& obj) : FRestoreIOSPurchasesRequest()
        {
            readFromValue(obj);
        }

        ~FRestoreIOSPurchasesRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FRestoreIOSPurchasesResult : public FPlayFabBaseModel
    {
        FRestoreIOSPurchasesResult() :
            FPlayFabBaseModel()
            {}

        FRestoreIOSPurchasesResult(const FRestoreIOSPurchasesResult& src) :
            FPlayFabBaseModel()
            {}

        FRestoreIOSPurchasesResult(const TSharedPtr<FJsonObject>& obj) : FRestoreIOSPurchasesResult()
        {
            readFromValue(obj);
        }

        ~FRestoreIOSPurchasesResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FSendAccountRecoveryEmailRequest : public FPlayFabBaseModel
    {
        // User email address attached to their account
        FString Email;

        // [optional] The email template id of the account recovery email template to send.
        FString EmailTemplateId;

        /**
         * Unique identifier for the title, found in the Settings > Game Properties section of the PlayFab developer site when a
         * title has been selected.
         */
        FString TitleId;

        FSendAccountRecoveryEmailRequest() :
            FPlayFabBaseModel(),
            Email(),
            EmailTemplateId(),
            TitleId()
            {}

        FSendAccountRecoveryEmailRequest(const FSendAccountRecoveryEmailRequest& src) :
            FPlayFabBaseModel(),
            Email(src.Email),
            EmailTemplateId(src.EmailTemplateId),
            TitleId(src.TitleId)
            {}

        FSendAccountRecoveryEmailRequest(const TSharedPtr<FJsonObject>& obj) : FSendAccountRecoveryEmailRequest()
        {
            readFromValue(obj);
        }

        ~FSendAccountRecoveryEmailRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FSendAccountRecoveryEmailResult : public FPlayFabBaseModel
    {
        FSendAccountRecoveryEmailResult() :
            FPlayFabBaseModel()
            {}

        FSendAccountRecoveryEmailResult(const FSendAccountRecoveryEmailResult& src) :
            FPlayFabBaseModel()
            {}

        FSendAccountRecoveryEmailResult(const TSharedPtr<FJsonObject>& obj) : FSendAccountRecoveryEmailResult()
        {
            readFromValue(obj);
        }

        ~FSendAccountRecoveryEmailResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FSetFriendTagsRequest : public FPlayFabBaseModel
    {
        // PlayFab identifier of the friend account to which the tag(s) should be applied.
        FString FriendPlayFabId;

        // Array of tags to set on the friend account.
        TArray<FString> Tags;
        FSetFriendTagsRequest() :
            FPlayFabBaseModel(),
            FriendPlayFabId(),
            Tags()
            {}

        FSetFriendTagsRequest(const FSetFriendTagsRequest& src) :
            FPlayFabBaseModel(),
            FriendPlayFabId(src.FriendPlayFabId),
            Tags(src.Tags)
            {}

        FSetFriendTagsRequest(const TSharedPtr<FJsonObject>& obj) : FSetFriendTagsRequest()
        {
            readFromValue(obj);
        }

        ~FSetFriendTagsRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FSetFriendTagsResult : public FPlayFabBaseModel
    {
        FSetFriendTagsResult() :
            FPlayFabBaseModel()
            {}

        FSetFriendTagsResult(const FSetFriendTagsResult& src) :
            FPlayFabBaseModel()
            {}

        FSetFriendTagsResult(const TSharedPtr<FJsonObject>& obj) : FSetFriendTagsResult()
        {
            readFromValue(obj);
        }

        ~FSetFriendTagsResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FSetPlayerSecretRequest : public FPlayFabBaseModel
    {
        // [optional] Base64 encoded body that is encrypted with the Title's public RSA key (Enterprise Only).
        FString EncryptedRequest;

        // [optional] Player secret that is used to verify API request signatures (Enterprise Only).
        FString PlayerSecret;

        FSetPlayerSecretRequest() :
            FPlayFabBaseModel(),
            EncryptedRequest(),
            PlayerSecret()
            {}

        FSetPlayerSecretRequest(const FSetPlayerSecretRequest& src) :
            FPlayFabBaseModel(),
            EncryptedRequest(src.EncryptedRequest),
            PlayerSecret(src.PlayerSecret)
            {}

        FSetPlayerSecretRequest(const TSharedPtr<FJsonObject>& obj) : FSetPlayerSecretRequest()
        {
            readFromValue(obj);
        }

        ~FSetPlayerSecretRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FSetPlayerSecretResult : public FPlayFabBaseModel
    {
        FSetPlayerSecretResult() :
            FPlayFabBaseModel()
            {}

        FSetPlayerSecretResult(const FSetPlayerSecretResult& src) :
            FPlayFabBaseModel()
            {}

        FSetPlayerSecretResult(const TSharedPtr<FJsonObject>& obj) : FSetPlayerSecretResult()
        {
            readFromValue(obj);
        }

        ~FSetPlayerSecretResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FStartGameRequest : public FPlayFabBaseModel
    {
        // version information for the build of the game server which is to be started
        FString BuildVersion;

        // [optional] character to use for stats based matching. Leave null to use account stats
        FString CharacterId;

        // [optional] custom command line argument when starting game server process
        FString CustomCommandLineData;

        // the title-defined game mode this server is to be running (defaults to 0 if there is only one mode)
        FString GameMode;

        // the region to associate this server with for match filtering
        Region pfRegion;

        // [optional] player statistic for others to use in finding this game. May be null for no stat-based matching
        FString StatisticName;

        FStartGameRequest() :
            FPlayFabBaseModel(),
            BuildVersion(),
            CharacterId(),
            CustomCommandLineData(),
            GameMode(),
            pfRegion(),
            StatisticName()
            {}

        FStartGameRequest(const FStartGameRequest& src) :
            FPlayFabBaseModel(),
            BuildVersion(src.BuildVersion),
            CharacterId(src.CharacterId),
            CustomCommandLineData(src.CustomCommandLineData),
            GameMode(src.GameMode),
            pfRegion(src.pfRegion),
            StatisticName(src.StatisticName)
            {}

        FStartGameRequest(const TSharedPtr<FJsonObject>& obj) : FStartGameRequest()
        {
            readFromValue(obj);
        }

        ~FStartGameRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FStartGameResult : public FPlayFabBaseModel
    {
        // [optional] timestamp for when the server should expire, if applicable
        FString Expires;

        // [optional] unique identifier for the lobby of the server started
        FString LobbyID;

        // [optional] password required to log into the server
        FString Password;

        // [optional] server IPV4 address
        FString ServerHostname;

        // [optional] server IPV6 address
        FString ServerIPV6Address;

        // [optional] port on the server to be used for communication
        Boxed<int32> ServerPort;

        // [optional] unique identifier for the server
        FString Ticket;

        FStartGameResult() :
            FPlayFabBaseModel(),
            Expires(),
            LobbyID(),
            Password(),
            ServerHostname(),
            ServerIPV6Address(),
            ServerPort(),
            Ticket()
            {}

        FStartGameResult(const FStartGameResult& src) :
            FPlayFabBaseModel(),
            Expires(src.Expires),
            LobbyID(src.LobbyID),
            Password(src.Password),
            ServerHostname(src.ServerHostname),
            ServerIPV6Address(src.ServerIPV6Address),
            ServerPort(src.ServerPort),
            Ticket(src.Ticket)
            {}

        FStartGameResult(const TSharedPtr<FJsonObject>& obj) : FStartGameResult()
        {
            readFromValue(obj);
        }

        ~FStartGameResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FStartPurchaseRequest : public FPlayFabBaseModel
    {
        // [optional] Catalog version for the items to be purchased. Defaults to most recent catalog.
        FString CatalogVersion;

        // Array of items to purchase.
        TArray<FItemPurchaseRequest> Items;
        // [optional] Store through which to purchase items. If not set, prices will be pulled from the catalog itself.
        FString StoreId;

        FStartPurchaseRequest() :
            FPlayFabBaseModel(),
            CatalogVersion(),
            Items(),
            StoreId()
            {}

        FStartPurchaseRequest(const FStartPurchaseRequest& src) :
            FPlayFabBaseModel(),
            CatalogVersion(src.CatalogVersion),
            Items(src.Items),
            StoreId(src.StoreId)
            {}

        FStartPurchaseRequest(const TSharedPtr<FJsonObject>& obj) : FStartPurchaseRequest()
        {
            readFromValue(obj);
        }

        ~FStartPurchaseRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FStartPurchaseResult : public FPlayFabBaseModel
    {
        // [optional] Cart items to be purchased.
        TArray<FCartItem> Contents;
        // [optional] Purchase order identifier.
        FString OrderId;

        // [optional] Available methods by which the user can pay.
        TArray<FPaymentOption> PaymentOptions;
        // [optional] Current virtual currency totals for the user.
        TMap<FString, int32> VirtualCurrencyBalances;
        FStartPurchaseResult() :
            FPlayFabBaseModel(),
            Contents(),
            OrderId(),
            PaymentOptions(),
            VirtualCurrencyBalances()
            {}

        FStartPurchaseResult(const FStartPurchaseResult& src) :
            FPlayFabBaseModel(),
            Contents(src.Contents),
            OrderId(src.OrderId),
            PaymentOptions(src.PaymentOptions),
            VirtualCurrencyBalances(src.VirtualCurrencyBalances)
            {}

        FStartPurchaseResult(const TSharedPtr<FJsonObject>& obj) : FStartPurchaseResult()
        {
            readFromValue(obj);
        }

        ~FStartPurchaseResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FStatisticUpdate : public FPlayFabBaseModel
    {
        // unique name of the statistic
        FString StatisticName;

        // statistic value for the player
        int32 Value;

        /**
         * [optional] for updates to an existing statistic value for a player, the version of the statistic when it was loaded. Null when
         * setting the statistic value for the first time.
         */
        Boxed<uint32> Version;

        FStatisticUpdate() :
            FPlayFabBaseModel(),
            StatisticName(),
            Value(0),
            Version()
            {}

        FStatisticUpdate(const FStatisticUpdate& src) :
            FPlayFabBaseModel(),
            StatisticName(src.StatisticName),
            Value(src.Value),
            Version(src.Version)
            {}

        FStatisticUpdate(const TSharedPtr<FJsonObject>& obj) : FStatisticUpdate()
        {
            readFromValue(obj);
        }

        ~FStatisticUpdate();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FSubtractUserVirtualCurrencyRequest : public FPlayFabBaseModel
    {
        // Amount to be subtracted from the user balance of the specified virtual currency.
        int32 Amount;

        // Name of the virtual currency which is to be decremented.
        FString VirtualCurrency;

        FSubtractUserVirtualCurrencyRequest() :
            FPlayFabBaseModel(),
            Amount(0),
            VirtualCurrency()
            {}

        FSubtractUserVirtualCurrencyRequest(const FSubtractUserVirtualCurrencyRequest& src) :
            FPlayFabBaseModel(),
            Amount(src.Amount),
            VirtualCurrency(src.VirtualCurrency)
            {}

        FSubtractUserVirtualCurrencyRequest(const TSharedPtr<FJsonObject>& obj) : FSubtractUserVirtualCurrencyRequest()
        {
            readFromValue(obj);
        }

        ~FSubtractUserVirtualCurrencyRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUnlinkAndroidDeviceIDRequest : public FPlayFabBaseModel
    {
        /**
         * [optional] Android device identifier for the user's device. If not specified, the most recently signed in Android Device ID will be
         * used.
         */
        FString AndroidDeviceId;

        FUnlinkAndroidDeviceIDRequest() :
            FPlayFabBaseModel(),
            AndroidDeviceId()
            {}

        FUnlinkAndroidDeviceIDRequest(const FUnlinkAndroidDeviceIDRequest& src) :
            FPlayFabBaseModel(),
            AndroidDeviceId(src.AndroidDeviceId)
            {}

        FUnlinkAndroidDeviceIDRequest(const TSharedPtr<FJsonObject>& obj) : FUnlinkAndroidDeviceIDRequest()
        {
            readFromValue(obj);
        }

        ~FUnlinkAndroidDeviceIDRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUnlinkAndroidDeviceIDResult : public FPlayFabBaseModel
    {
        FUnlinkAndroidDeviceIDResult() :
            FPlayFabBaseModel()
            {}

        FUnlinkAndroidDeviceIDResult(const FUnlinkAndroidDeviceIDResult& src) :
            FPlayFabBaseModel()
            {}

        FUnlinkAndroidDeviceIDResult(const TSharedPtr<FJsonObject>& obj) : FUnlinkAndroidDeviceIDResult()
        {
            readFromValue(obj);
        }

        ~FUnlinkAndroidDeviceIDResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUnlinkCustomIDRequest : public FPlayFabBaseModel
    {
        /**
         * [optional] Custom unique identifier for the user, generated by the title. If not specified, the most recently signed in Custom ID
         * will be used.
         */
        FString CustomId;

        FUnlinkCustomIDRequest() :
            FPlayFabBaseModel(),
            CustomId()
            {}

        FUnlinkCustomIDRequest(const FUnlinkCustomIDRequest& src) :
            FPlayFabBaseModel(),
            CustomId(src.CustomId)
            {}

        FUnlinkCustomIDRequest(const TSharedPtr<FJsonObject>& obj) : FUnlinkCustomIDRequest()
        {
            readFromValue(obj);
        }

        ~FUnlinkCustomIDRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUnlinkCustomIDResult : public FPlayFabBaseModel
    {
        FUnlinkCustomIDResult() :
            FPlayFabBaseModel()
            {}

        FUnlinkCustomIDResult(const FUnlinkCustomIDResult& src) :
            FPlayFabBaseModel()
            {}

        FUnlinkCustomIDResult(const TSharedPtr<FJsonObject>& obj) : FUnlinkCustomIDResult()
        {
            readFromValue(obj);
        }

        ~FUnlinkCustomIDResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUnlinkFacebookAccountRequest : public FPlayFabBaseModel
    {
        FUnlinkFacebookAccountRequest() :
            FPlayFabBaseModel()
            {}

        FUnlinkFacebookAccountRequest(const FUnlinkFacebookAccountRequest& src) :
            FPlayFabBaseModel()
            {}

        FUnlinkFacebookAccountRequest(const TSharedPtr<FJsonObject>& obj) : FUnlinkFacebookAccountRequest()
        {
            readFromValue(obj);
        }

        ~FUnlinkFacebookAccountRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUnlinkFacebookAccountResult : public FPlayFabBaseModel
    {
        FUnlinkFacebookAccountResult() :
            FPlayFabBaseModel()
            {}

        FUnlinkFacebookAccountResult(const FUnlinkFacebookAccountResult& src) :
            FPlayFabBaseModel()
            {}

        FUnlinkFacebookAccountResult(const TSharedPtr<FJsonObject>& obj) : FUnlinkFacebookAccountResult()
        {
            readFromValue(obj);
        }

        ~FUnlinkFacebookAccountResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUnlinkGameCenterAccountRequest : public FPlayFabBaseModel
    {
        FUnlinkGameCenterAccountRequest() :
            FPlayFabBaseModel()
            {}

        FUnlinkGameCenterAccountRequest(const FUnlinkGameCenterAccountRequest& src) :
            FPlayFabBaseModel()
            {}

        FUnlinkGameCenterAccountRequest(const TSharedPtr<FJsonObject>& obj) : FUnlinkGameCenterAccountRequest()
        {
            readFromValue(obj);
        }

        ~FUnlinkGameCenterAccountRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUnlinkGameCenterAccountResult : public FPlayFabBaseModel
    {
        FUnlinkGameCenterAccountResult() :
            FPlayFabBaseModel()
            {}

        FUnlinkGameCenterAccountResult(const FUnlinkGameCenterAccountResult& src) :
            FPlayFabBaseModel()
            {}

        FUnlinkGameCenterAccountResult(const TSharedPtr<FJsonObject>& obj) : FUnlinkGameCenterAccountResult()
        {
            readFromValue(obj);
        }

        ~FUnlinkGameCenterAccountResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUnlinkGoogleAccountRequest : public FPlayFabBaseModel
    {
        FUnlinkGoogleAccountRequest() :
            FPlayFabBaseModel()
            {}

        FUnlinkGoogleAccountRequest(const FUnlinkGoogleAccountRequest& src) :
            FPlayFabBaseModel()
            {}

        FUnlinkGoogleAccountRequest(const TSharedPtr<FJsonObject>& obj) : FUnlinkGoogleAccountRequest()
        {
            readFromValue(obj);
        }

        ~FUnlinkGoogleAccountRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUnlinkGoogleAccountResult : public FPlayFabBaseModel
    {
        FUnlinkGoogleAccountResult() :
            FPlayFabBaseModel()
            {}

        FUnlinkGoogleAccountResult(const FUnlinkGoogleAccountResult& src) :
            FPlayFabBaseModel()
            {}

        FUnlinkGoogleAccountResult(const TSharedPtr<FJsonObject>& obj) : FUnlinkGoogleAccountResult()
        {
            readFromValue(obj);
        }

        ~FUnlinkGoogleAccountResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUnlinkIOSDeviceIDRequest : public FPlayFabBaseModel
    {
        /**
         * [optional] Vendor-specific iOS identifier for the user's device. If not specified, the most recently signed in iOS Device ID will
         * be used.
         */
        FString DeviceId;

        FUnlinkIOSDeviceIDRequest() :
            FPlayFabBaseModel(),
            DeviceId()
            {}

        FUnlinkIOSDeviceIDRequest(const FUnlinkIOSDeviceIDRequest& src) :
            FPlayFabBaseModel(),
            DeviceId(src.DeviceId)
            {}

        FUnlinkIOSDeviceIDRequest(const TSharedPtr<FJsonObject>& obj) : FUnlinkIOSDeviceIDRequest()
        {
            readFromValue(obj);
        }

        ~FUnlinkIOSDeviceIDRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUnlinkIOSDeviceIDResult : public FPlayFabBaseModel
    {
        FUnlinkIOSDeviceIDResult() :
            FPlayFabBaseModel()
            {}

        FUnlinkIOSDeviceIDResult(const FUnlinkIOSDeviceIDResult& src) :
            FPlayFabBaseModel()
            {}

        FUnlinkIOSDeviceIDResult(const TSharedPtr<FJsonObject>& obj) : FUnlinkIOSDeviceIDResult()
        {
            readFromValue(obj);
        }

        ~FUnlinkIOSDeviceIDResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUnlinkKongregateAccountRequest : public FPlayFabBaseModel
    {
        FUnlinkKongregateAccountRequest() :
            FPlayFabBaseModel()
            {}

        FUnlinkKongregateAccountRequest(const FUnlinkKongregateAccountRequest& src) :
            FPlayFabBaseModel()
            {}

        FUnlinkKongregateAccountRequest(const TSharedPtr<FJsonObject>& obj) : FUnlinkKongregateAccountRequest()
        {
            readFromValue(obj);
        }

        ~FUnlinkKongregateAccountRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUnlinkKongregateAccountResult : public FPlayFabBaseModel
    {
        FUnlinkKongregateAccountResult() :
            FPlayFabBaseModel()
            {}

        FUnlinkKongregateAccountResult(const FUnlinkKongregateAccountResult& src) :
            FPlayFabBaseModel()
            {}

        FUnlinkKongregateAccountResult(const TSharedPtr<FJsonObject>& obj) : FUnlinkKongregateAccountResult()
        {
            readFromValue(obj);
        }

        ~FUnlinkKongregateAccountResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUnlinkSteamAccountRequest : public FPlayFabBaseModel
    {
        FUnlinkSteamAccountRequest() :
            FPlayFabBaseModel()
            {}

        FUnlinkSteamAccountRequest(const FUnlinkSteamAccountRequest& src) :
            FPlayFabBaseModel()
            {}

        FUnlinkSteamAccountRequest(const TSharedPtr<FJsonObject>& obj) : FUnlinkSteamAccountRequest()
        {
            readFromValue(obj);
        }

        ~FUnlinkSteamAccountRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUnlinkSteamAccountResult : public FPlayFabBaseModel
    {
        FUnlinkSteamAccountResult() :
            FPlayFabBaseModel()
            {}

        FUnlinkSteamAccountResult(const FUnlinkSteamAccountResult& src) :
            FPlayFabBaseModel()
            {}

        FUnlinkSteamAccountResult(const TSharedPtr<FJsonObject>& obj) : FUnlinkSteamAccountResult()
        {
            readFromValue(obj);
        }

        ~FUnlinkSteamAccountResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUnlinkTwitchAccountRequest : public FPlayFabBaseModel
    {
        FUnlinkTwitchAccountRequest() :
            FPlayFabBaseModel()
            {}

        FUnlinkTwitchAccountRequest(const FUnlinkTwitchAccountRequest& src) :
            FPlayFabBaseModel()
            {}

        FUnlinkTwitchAccountRequest(const TSharedPtr<FJsonObject>& obj) : FUnlinkTwitchAccountRequest()
        {
            readFromValue(obj);
        }

        ~FUnlinkTwitchAccountRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUnlinkTwitchAccountResult : public FPlayFabBaseModel
    {
        FUnlinkTwitchAccountResult() :
            FPlayFabBaseModel()
            {}

        FUnlinkTwitchAccountResult(const FUnlinkTwitchAccountResult& src) :
            FPlayFabBaseModel()
            {}

        FUnlinkTwitchAccountResult(const TSharedPtr<FJsonObject>& obj) : FUnlinkTwitchAccountResult()
        {
            readFromValue(obj);
        }

        ~FUnlinkTwitchAccountResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUnlinkWindowsHelloAccountRequest : public FPlayFabBaseModel
    {
        // SHA256 hash of the PublicKey generated by Windows Hello.
        FString PublicKeyHint;

        FUnlinkWindowsHelloAccountRequest() :
            FPlayFabBaseModel(),
            PublicKeyHint()
            {}

        FUnlinkWindowsHelloAccountRequest(const FUnlinkWindowsHelloAccountRequest& src) :
            FPlayFabBaseModel(),
            PublicKeyHint(src.PublicKeyHint)
            {}

        FUnlinkWindowsHelloAccountRequest(const TSharedPtr<FJsonObject>& obj) : FUnlinkWindowsHelloAccountRequest()
        {
            readFromValue(obj);
        }

        ~FUnlinkWindowsHelloAccountRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUnlinkWindowsHelloAccountResponse : public FPlayFabBaseModel
    {
        FUnlinkWindowsHelloAccountResponse() :
            FPlayFabBaseModel()
            {}

        FUnlinkWindowsHelloAccountResponse(const FUnlinkWindowsHelloAccountResponse& src) :
            FPlayFabBaseModel()
            {}

        FUnlinkWindowsHelloAccountResponse(const TSharedPtr<FJsonObject>& obj) : FUnlinkWindowsHelloAccountResponse()
        {
            readFromValue(obj);
        }

        ~FUnlinkWindowsHelloAccountResponse();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUnlockContainerInstanceRequest : public FPlayFabBaseModel
    {
        /**
         * [optional] Specifies the catalog version that should be used to determine container contents. If unspecified, uses catalog
         * associated with the item instance.
         */
        FString CatalogVersion;

        // [optional] Unique PlayFab assigned ID for a specific character owned by a user
        FString CharacterId;

        // ItemInstanceId of the container to unlock.
        FString ContainerItemInstanceId;

        /**
         * [optional] ItemInstanceId of the key that will be consumed by unlocking this container. If the container requires a key, this
         * parameter is required.
         */
        FString KeyItemInstanceId;

        FUnlockContainerInstanceRequest() :
            FPlayFabBaseModel(),
            CatalogVersion(),
            CharacterId(),
            ContainerItemInstanceId(),
            KeyItemInstanceId()
            {}

        FUnlockContainerInstanceRequest(const FUnlockContainerInstanceRequest& src) :
            FPlayFabBaseModel(),
            CatalogVersion(src.CatalogVersion),
            CharacterId(src.CharacterId),
            ContainerItemInstanceId(src.ContainerItemInstanceId),
            KeyItemInstanceId(src.KeyItemInstanceId)
            {}

        FUnlockContainerInstanceRequest(const TSharedPtr<FJsonObject>& obj) : FUnlockContainerInstanceRequest()
        {
            readFromValue(obj);
        }

        ~FUnlockContainerInstanceRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUnlockContainerItemRequest : public FPlayFabBaseModel
    {
        /**
         * [optional] Specifies the catalog version that should be used to determine container contents. If unspecified, uses default/primary
         * catalog.
         */
        FString CatalogVersion;

        // [optional] Unique PlayFab assigned ID for a specific character owned by a user
        FString CharacterId;

        // Catalog ItemId of the container type to unlock.
        FString ContainerItemId;

        FUnlockContainerItemRequest() :
            FPlayFabBaseModel(),
            CatalogVersion(),
            CharacterId(),
            ContainerItemId()
            {}

        FUnlockContainerItemRequest(const FUnlockContainerItemRequest& src) :
            FPlayFabBaseModel(),
            CatalogVersion(src.CatalogVersion),
            CharacterId(src.CharacterId),
            ContainerItemId(src.ContainerItemId)
            {}

        FUnlockContainerItemRequest(const TSharedPtr<FJsonObject>& obj) : FUnlockContainerItemRequest()
        {
            readFromValue(obj);
        }

        ~FUnlockContainerItemRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUnlockContainerItemResult : public FPlayFabBaseModel
    {
        // [optional] Items granted to the player as a result of unlocking the container.
        TArray<FItemInstance> GrantedItems;
        // [optional] Unique instance identifier of the container unlocked.
        FString UnlockedItemInstanceId;

        // [optional] Unique instance identifier of the key used to unlock the container, if applicable.
        FString UnlockedWithItemInstanceId;

        // [optional] Virtual currency granted to the player as a result of unlocking the container.
        TMap<FString, uint32> VirtualCurrency;
        FUnlockContainerItemResult() :
            FPlayFabBaseModel(),
            GrantedItems(),
            UnlockedItemInstanceId(),
            UnlockedWithItemInstanceId(),
            VirtualCurrency()
            {}

        FUnlockContainerItemResult(const FUnlockContainerItemResult& src) :
            FPlayFabBaseModel(),
            GrantedItems(src.GrantedItems),
            UnlockedItemInstanceId(src.UnlockedItemInstanceId),
            UnlockedWithItemInstanceId(src.UnlockedWithItemInstanceId),
            VirtualCurrency(src.VirtualCurrency)
            {}

        FUnlockContainerItemResult(const TSharedPtr<FJsonObject>& obj) : FUnlockContainerItemResult()
        {
            readFromValue(obj);
        }

        ~FUnlockContainerItemResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUpdateAvatarUrlRequest : public FPlayFabBaseModel
    {
        // URL of the avatar image. If empty, it removes the existing avatar URL.
        FString ImageUrl;

        FUpdateAvatarUrlRequest() :
            FPlayFabBaseModel(),
            ImageUrl()
            {}

        FUpdateAvatarUrlRequest(const FUpdateAvatarUrlRequest& src) :
            FPlayFabBaseModel(),
            ImageUrl(src.ImageUrl)
            {}

        FUpdateAvatarUrlRequest(const TSharedPtr<FJsonObject>& obj) : FUpdateAvatarUrlRequest()
        {
            readFromValue(obj);
        }

        ~FUpdateAvatarUrlRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUpdateCharacterDataRequest : public FPlayFabBaseModel
    {
        // Unique PlayFab assigned ID for a specific character owned by a user
        FString CharacterId;

        /**
         * [optional] Key-value pairs to be written to the custom data. Note that keys are trimmed of whitespace, are limited in size, and may
         * not begin with a '!' character or be null.
         */
        TMap<FString, FString> Data;
        /**
         * [optional] Optional list of Data-keys to remove from UserData. Some SDKs cannot insert null-values into Data due to language
         * constraints. Use this to delete the keys directly.
         */
        TArray<FString> KeysToRemove;
        // [optional] Permission to be applied to all user data keys written in this request. Defaults to "private" if not set.
        Boxed<UserDataPermission> Permission;

        FUpdateCharacterDataRequest() :
            FPlayFabBaseModel(),
            CharacterId(),
            Data(),
            KeysToRemove(),
            Permission()
            {}

        FUpdateCharacterDataRequest(const FUpdateCharacterDataRequest& src) :
            FPlayFabBaseModel(),
            CharacterId(src.CharacterId),
            Data(src.Data),
            KeysToRemove(src.KeysToRemove),
            Permission(src.Permission)
            {}

        FUpdateCharacterDataRequest(const TSharedPtr<FJsonObject>& obj) : FUpdateCharacterDataRequest()
        {
            readFromValue(obj);
        }

        ~FUpdateCharacterDataRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUpdateCharacterDataResult : public FPlayFabBaseModel
    {
        /**
         * Indicates the current version of the data that has been set. This is incremented with every set call for that type of
         * data (read-only, internal, etc). This version can be provided in Get calls to find updated data.
         */
        uint32 DataVersion;

        FUpdateCharacterDataResult() :
            FPlayFabBaseModel(),
            DataVersion(0)
            {}

        FUpdateCharacterDataResult(const FUpdateCharacterDataResult& src) :
            FPlayFabBaseModel(),
            DataVersion(src.DataVersion)
            {}

        FUpdateCharacterDataResult(const TSharedPtr<FJsonObject>& obj) : FUpdateCharacterDataResult()
        {
            readFromValue(obj);
        }

        ~FUpdateCharacterDataResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUpdateCharacterStatisticsRequest : public FPlayFabBaseModel
    {
        // Unique PlayFab assigned ID for a specific character owned by a user
        FString CharacterId;

        // [optional] Statistics to be updated with the provided values.
        TMap<FString, int32> CharacterStatistics;
        FUpdateCharacterStatisticsRequest() :
            FPlayFabBaseModel(),
            CharacterId(),
            CharacterStatistics()
            {}

        FUpdateCharacterStatisticsRequest(const FUpdateCharacterStatisticsRequest& src) :
            FPlayFabBaseModel(),
            CharacterId(src.CharacterId),
            CharacterStatistics(src.CharacterStatistics)
            {}

        FUpdateCharacterStatisticsRequest(const TSharedPtr<FJsonObject>& obj) : FUpdateCharacterStatisticsRequest()
        {
            readFromValue(obj);
        }

        ~FUpdateCharacterStatisticsRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUpdateCharacterStatisticsResult : public FPlayFabBaseModel
    {
        FUpdateCharacterStatisticsResult() :
            FPlayFabBaseModel()
            {}

        FUpdateCharacterStatisticsResult(const FUpdateCharacterStatisticsResult& src) :
            FPlayFabBaseModel()
            {}

        FUpdateCharacterStatisticsResult(const TSharedPtr<FJsonObject>& obj) : FUpdateCharacterStatisticsResult()
        {
            readFromValue(obj);
        }

        ~FUpdateCharacterStatisticsResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUpdatePlayerStatisticsRequest : public FPlayFabBaseModel
    {
        // Statistics to be updated with the provided values
        TArray<FStatisticUpdate> Statistics;
        FUpdatePlayerStatisticsRequest() :
            FPlayFabBaseModel(),
            Statistics()
            {}

        FUpdatePlayerStatisticsRequest(const FUpdatePlayerStatisticsRequest& src) :
            FPlayFabBaseModel(),
            Statistics(src.Statistics)
            {}

        FUpdatePlayerStatisticsRequest(const TSharedPtr<FJsonObject>& obj) : FUpdatePlayerStatisticsRequest()
        {
            readFromValue(obj);
        }

        ~FUpdatePlayerStatisticsRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUpdatePlayerStatisticsResult : public FPlayFabBaseModel
    {
        FUpdatePlayerStatisticsResult() :
            FPlayFabBaseModel()
            {}

        FUpdatePlayerStatisticsResult(const FUpdatePlayerStatisticsResult& src) :
            FPlayFabBaseModel()
            {}

        FUpdatePlayerStatisticsResult(const TSharedPtr<FJsonObject>& obj) : FUpdatePlayerStatisticsResult()
        {
            readFromValue(obj);
        }

        ~FUpdatePlayerStatisticsResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUpdateSharedGroupDataRequest : public FPlayFabBaseModel
    {
        /**
         * [optional] Key-value pairs to be written to the custom data. Note that keys are trimmed of whitespace, are limited in size, and may
         * not begin with a '!' character or be null.
         */
        TMap<FString, FString> Data;
        /**
         * [optional] Optional list of Data-keys to remove from UserData. Some SDKs cannot insert null-values into Data due to language
         * constraints. Use this to delete the keys directly.
         */
        TArray<FString> KeysToRemove;
        // [optional] Permission to be applied to all user data keys in this request.
        Boxed<UserDataPermission> Permission;

        // Unique identifier for the shared group.
        FString SharedGroupId;

        FUpdateSharedGroupDataRequest() :
            FPlayFabBaseModel(),
            Data(),
            KeysToRemove(),
            Permission(),
            SharedGroupId()
            {}

        FUpdateSharedGroupDataRequest(const FUpdateSharedGroupDataRequest& src) :
            FPlayFabBaseModel(),
            Data(src.Data),
            KeysToRemove(src.KeysToRemove),
            Permission(src.Permission),
            SharedGroupId(src.SharedGroupId)
            {}

        FUpdateSharedGroupDataRequest(const TSharedPtr<FJsonObject>& obj) : FUpdateSharedGroupDataRequest()
        {
            readFromValue(obj);
        }

        ~FUpdateSharedGroupDataRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUpdateSharedGroupDataResult : public FPlayFabBaseModel
    {
        FUpdateSharedGroupDataResult() :
            FPlayFabBaseModel()
            {}

        FUpdateSharedGroupDataResult(const FUpdateSharedGroupDataResult& src) :
            FPlayFabBaseModel()
            {}

        FUpdateSharedGroupDataResult(const TSharedPtr<FJsonObject>& obj) : FUpdateSharedGroupDataResult()
        {
            readFromValue(obj);
        }

        ~FUpdateSharedGroupDataResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUpdateUserDataRequest : public FPlayFabBaseModel
    {
        /**
         * [optional] Key-value pairs to be written to the custom data. Note that keys are trimmed of whitespace, are limited in size, and may
         * not begin with a '!' character or be null.
         */
        TMap<FString, FString> Data;
        /**
         * [optional] Optional list of Data-keys to remove from UserData. Some SDKs cannot insert null-values into Data due to language
         * constraints. Use this to delete the keys directly.
         */
        TArray<FString> KeysToRemove;
        /**
         * [optional] Permission to be applied to all user data keys written in this request. Defaults to "private" if not set. This is used
         * for requests by one player for information about another player; those requests will only return Public keys.
         */
        Boxed<UserDataPermission> Permission;

        FUpdateUserDataRequest() :
            FPlayFabBaseModel(),
            Data(),
            KeysToRemove(),
            Permission()
            {}

        FUpdateUserDataRequest(const FUpdateUserDataRequest& src) :
            FPlayFabBaseModel(),
            Data(src.Data),
            KeysToRemove(src.KeysToRemove),
            Permission(src.Permission)
            {}

        FUpdateUserDataRequest(const TSharedPtr<FJsonObject>& obj) : FUpdateUserDataRequest()
        {
            readFromValue(obj);
        }

        ~FUpdateUserDataRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUpdateUserDataResult : public FPlayFabBaseModel
    {
        /**
         * Indicates the current version of the data that has been set. This is incremented with every set call for that type of
         * data (read-only, internal, etc). This version can be provided in Get calls to find updated data.
         */
        uint32 DataVersion;

        FUpdateUserDataResult() :
            FPlayFabBaseModel(),
            DataVersion(0)
            {}

        FUpdateUserDataResult(const FUpdateUserDataResult& src) :
            FPlayFabBaseModel(),
            DataVersion(src.DataVersion)
            {}

        FUpdateUserDataResult(const TSharedPtr<FJsonObject>& obj) : FUpdateUserDataResult()
        {
            readFromValue(obj);
        }

        ~FUpdateUserDataResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUpdateUserTitleDisplayNameRequest : public FPlayFabBaseModel
    {
        // New title display name for the user - must be between 3 and 25 characters.
        FString DisplayName;

        FUpdateUserTitleDisplayNameRequest() :
            FPlayFabBaseModel(),
            DisplayName()
            {}

        FUpdateUserTitleDisplayNameRequest(const FUpdateUserTitleDisplayNameRequest& src) :
            FPlayFabBaseModel(),
            DisplayName(src.DisplayName)
            {}

        FUpdateUserTitleDisplayNameRequest(const TSharedPtr<FJsonObject>& obj) : FUpdateUserTitleDisplayNameRequest()
        {
            readFromValue(obj);
        }

        ~FUpdateUserTitleDisplayNameRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FUpdateUserTitleDisplayNameResult : public FPlayFabBaseModel
    {
        // [optional] Current title display name for the user (this will be the original display name if the rename attempt failed).
        FString DisplayName;

        FUpdateUserTitleDisplayNameResult() :
            FPlayFabBaseModel(),
            DisplayName()
            {}

        FUpdateUserTitleDisplayNameResult(const FUpdateUserTitleDisplayNameResult& src) :
            FPlayFabBaseModel(),
            DisplayName(src.DisplayName)
            {}

        FUpdateUserTitleDisplayNameResult(const TSharedPtr<FJsonObject>& obj) : FUpdateUserTitleDisplayNameResult()
        {
            readFromValue(obj);
        }

        ~FUpdateUserTitleDisplayNameResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FValidateAmazonReceiptRequest : public FPlayFabBaseModel
    {
        // [optional] Catalog version to use when granting receipt item. If null, defaults to primary catalog.
        FString CatalogVersion;

        // Currency used for the purchase.
        FString CurrencyCode;

        // Amount of the stated currency paid for the object.
        int32 PurchasePrice;

        // ReceiptId returned by the Amazon App Store in-app purchase API
        FString ReceiptId;

        // AmazonId of the user making the purchase as returned by the Amazon App Store in-app purchase API
        FString UserId;

        FValidateAmazonReceiptRequest() :
            FPlayFabBaseModel(),
            CatalogVersion(),
            CurrencyCode(),
            PurchasePrice(0),
            ReceiptId(),
            UserId()
            {}

        FValidateAmazonReceiptRequest(const FValidateAmazonReceiptRequest& src) :
            FPlayFabBaseModel(),
            CatalogVersion(src.CatalogVersion),
            CurrencyCode(src.CurrencyCode),
            PurchasePrice(src.PurchasePrice),
            ReceiptId(src.ReceiptId),
            UserId(src.UserId)
            {}

        FValidateAmazonReceiptRequest(const TSharedPtr<FJsonObject>& obj) : FValidateAmazonReceiptRequest()
        {
            readFromValue(obj);
        }

        ~FValidateAmazonReceiptRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FValidateAmazonReceiptResult : public FPlayFabBaseModel
    {
        FValidateAmazonReceiptResult() :
            FPlayFabBaseModel()
            {}

        FValidateAmazonReceiptResult(const FValidateAmazonReceiptResult& src) :
            FPlayFabBaseModel()
            {}

        FValidateAmazonReceiptResult(const TSharedPtr<FJsonObject>& obj) : FValidateAmazonReceiptResult()
        {
            readFromValue(obj);
        }

        ~FValidateAmazonReceiptResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FValidateGooglePlayPurchaseRequest : public FPlayFabBaseModel
    {
        // [optional] Currency used for the purchase.
        FString CurrencyCode;

        // [optional] Amount of the stated currency paid for the object.
        Boxed<uint32> PurchasePrice;

        // Original JSON string returned by the Google Play IAB API.
        FString ReceiptJson;

        // Signature returned by the Google Play IAB API.
        FString Signature;

        FValidateGooglePlayPurchaseRequest() :
            FPlayFabBaseModel(),
            CurrencyCode(),
            PurchasePrice(),
            ReceiptJson(),
            Signature()
            {}

        FValidateGooglePlayPurchaseRequest(const FValidateGooglePlayPurchaseRequest& src) :
            FPlayFabBaseModel(),
            CurrencyCode(src.CurrencyCode),
            PurchasePrice(src.PurchasePrice),
            ReceiptJson(src.ReceiptJson),
            Signature(src.Signature)
            {}

        FValidateGooglePlayPurchaseRequest(const TSharedPtr<FJsonObject>& obj) : FValidateGooglePlayPurchaseRequest()
        {
            readFromValue(obj);
        }

        ~FValidateGooglePlayPurchaseRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FValidateGooglePlayPurchaseResult : public FPlayFabBaseModel
    {
        FValidateGooglePlayPurchaseResult() :
            FPlayFabBaseModel()
            {}

        FValidateGooglePlayPurchaseResult(const FValidateGooglePlayPurchaseResult& src) :
            FPlayFabBaseModel()
            {}

        FValidateGooglePlayPurchaseResult(const TSharedPtr<FJsonObject>& obj) : FValidateGooglePlayPurchaseResult()
        {
            readFromValue(obj);
        }

        ~FValidateGooglePlayPurchaseResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FValidateIOSReceiptRequest : public FPlayFabBaseModel
    {
        // Currency used for the purchase.
        FString CurrencyCode;

        // Amount of the stated currency paid for the object.
        int32 PurchasePrice;

        // Base64 encoded receipt data, passed back by the App Store as a result of a successful purchase.
        FString ReceiptData;

        FValidateIOSReceiptRequest() :
            FPlayFabBaseModel(),
            CurrencyCode(),
            PurchasePrice(0),
            ReceiptData()
            {}

        FValidateIOSReceiptRequest(const FValidateIOSReceiptRequest& src) :
            FPlayFabBaseModel(),
            CurrencyCode(src.CurrencyCode),
            PurchasePrice(src.PurchasePrice),
            ReceiptData(src.ReceiptData)
            {}

        FValidateIOSReceiptRequest(const TSharedPtr<FJsonObject>& obj) : FValidateIOSReceiptRequest()
        {
            readFromValue(obj);
        }

        ~FValidateIOSReceiptRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FValidateIOSReceiptResult : public FPlayFabBaseModel
    {
        FValidateIOSReceiptResult() :
            FPlayFabBaseModel()
            {}

        FValidateIOSReceiptResult(const FValidateIOSReceiptResult& src) :
            FPlayFabBaseModel()
            {}

        FValidateIOSReceiptResult(const TSharedPtr<FJsonObject>& obj) : FValidateIOSReceiptResult()
        {
            readFromValue(obj);
        }

        ~FValidateIOSReceiptResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FValidateWindowsReceiptRequest : public FPlayFabBaseModel
    {
        // [optional] Catalog version to use when granting receipt item. If null, defaults to primary catalog.
        FString CatalogVersion;

        // Currency used for the purchase.
        FString CurrencyCode;

        // Amount of the stated currency paid for the object.
        uint32 PurchasePrice;

        // XML Receipt returned by the Windows App Store in-app purchase API
        FString Receipt;

        FValidateWindowsReceiptRequest() :
            FPlayFabBaseModel(),
            CatalogVersion(),
            CurrencyCode(),
            PurchasePrice(0),
            Receipt()
            {}

        FValidateWindowsReceiptRequest(const FValidateWindowsReceiptRequest& src) :
            FPlayFabBaseModel(),
            CatalogVersion(src.CatalogVersion),
            CurrencyCode(src.CurrencyCode),
            PurchasePrice(src.PurchasePrice),
            Receipt(src.Receipt)
            {}

        FValidateWindowsReceiptRequest(const TSharedPtr<FJsonObject>& obj) : FValidateWindowsReceiptRequest()
        {
            readFromValue(obj);
        }

        ~FValidateWindowsReceiptRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FValidateWindowsReceiptResult : public FPlayFabBaseModel
    {
        FValidateWindowsReceiptResult() :
            FPlayFabBaseModel()
            {}

        FValidateWindowsReceiptResult(const FValidateWindowsReceiptResult& src) :
            FPlayFabBaseModel()
            {}

        FValidateWindowsReceiptResult(const TSharedPtr<FJsonObject>& obj) : FValidateWindowsReceiptResult()
        {
            readFromValue(obj);
        }

        ~FValidateWindowsReceiptResult();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FWriteClientCharacterEventRequest : public FPlayFabBaseModel
    {
        // [optional] Custom event properties. Each property consists of a name (string) and a value (JSON object).
        TMap<FString, FJsonKeeper> Body;
        // Unique PlayFab assigned ID for a specific character owned by a user
        FString CharacterId;

        /**
         * The name of the event, within the namespace scoped to the title. The naming convention is up to the caller, but it
         * commonly follows the subject_verb_object pattern (e.g. player_logged_in).
         */
        FString EventName;

        // [optional] The time (in UTC) associated with this event. The value dafaults to the current time.
        Boxed<FDateTime> Timestamp;

        FWriteClientCharacterEventRequest() :
            FPlayFabBaseModel(),
            Body(),
            CharacterId(),
            EventName(),
            Timestamp()
            {}

        FWriteClientCharacterEventRequest(const FWriteClientCharacterEventRequest& src) :
            FPlayFabBaseModel(),
            Body(src.Body),
            CharacterId(src.CharacterId),
            EventName(src.EventName),
            Timestamp(src.Timestamp)
            {}

        FWriteClientCharacterEventRequest(const TSharedPtr<FJsonObject>& obj) : FWriteClientCharacterEventRequest()
        {
            readFromValue(obj);
        }

        ~FWriteClientCharacterEventRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FWriteClientPlayerEventRequest : public FPlayFabBaseModel
    {
        // [optional] Custom data properties associated with the event. Each property consists of a name (string) and a value (JSON object).
        TMap<FString, FJsonKeeper> Body;
        /**
         * The name of the event, within the namespace scoped to the title. The naming convention is up to the caller, but it
         * commonly follows the subject_verb_object pattern (e.g. player_logged_in).
         */
        FString EventName;

        // [optional] The time (in UTC) associated with this event. The value dafaults to the current time.
        Boxed<FDateTime> Timestamp;

        FWriteClientPlayerEventRequest() :
            FPlayFabBaseModel(),
            Body(),
            EventName(),
            Timestamp()
            {}

        FWriteClientPlayerEventRequest(const FWriteClientPlayerEventRequest& src) :
            FPlayFabBaseModel(),
            Body(src.Body),
            EventName(src.EventName),
            Timestamp(src.Timestamp)
            {}

        FWriteClientPlayerEventRequest(const TSharedPtr<FJsonObject>& obj) : FWriteClientPlayerEventRequest()
        {
            readFromValue(obj);
        }

        ~FWriteClientPlayerEventRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FWriteEventResponse : public FPlayFabBaseModel
    {
        /**
         * [optional] The unique identifier of the event. The values of this identifier consist of ASCII characters and are not constrained to
         * any particular format.
         */
        FString EventId;

        FWriteEventResponse() :
            FPlayFabBaseModel(),
            EventId()
            {}

        FWriteEventResponse(const FWriteEventResponse& src) :
            FPlayFabBaseModel(),
            EventId(src.EventId)
            {}

        FWriteEventResponse(const TSharedPtr<FJsonObject>& obj) : FWriteEventResponse()
        {
            readFromValue(obj);
        }

        ~FWriteEventResponse();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

    struct PLAYFAB_API FWriteTitleEventRequest : public FPlayFabBaseModel
    {
        // [optional] Custom event properties. Each property consists of a name (string) and a value (JSON object).
        TMap<FString, FJsonKeeper> Body;
        /**
         * The name of the event, within the namespace scoped to the title. The naming convention is up to the caller, but it
         * commonly follows the subject_verb_object pattern (e.g. player_logged_in).
         */
        FString EventName;

        // [optional] The time (in UTC) associated with this event. The value dafaults to the current time.
        Boxed<FDateTime> Timestamp;

        FWriteTitleEventRequest() :
            FPlayFabBaseModel(),
            Body(),
            EventName(),
            Timestamp()
            {}

        FWriteTitleEventRequest(const FWriteTitleEventRequest& src) :
            FPlayFabBaseModel(),
            Body(src.Body),
            EventName(src.EventName),
            Timestamp(src.Timestamp)
            {}

        FWriteTitleEventRequest(const TSharedPtr<FJsonObject>& obj) : FWriteTitleEventRequest()
        {
            readFromValue(obj);
        }

        ~FWriteTitleEventRequest();

        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };

}
}
